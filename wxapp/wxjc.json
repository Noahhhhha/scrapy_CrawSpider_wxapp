{"title": "5个套路看懂微信小程序开发 ", "author": "2019-6-21 00:17", "pub_time": "2019-6-21 00:17", "content": "你或许听说过，快速入门就是要学最小必要知识。而我最近在看微信小程序的官方教程时发现，这个教程虽然简单，但对于微信小程序开发来说，80%的套路都能从这里学习到，你的小程序从0到1可以从这里实现突破。在开始之前，先做100字的铺垫。一个页面 = 4个文件小程序的每个页面都是由4个文件组成的 ，前两个最重要，是我们的重头戏。先给这几个文件一个简短的解释：js 文件——数据来源；wxml 文件——页面的骨架；wxss 文件——页面的装饰效果；json 文件——可选，配置页面上的零件。另外，本文的目标读者是真心想要尝试小程序的无经验开发者，英语水平要求中学及格水平以上。另外，为了你可以动手跟着做，请下载微信开发工具并注册微信小程序。部分语言过于通俗是为了更好的理解。绑定数据现在就开始我们的第一个套路。小程序简易教程 -> 编写代码 -> 创建页面 -> 第二个代码块依照小程序的定义，小程序中的每个页面都包含一个js文件。在一个 js 文件中，你需要列出这个页面上需要的数据（上图红框中的内容）。也就是说，data下面规定的数据（请努力去上图中找到 data），就是页面上需要用到的数据。这就叫做数据绑定。「数据绑定」对你来说可能是个新词汇。这里先不急着理解，我们的目标是会用，会用了就能理解一大半了。怎么应用「数据绑定」呢？只需要两步：1，声明；2，使用。声明的格式是这样的（类似上图中的内容）：Page({data: {greeting: 'Hello World'}//...})在微信开发工具中是这样的：注意看红框中的内容，和上面的代码块是一样的注意看 data 那个部分，我声明了名字为greeting的数据。（所谓数据，学名应该叫变量，但在我们的教程里可以近似理解。）第二步是使用。使用的意思是，我们到页面上把这个数据显示出来。方法是这样的：{{greeting}}注意看{{ }}之间的部分，我们只需要把刚刚定义好的数据名称写在两个大括号里就行了。顺带一提，这种使用数据的方法，叫做八字胡方法（英文Mustache），因为加上的两个大括号可以想象成嘴上的胡子。或许记住了胡子，你就记住了这种使用方法。这就完成了我们的第一个套路——数据绑定。简单吧！但是这里有一个疑问，我们在哪里使用绑定好的数据呢？也就是问，在哪里使用{{greeting}}这句程序呢？答案是我们的页面上，也就是 wxml 这个文件中。这就是我们的下一个套路——显示数据。显示数据上一个套路的讲解中，我们出现了这样一句程序{{greeting}}。这是在使用数据。但这行代码的完整版其实是这样的：<text class=\"your-class\">{{greeting}}</text>在微信开发工具中的样子是这样的：还是看红框内的内容，也请注意这是在 wxml 文件中我们对{{greeting}}这一部分已经熟悉，但对于它前面和后面的代码还不熟悉。所以我们现在进行讲解。显示数据时，我们其实希望显示出来的内容是很好看的。但如果你只写成{{greeting}}，显示出来的效果并不好：最左边红框中的文字一点装饰效果都没有为了让显示数据有更好看的效果，我们需要对{{greeting}}进行装饰。怎么装饰数据呢。我们要用2个东西：标签样式表什么是标签，我们从例子中来理解：{{greeting}}两边的<text class=\"your-class\">和</text>就是标签，而且分别叫开始标签和结束标签。（你能发现开始标签和结束标签的区别么？）开始标签可以定义一些属性，以便调整显示的结果。这就像是你画一幅画可以选择用毛笔，来画出国画的效果。在上面的例子中，class=\"your-class\"就是<text>这个标签的一个属性，<text>标签会表现出class=\"your-class\"的规定的样子。那么class=\"your-class\"这个属性的完整意思是什么呢？他的意思是<text>的 class 对应样式表中的your-class。对，你可以把等号理解为对应。而后面的\"your-class\"就是我们在样式表中规定好的一种装饰效果。这里出现了我们的第2个工具：样式表。样式表是写在 wxss 文件中的，我们来看看怎么写：.your-class {display: flex;flex-direction: column;align-items: center;color: blue;}在开发者工具中的样子是这样的：你通过理解代码中英文的字面意思就可以了解到，我把字的 color 定义为蓝色，把位置定义为 center。最重要的，是这个样式的名字，叫做.your-class，而<text>标签中的 class 属性，正好指向这个样式，所以<text>中的数据会变成中间位置的蓝色字。（在.your-class的最前面有一个点，那是对应<text>中 class 属性的特有标记，还有类似的标记[1]，可以在以后更多的实践中去理解)到这里，我们的前两个套路就已经简单的介绍完了。总结一下：绑定数据：在 js 文件中的 Page 模块下面定义 data 的名字，并用八字胡方法({{ }})来使用数据。显示数据：在 wxml 中给数据加上标签（比如 text 标签），并且给标签加上属性（比如 class 属性）。class 对应的样式在 wxss 文件中写好。不过，我们这里好像缺了什么。我好像没教大家怎么写最后一步的 wxss。微信文档说，wxss 和 css 大体上都是一样的[2]。大家可以去找找css的书，或者期待我后续的实践教程，带你一步一步写一个能上线的小程序。现在，如果你把这两个套路循环用起来，已经能解决很多问题了。想要多显示一个数据，就先在 js文件中绑定这个数据，然后去 wxml 文件中装饰数据。下面是绑定两个数据的示例代码：Page({data: {greeting: 'Hello World',farewell: 'Goodbye!'}//其他内容})而对应显示这两个数据的示例代码是这样的：<!--index.wxml--><text class=\"your-class\">{{greeting}}</text><view class=\"your-class\">{{farewell}}</view>在开发者工具中显示的样子是这样的：我在写教程的过程中升级了一次开发者工具，所以界面有变化大家可以看到，我在最右侧的红箭头处加入了一行新代码， 然后显示出了新数据。但是，这次不一样的是，我用了一个叫做<view>的标签，而不是之前的<text>标签。其实 wxml 文件中可以使用很多种标签来显示数据，有负责显示图片的，有可以负责滚动效果的的，他们都被写在微信文档中，你在实践的过程中可以查看。比如，我使用了一个叫做<icon>的标签，然后显示出了一个圆形的图标：有了「绑定数据」和「显示数据」这两个套路，我们已经能够写出一个简单的页面了。能够做到展示，但没有交互，所以我们进入第三个套路：绑定交互。绑定交互绑定交互这个名字听起来有没有和之前的「绑定数据」很像？他们的操作方法也很相似。绑定交互分为两步：声明：在 js 文件中声明交互的名称。使用：在 wxml 文件中使用这个交互。先来看「声明」。怎么声明一个交互呢？（或者用微信文档的说法，怎么来声明一个事件呢？）请在 js 文件中写下这样几行代码，就在我们之前绑定数据的 data 模块下面：changeWord: function() {this.setData({farewell: 'Never Say Goodbye!'})}在开发者工具中的样子是：这样，我们就声明了一个叫做changeWord的交互。这个交互的具体内容是，改变 farewell 这个数据的内容。原来是Goodbye!，现在我们要改成Never Say Goodbye!。而这个声明中function，this，setDate都是什么意思，我们在后面实践中再讲，大家关注的重点是这个声明中最前面的部分，也就是这个交互的名字：changeWord。我们已经声明完了这个交互，现在就该进入第2步——使用交互。请在 wxml 中插入这样的代码片段：<button bindtap=\"changeWord\" type='primary' class=\"your-button\" size='default'>改变文字</button>在开发者工具中的的样子是这样的：这里的重点是bindtap=\"changeWord\"，大家可以看到我们刚刚声明的交互changeWord出现了，那前面的bingtap=是什么呢？他的意思是：把点击事件的交互对应到changeWord。当你点一下图中的那个绿色按钮，我们的页面就会把Goodbye!换为 Never Say Goodbye!除了利用标签的bindtap属性来绑定交互，还可以用bindlongtap（绑定长按事件），bindtouchmove（绑定触摸后移动事件）等等，他们都有各自的效果。具体内容都被写在事件相关的文档中，你可以亲自试一下。你会发现他们的开头都是 bind，就好像单词的前缀一样，加上tap，longtap等后缀，就能帮你绑定一个交互。（绑定事件的前缀还有另外一种，叫catch，比如catchtap，catchtouchmove等等，你可以结合文档，试验一下他们的效果）[3]到这里，我们已经能够简单的绑定交互了。但绑定交互的核心目的是要改变页面上的显示，从而给用户一个反馈。下面就让我们来看看第4个套路：修改显示。执行交互就像绑定数据之后，要去显示数据。我们绑定交互之后，也要让交互被执行，这样才有意义。而交互的执行内容，就写在被声明的交互的下面：changeWord: function() {// 这里写交互的实际内容}我们这里介绍两种交互内容的写法，足够解决很多问题了：修改页面数据弹窗第一种，修改页面数据。我们在上一个套路的实例代码中已经见过：changeWord: function() {this.setData({farewell: 'Never Say Goodbye!'})}这几行代码中间的部分，就是要执行的交互内容：this.setData({farewell: 'Never Say Goodbye!'})即使你不懂得javaScript编程语言，也完全可以从英语的字面意思去理解这几行代码。这3行代码是在说，我这个页面(this)要修改数据(setData)中的farewell为 Never Say Goodbye!。如果你想修改其他数据，比如greeting，你可以如法炮制：changeAnotherWord: function() {this.setData({greeting: 'Hello, again!'})}你会发现这里面有很多结构是固定的。变化的部分只有交互的名称（变成了changeAnotherWord）和要修改的数据（变成了greeting: 'Hello, again!'）。如果你也想修改页面上的数据，请如法炮制。我们要介绍的第二种交互方法是弹窗，而且是微信内建的弹窗。首先，还是要做一下绑定交互这个套路：1，在 js 文件中声明一个交互；2，在 wxml 中使用这个交互。声明交互的代码如下（在 js 文件中），我们用showConfirmation作为名称： showConfirmation: function() {\r\n var that = this\r\n wx.showModal({\r\n title: '提示',\r\n content: '你确定要更改文字吗？',\r\n showCancel: true,\r\n cancelText: '取消',\r\n confirmText: '确定',\r\n success: function (response) { \r\n that.changeWord()\r\n }\r\n })\r\n }\r\n在微信开发者工具中是这样的：先不要在乎这里面陌生的代码，我们继续看使用交互的部分：<button bindtap=\"showConfirmation\" type='primary' class=\"your-button\" size='default'>改变文字</button>我把上一个套路中出现的 button 改写成了绑定到这个showConfirmation，在微信开发者工具中的样子是这样的：写完之后，我再去点「改变文字」的按钮，就会出现对话框：箭头连接的两部分是一样的，你发现了吗你会发现，所有的不一样，都只是在 js 文件中showConfirmation的下面，其他的部分都符合我们以前的套路。那我们就看看那段陌生的代码： var that = this\r\n wx.showModal({\r\n title: '提示',\r\n content: '你确定要更改文字吗？',\r\n showCancel: true,\r\n cancelText: '取消',\r\n confirmText: '确定',\r\n success: function (response) { \r\n that.changeWord()\r\n }\r\n })\r\n我们从wx.showModal看起，这是一个微信内建的代码表达方式，从英文的字面就能理解他是什么意思：请微信（wx）显示一下对话框（showModal）。那怎么用这个工具呢，微信的文档里面已经写好了：我们只需要像填空一样，把制作对话框需要的 title, content, showCancel 等需要填充的地方填好就可以了。这样，微信会帮助我们制作出一个对话框。但在这段代码中，有一个比较难解释的地方，就是var that = this和that.changeWord()。你能猜到他们是联动的，因为他们都有一个that。具体的意思是：把这个页面存储在那个地方（var that = this），让那个地方的数据中的文字改变（that.changeWord()）。为了避免混乱，我们暂时解释到这里。而且这两行也不影响我们制作一个对话框。因为制作对话框只需要做一件事[4]：使用wx.showModal跳转到这里，我们已经能在一个页面上使用4个套路了：绑定数据，显示数据，绑定交互，修改数据。如果你的小程序比较复杂，那么，是时候跳转到下一个页面来开辟一片新战场。要跳转到下一个页面，我们只需要最后一个套路：跳转。跳转本质上也是一种交互，我们完全可以用上面提到的「绑定交互」和「执行交互」来实现。再重复一遍这两步：1，在 js 文件中声明一个交互；2，在 wxml 中使用这个交互。我们先在 js 文件中声明一个名为navigateToLogs的交互：navigateToLogs: function() {wx.navigateTo({url: '/pages/logs/logs'})}在开发者工具中的样子是这样的：这里面有我们不太熟悉的代码，比如wx.navigateTo，根据上一个套路的经验，你已经能够大致猜到他的意思了，对么？不过我们还是把下一步走完再说。在 wxml 中使用这个交互：<button bindtap=\"navigateToLogs\" type='default' class=\"your-button\" size='default'>跳转</button>在开发者工具中的样子是这样的：好了，现在，如果我们点一下「跳转」按钮，他就会跳到下一页。已经看完了效果，我们回来看那段不熟悉的代码：wx.navigateTo({url: '/pages/logs/logs'})这一次，我们依然可以从字面理解：请微信（wx）导航到（navigateTo）logs 路径下的页面（url: '/pages/logs/logs'）。其中 url 这个数据是微信要求的，在文档中可以找到他的说明，我们依然是照着文档来填空就可以了[5]。这里面有一点需要说明，新页面的地址叫做'/pages/logs/logs'，他是从哪里来的呢？大家看下图红框中的文件结构，会发现 logs 这个页面的地址就是 pages 文件夹下面的 logs 文件夹下面的 logs 文件（有4个文件，但都叫 logs），用标准的格式表示，就成了我们刚刚提到的/pages/logs/logs。更进一步，按照微信的规定，我们还需要把他写在一个叫做app.json的配置文件中，这样微信才允许我们跳转到那个路径。总结一下好了，到这里，我们把5个套路都学完了。如果你能把他们组合起来，不断使用，你就能制作一个用很多功能的小程序：绑定数据——在 js 文件中声明数据名称显示数据——在 wxml 中写出数据显示的位置，并在 wxss 中写出装饰效果绑定交互——在 js 文件中声明交互的名称执行交互——在 js 文件中支出要修改的数据或者显示弹窗跳转——跳转到下一页，开辟新的战场番外篇——调取微信数据微信小程序其实还有一个隐含套路，叫做调用微信提供的接口。用微信官方的话讲，就是使用微信的能力。如果没有这些能力，微信小程序只能叫小程序，而不能叫「微信」小程序。其实，我们已经在上面见过一些微信小程序的能力了，比如显示弹窗的wx.showModal，比如跳转下一页的wx.navigateTo你已经发现，他们的特点都是wx.开头。更多的能力还有，还有获取用户头像，打开扫一扫这样的能力。他们怎么用呢？其实都是查文档，看看这个方法需要你提供哪些数据，提供给他就好了。用两个字总结就是：填空。最后的最后，轻轻说一句，对于刚刚入门的开发者，最大的坑可能是——忘记保存。因为我曾经也是个新手，在很多领域依然是新手，甚至还没有入门。希望这份教程能帮到你。共勉。这种标记叫做选择器，可以在这个小程序 wxss 文档的选择器那一节找到而且是个简版的css，不会用到复杂一点的级联样式另外，还有两类特殊的交互，为了避免大家混乱，我没有讲，但在我们后续的教程中会用到，感兴趣的朋友可以先了解一下：一类是某些标签特有的绑定方法，比如<checkbox-group>便签有一个特有属性 bindchange，可以用来绑定交互。另一类是用户关闭和打开页面时绑定的交互，比如onLoad，这类交互都是以 on 开头的，代表这个页面的事件，直接在 js 文件中声明，不用再 wxml 中绑定到标签。微信还有2个可用弹窗类交互，大家可以对照文档进行实验。微信出了提供wx.navigateTo这个跳转方法，还提供了其他4个导航相关的方法，你可以在实践中体会他们的区别。另外，微信还提供了<navigator>标签来实现跳转，跟wx.navigateTo等方法实现同样效果，为避免混乱，这里只留下文档地址，不详细举例。"}
{"title": "基于Proxy的小程序状态管理 ", "author": "2019-6-21 00:34", "pub_time": "2019-6-21 00:34", "content": "作者：wwayne原文： 基于Proxy的小程序状态管理Fundebug经授权转载，版权归原作者所有。微信小程序的市场在进一步的扩大，而背后的技术社区仍在摸索着最好的实践方案。我在帮助Nike，沃尔玛以及一些创业公司开发小程序后，依旧认为使用小程序原生框架是一个更高效，稳定的选择，而使用原生框架唯独缺少一个好的状态管理库，如果不引入状态管理则会让我们在模块化，项目结构以及单元测试上都有些捉襟见肘。目前相对比较稳健的做法是针对redux或者mobx做一个adaptor应用到小程序中，但这样需要自己想办法打包引入外部库，还要想怎么去写这个adaptor，总显得有些麻烦。于是我迸发出一个想法去写一个专用于小程序的状态管理库，它使用起来足够简单并且可以通过小程序自己的npm机制安装。目前我已经用这个开源库开发了两个电商小程序，在提高我开发效率的同时亦保证了程序的性能，所以接下来我想谈谈这背后的理念以启发更多开发者尝试新的解决方案。基于Proxy的状态管理实现Proxy在小程序中已经得到了足够好的支持，目前并没有发现在任何iPhone或者Android上不能使用Proxy的情况。而基于Proxy的状态管理其实也就是订阅监听的模式，一方面监听数据的变化，另一方面将这些变化传达给订阅的小程序页面。举一个比较常见的例子，当一个用户从自己的主页进入用户编辑页面，然后更改了自己的用户名点击保存后，用户主页和用户编辑页上的用户名这时候都应该被更新。这背后的程序逻辑则是：更新这个行为将触发Proxy去通知状态管理库，然后状态管理库负责检查此时还在页面栈中的所有页面，更新订阅了用户名这个数据的页面，如下图：Part1: 监听数据变化监听数据变化其实就是监听各个Store的属性变化，实现上就是在各个Store前面加了一层Proxy，用更直观的图片来表示就是这样：当一个Store被观察以后，它的属性就都变成了Proxy实例，当这个属性值是Object或者Array的时候，它内部的值也会被包装成Proxy实例，这样无论多深层的数据变动都能被监听到。而在Proxy的后面，Store的属性其实是被另一套数据(紫色部分)所维护，这套数据不负责监听，它就是纯数据，针对属性的任何变动最后都会应用到这套数据上来，它的作用是维护和返回最新的数据。实现细节： https://github.com/wwayne/min…Part2: 页面数据绑定因为小程序每个页面的js都是向Page中传递一个对象，这就让我们有机会包装这个对象，从而实现：进入页面后，将页面保存在页面栈中将来自状态管理库的数据映射到这个页面的data上来页面退出时，将页面从页面栈中移除实现细节： https://github.com/wwayne/min…Part3： 页面订阅更新当数据被监听到变化后，我们需要依次做两件事，先是找到所有存储在页面栈里的页面，然后根据各个页面订阅的数据来检查变化，如果有变化就通知这些页面，从而让它们去触发setData更新页面。实现细节： https://github.com/wwayne/min…使用状态管理的例子有了状态管理库，现在我们就来实现一开始举例的更新用户信息的操作，我们的文件路径如下：stores/\r\n  user.js\r\npages/\r\n  userEdit/\r\n     index.js\r\n     index.wxml\r\n1. 首先我们创建一个Store保存用户的信息，并且监听它的变化：// stores/user.js\r\nimport { observe } from 'minii'\r\n\r\nClass UserStore {\r\n  constructor () {\r\n     this.name = 'bob'\r\n  }\r\n\r\n  changeName (name) {\r\n     this.name = name\r\n  }\r\n}\r\n\r\nexport default observe(new UserStore(), 'user')\r\n2. 接着在我们的小程序页面订阅Store的信息// pages/userEdit/index.js\r\nimport { mapToData } from 'minii'\r\nimport userStore from '../../stores/user'\r\n\r\nconst connect = mapToData(state => (({\r\n  myName: state.user.name\r\n}))\r\nPage(connect({\r\n  updateNameToJames () {\r\n    userStore. changeName('james')\r\n  }\r\n}))\r\n3. 完成，现在可以在页面中使用和更新数据了// pages/userEdit/index.wxml\r\n<text>{{ myName }}</text>\r\n<button bindtap=\"updateNameToJames\">update name to James</button>\r\n最后小程序因为有体积的限制，所以我希望在代码量上也尽量做到轻量和便捷，所以目前这个状态管理库并没有太多很复杂的功能，在小程序打包后所占用的体积也不到1kb，颇有点够用就好的意思。我也已经用它开发了两款小程序，在经历了一段时间的用户使用后，我也更有信心说这个方案在小程序中是可行的。如果你有任何想法和建议，都欢迎告诉我。项目Github: https://github.com/wwayne/minii关于作者Hi, 我是wwayne，是一名居住在上海的独立软件工程师，我正在开发我的新产品 talk-to-kim , 你可以在 Github 或者专栏 一个人写代码 找到我"}
{"title": "小程序框架原理综合分析和 fard 的新思路 ", "author": "2019-6-24 00:07", "pub_time": "2019-6-24 00:07", "content": "halo，大家好，我是 132 ，好久不贱~今天给大家带来的是一个 fre 转小程序的新框架，叫 fard，它使用了非常精彩的思路，将 fre 代码跑到小程序环境里背景当下国内前端环境中，几乎每一个框架作者最终都会研究小程序，如 nerv 和 taro，anu 和 nanachi加上前阵子某人发微博说出 “hooks 无法用于别处，想用就得重新实现” 这种膝盖言论我急迫的想要给 fre 一个归宿，寻找适用于 fre 的小程序方案现有方案在做 fard 之前，我看了几乎所有的小程序框架，以下：编译型封装型tarowepynanachimpxmpvueuniappchameleon以上列举的只是常见的，还有很多小众的没有写出，小程序框架比小程序还多::>_<::编译型对于编译型框架，基本上就是 AST 转译，写 react/vue 的语法，编译出小程序的语法这样做的好处是理论上无所不能，啥都能转，甚至使用 parcel 的策略能让编译速度很快但是致命缺陷是，全程写的不是真的 react，react 内部的遍历过程根本没走，而且还需要制定足够严格的语法约定我认为，这个方向是走投无路的方向封装型封装型框架，基本就是对小程序的 API 进行封装，使其长得像 vue优点是能够最大程度的接近原生，缺点是没有足够的抽象层，无法跨端跨端了解完两种类型的框架，我们来探讨一下“跨端”跨端一直是很多人乐此不疲的事情，跨端的关键点在于寻找一个【抽象中间层】比如 taro 等使用 AST 作为抽象中间层flutter 使用各个端都支持的渲染引擎作为抽象中间层RN 自己搞了个 bridge，把桥作为抽象中间层weex 利用 v8 搞了个 runtime 作为抽象中间层(以上仅仅是举例，不要深究他们的原理)所以，fard 只需要寻找一个中间层，就完事了Fard 原理好吧，通篇，就这段是重点 ::>_<::首先，fard 是 fre 转小程序的框架，fre 是 react like 框架，它包含了整个 reconcilerreconciler 全程都是 js 的遍历行为，能够跑在任何 js 环境中，小程序也不例外所以最终 fard 的方案，就和 RN 类似，在小程序端跑 fre reconciler 过程，跑完再通过某个【桥】反馈给小程序视图好吧，上图如图，首先，在小程序里，跑 fre reconciler 的所有逻辑，hooks 就位于这个阶段，所以 hooks 所有逻辑，都是在 fre 中跑完的跑完后就好说了，我们拿到了一个 vdom (也可以说 fiber，但是我们只需要子集 vdom )拿到这个 vdom 后，就去 setData，附加给 Page好的，到这里，可以说全程 js 逻辑，该拿到的都拿到了，就差怎么反馈给视图了小程序自身也是 vdom 机制的，如果说它默认提供 vdom 的接口的话，我们直接将 vdom 附加过去即可但是并没有，小程序开放的唯一的修改视图的方法就是 template所以我们需要根据 vdom 改造 template，使其成为桥梁这个也非常简单，比如 vdom 长这个样子：let vdom = {\r\n    name:'@2',\r\n    type:'view',\r\n    children:[\r\n        {\r\n            name:'@1',\r\n            type:'text'\r\n        }\r\n    ]\r\n}\r\n复制代码我们完全可以通过 template 模拟出来<template is=\"@2\">\r\n    <view>\r\n        <block wx:for=\"{{props.children}}\" wx:key=\"\">\r\n            <template is=\"{{item.name}}\"></template>\r\n      </block>\r\n    </view>\r\n</template>\r\n\r\n<template is=\"@1\">\r\n    <text></text>\r\n</template>\r\n\r\n复制代码我们可以通过 template 模拟出整个 vdom，很好，bridge 就这么搞定了其实到这里，fard 就搞定了剩下的就是，增加更多的 case，封装更多的通用 API，提高性能了综合分析我们看到 fard 是类似 RN 的原理，我们高度抽象 fre 的 reconciler 层和小程序的 template bridge，使得整个设计非常的简单却精彩而且它能够完美的支持 jsx 和 hooks API，不存在任何约定任何限制任何规范毕竟，这才是 jsx 真正的意义同样的，hooks API 自出现以来，关于它内部的黑魔法也一直令人津津乐道，我用实际行动证明，hooks API 完全可以用到任何端，也包括 webgl前提是要有设计精巧的抽象中间层"}
{"title": "小程序生成海报代码分享 ", "author": "2019-6-24 00:26", "pub_time": "2019-6-24 00:26", "content": "今天下午花了一下午时间把之前项目添加了对海报生成的支持,本代码已提交到微信，已通过审核，已发布，已经过本人验收，以下功能可用需要的同学可以移步下面链接https://gitee.com/jgl1210/eas...本代码实现功能1、海报上添加图片2、海报上添加文字3、海报下载4、海报保存到本地"}
{"title": "微信小程序自定义组件boundingClientRect获取到的rect值为null ", "author": "2019-6-24 00:36", "pub_time": "2019-6-24 00:36", "content": "解决办法：在自定义组件内获取必须用SelectorQuery.in()Component({\r\n  lifetimes: {\r\n    ready() {\r\n      const query = wx.createSelectorQuery().in(this)\r\n      const num = Math.ceil(this.data.picList.length / LINE_LENGTH)\r\n      query.select('.tab-content-item').boundingClientRect((rect) => {\r\n        this.setData({\r\n          swiperHeight: rect.height * num + 'rpx'\r\n        })\r\n      }).exec()\r\n    }\r\n  },\r\n})const query = wx.createSelectorQuery().in(this)这一句是最重要的，要用.in(this)，this传入的是自定义组件的实例。否则获取到的rect值为null"}
{"title": "微信小程序组件化开发框架WePY ", "author": "2019-6-24 00:48", "pub_time": "2019-6-24 00:48", "content": "compilers： compilers为1.3.1版本之后的功能，如果需要使用其它语法，请先配置compilers，然后再安装相应的compilers。目前支持wepy-compiler-less， wepy-compiler-postcss，wepy-compiler-sass、wepy-compiler-babel、wepy-compiler-pug，其他compiler持续开发中......\r\nplugins： plugins为1.1.6版本之后的功能，目前支持js压缩wepy-plugin-ugliyjs、图片压缩wepy-plugin-imagemin，其他plugin持续开发中......\r\nlang决定了其代码编译过程，src决定是否外联代码\r\n<style lang=\"less\" src=\"page1.less\"></style>\r\n<template lang=\"wxml\" src=\"page1.wxml\"></template>\r\n<script>\r\n    // some code\r\n</script>\r\n\r\n<script>\r\nimport wepy from 'wepy';\r\nexport default class extends wepy.app {\r\n    config = {\r\n        \"pages\":[\r\n            \"pages/index/index\"\r\n        ],\r\n        \"window\":{\r\n            \"backgroundTextStyle\": \"light\",\r\n            \"navigationBarBackgroundColor\": \"#fff\",\r\n            \"navigationBarTitleText\": \"WeChat\",\r\n            \"navigationBarTextStyle\": \"black\"\r\n        }\r\n    };\r\n    onLaunch() {\r\n        console.log(this);\r\n    }\r\n}\r\n</script>\r\n\r\n<style lang=\"less\">\r\n/** less **/\r\n</style>\r\n\r\n<script>\r\nimport wepy from 'wepy';\r\nimport Counter from '../components/counter';\r\n\r\nexport default class Page extends wepy.page {\r\n    config = {};\r\n    components = {counter1: Counter};\r\n\r\n    data = {};\r\n    methods = {};\r\n\r\n    events = {};\r\n    onLoad() {};\r\n    // Other properties\r\n}\r\n</script>\r\n\r\n<template lang=\"wxml\">\r\n    <view>\r\n    </view>\r\n    <counter1></counter1>\r\n</template>\r\n\r\n<style lang=\"less\">\r\n/** less **/\r\n</style>\r\n\r\n<template lang=\"wxml\">\r\n    <view>  </view>\r\n</template>\r\n\r\n<script>\r\nimport wepy from 'wepy';\r\nexport default class Com extends wepy.component {\r\n    components = {};\r\n\r\n    data = {};\r\n    methods = {};\r\n\r\n    events = {};\r\n    // Other properties\r\n}\r\n</script>\r\n\r\n<style lang=\"less\">\r\n/** less **/\r\n</style>\r\n\r\nimport wepy from 'wepy';\r\n\r\n// 声明一个App小程序实例\r\nexport default class MyAPP extends wepy.app {\r\n}\r\n\r\n// 声明一个Page页面实例\r\nexport default class IndexPage extends wepy.page {\r\n}\r\n\r\n// 声明一个Component组件实例\r\nexport default class MyComponent extends wepy.component {\r\n}\r\n\r\nimport wepy from 'wepy';\r\n\r\nexport default class MyAPP extends wepy.app {\r\n    customData = {};\r\n\r\n    customFunction ()　{ }\r\n\r\n    onLaunch () {}\r\n\r\n    onShow () {}\r\n\r\n    config = {}  // 对应 app.json 文件\r\n\r\n    globalData = {}\r\n}\r\n\r\n在Page页面实例中，可以通过this.$parent来访问App实例。\r\nimport wepy from 'wepy';\r\n\r\nexport default class MyPage extends wepy.page {\r\n// export default class MyComponent extends wepy.component {\r\n    customData = {}  // 自定义数据\r\n\r\n    customFunction ()　{}  //自定义方法\r\n\r\n    onLoad () {}  // 在Page和Component共用的生命周期函数\r\n\r\n    onShow () {}  // 只在Page中存在的页面生命周期函数\r\n\r\n    config = {};  // 只在Page实例中存在的配置数据，对应于原生的page.json文件\r\n\r\n    data = {};  // 页面所需数据均需在这里声明，可用于模板数据绑定\r\n\r\n    components = {};  // 声明页面中所引用的组件，或声明组件中所引用的子组件\r\n\r\n    mixins = [];  // 声明页面所引用的Mixin实例\r\n\r\n    computed = {};  // 声明计算属性（详见后文介绍）\r\n\r\n    watch = {};  // 声明数据watcher（详见后文介绍）\r\n\r\n    methods = {};  // 声明页面wxml中标签的事件处理函数。注意，此处只用于声明页面wxml中标签的bind、catch事件，自定义方法需以自定义方法的方式声明\r\n\r\n    events = {};  // 声明组件之间的事件处理函数\r\n}\r\n\r\n// 错误示例\r\n\r\nimport wepy from 'wepy';\r\n\r\nexport default class MyComponent extends wepy.component {\r\n    methods = {\r\n        bindtap () {\r\n            let rst = this.commonFunc();\r\n            // doSomething\r\n        },\r\n\r\n        bindinput () {\r\n            let rst = this.commonFunc();\r\n            // doSomething\r\n        },\r\n\r\n        //错误：普通自定义方法不能放在methods对象中\r\n        customFunction () {\r\n            return 'sth.';\r\n        }\r\n    };\r\n\r\n}\r\n\r\n// 正确示例\r\n\r\nimport wepy from 'wepy';\r\n\r\nexport default class MyComponent extends wepy.component {\r\n    methods = {\r\n        bindtap () {\r\n            let rst = this.commonFunc();\r\n            // doSomething\r\n        },\r\n\r\n        bindinput () {\r\n            let rst = this.commonFunc();\r\n            // doSomething\r\n        },\r\n    }\r\n\r\n    //正确：普通自定义方法在methods对象外声明，与methods平级\r\n    customFunction () {\r\n        return 'sth.';\r\n    }\r\n\r\n}\r\n\r\n/**\r\nproject\r\n└── src\r\n    ├── components\r\n    |   └── child.wpy\r\n    ├── pages\r\n    |   ├── index.wpy    index 页面配置、结构、样式、逻辑\r\n    |   └── log.wpy      log 页面配置、结构、样式、逻辑\r\n    └──app.wpy           小程序配置项（全局公共配置、公共样式、声明钩子等）\r\n**/\r\n\r\n// index.wpy\r\n\r\n<template>\r\n    <!-- 以`<script>`脚本部分中所声明的组件ID为名命名自定义标签，从而在`<template>`模板部分中插入组件 -->\r\n    <child></child>\r\n</template>\r\n\r\n<script>\r\n    import wepy from 'wepy';\r\n    //引入组件文件\r\n    import Child from '../components/child';\r\n\r\n    export default class Index extends wepy.page {\r\n        //声明组件，分配组件id为child\r\n        components = {\r\n            child: Child\r\n        };\r\n    }\r\n</script>\r\n\r\n\r\n<template>\r\n    <view class=\"child1\">\r\n        <child></child>\r\n    </view>\r\n\r\n    <view class=\"child2\">\r\n        <anotherchild></anotherchild>\r\n    </view>\r\n</template>\r\n\r\n\r\n<script>\r\n    import wepy from 'wepy';\r\n    import Child from '../components/child';\r\n\r\n    export default class Index extends wepy.page {\r\n        components = {\r\n            //为两个相同组件的不同实例分配不同的组件ID，从而避免数据同步变化的问题\r\n            child: Child,\r\n            anotherchild: Child\r\n        };\r\n    }\r\n</script>\r\n\r\n/**\r\nproject\r\n└── src\r\n    ├── components\r\n    |   └── child.wpy\r\n    ├── pages\r\n    |   ├── index.wpy    index 页面配置、结构、样式、逻辑\r\n    |   └── log.wpy      log 页面配置、结构、样式、逻辑\r\n    └──app.wpy           小程序配置项（全局样式配置、声明钩子等）\r\n**/\r\n\r\n// index.wpy\r\n\r\n<template>\r\n    <!-- 注意，使用for属性，而不是使用wx:for属性 -->\r\n    <repeat for=\"{{list}}\" key=\"index\" index=\"index\" item=\"item\">\r\n        <!-- 插入<script>脚本部分所声明的child组件，同时传入item -->\r\n        <child :item=\"item\"></child>\r\n    </repeat>\r\n</template>\r\n\r\n<script>\r\n    import wepy from 'wepy';\r\n    // 引入child组件文件\r\n    import Child from '../components/child';\r\n\r\n    export default class Index extends wepy.page {\r\n        components = {\r\n            // 声明页面中要使用到的Child组件的ID为child\r\n            child: Child\r\n        }\r\n\r\n        data = {\r\n            list: [{id: 1, title: 'title1'}, {id: 2, title: 'title2'}]\r\n        }\r\n    }\r\n</script>\r\n\r\n\r\n  data = {\r\n      a: 1\r\n  }\r\n\r\n  // 计算属性aPlus，在脚本中可通过this.aPlus来引用，在模板中可通过{{ aPlus }}来插值\r\n  computed = {\r\n      aPlus () {\r\n          return this.a + 1\r\n      }\r\n  }\r\n\r\n通过监听器watcher能够监听到任何属性的更新。监听器在watch对象中声明，类型为函数，函数名与需要被监听的data对象中的属性同名，每当被监听的属性改变一次，监听器函数就会被自动调用执行一次。\r\n data = {\r\n      num: 1\r\n  }\r\n\r\n  // 监听器函数名必须跟需要被监听的data对象中的属性num同名，\r\n  // 其参数中的newValue为属性改变后的新值，oldValue为改变前的旧值\r\n  watch = {\r\n      num (newValue, oldValue) {\r\n          console.log(`num value: ${oldValue} -> ${newValue}`)\r\n      }\r\n  }\r\n\r\n  // 每当被监听的属性num改变一次，对应的同名监听器函数num()就被自动调用执行一次\r\n  onLoad () {\r\n      setInterval(() => {\r\n          this.num++;\r\n          this.$apply();\r\n      }, 1000)\r\n  }\r\n\r\n\r\nprops = {\r\n    fromShopCar: Number\r\n  }\r\n\r\nprops传值\r\n静态传值为父组件向子组件传递常量数据，因此只能传递String字符串类型。\r\n在父组件template模板部分的组件标签中，使用子组件props对象中所声明的属性名作为其属性名来接收父组件传递的值。\r\n<child title=\"mytitle\"></child>\r\n\r\n// child.wpy\r\nprops = {\r\n    title: String\r\n};\r\n\r\nonLoad () {\r\n    console.log(this.title); // mytitle\r\n}\r\n\r\n\r\n// parent.wpy\r\n\r\n<child :title=\"parentTitle\" :syncTitle.sync=\"parentTitle\" :twoWayTitle=\"parentTitle\"></child>\r\n\r\ndata = {\r\n    parentTitle: 'p-title'\r\n};\r\n\r\n\r\n// child.wpy\r\n\r\nprops = {\r\n    // 静态传值\r\n    title: String,\r\n\r\n    // 父向子单向动态传值\r\n    syncTitle: {\r\n        type: String,\r\n        default: 'null'\r\n    },\r\n\r\n    twoWayTitle: {\r\n        type: String,\r\n        default: 'nothing',\r\n        twoWay: true\r\n    }\r\n};\r\n\r\nonLoad () {\r\n    console.log(this.title); // p-title\r\n    console.log(this.syncTitle); // p-title\r\n    console.log(this.twoWayTitle); // p-title\r\n\r\n    this.title = 'c-title';\r\n    console.log(this.$parent.parentTitle); // p-title.\r\n    this.twoWayTitle = 'two-way-title';\r\n    this.$apply();\r\n    console.log(this.$parent.parentTitle); // two-way-title.  --- twoWay为true时，子组件props中的属性值改变时，会同时改变父组件对应的值\r\n    this.$parent.parentTitle = 'p-title-changed';\r\n    this.$parent.$apply();\r\n    console.log(this.title); // 'c-title';\r\n    console.log(this.syncTitle); // 'p-title-changed' --- 有.sync修饰符的props属性值，当在父组件中改变时，会同时改变子组件对应的值。\r\n}\r\n\r\nwepy.component基类提供emit、$invoke三个方法用于组件之间的通信和交互\r\nimport wepy from 'wepy'\r\n\r\nexport default class Com extends wepy.component {\r\n    components = {};\r\n\r\n    data = {};\r\n\r\n    methods = {};\r\n\r\n    // events对象中所声明的函数为用于监听组件之间的通信与交互事件的事件处理函数\r\n    events = {\r\n        'some-event': (p1, p2, p3, $event) => {\r\n               console.log(`${this.$name} receive ${$event.name} from ${$event.source.$name}`);\r\n        }\r\n    };\r\n    // Other properties\r\n}\r\n\r\n@表示事件修饰符，customEvent 表示事件名称，.user表示事件后缀。\r\n目前总共有三种事件后缀：\r\n.default: 绑定小程序冒泡型事件，如bindtap，.default后缀可省略不写；\r\n.stop: 绑定小程序捕获型事件，如catchtap；\r\n.user: 绑定用户自定义组件事件，通过$emit触发。注意，如果用了自定义事件，则events中对应的监听函数不会再执行。\r\n// index.wpy\r\n\r\n<template>\r\n    <child @childFn.user=\"parentFn\"></child>\r\n</template>\r\n\r\n<script>\r\n    import wepy from 'wepy'\r\n    import Child from '../components/child'\r\n\r\n    export default class Index extends wepy.page {\r\n        components = {\r\n            child: Child\r\n        }\r\n\r\n        methods = {\r\n            parentFn (num, evt) {\r\n                console.log('parent received emit event, number is: ' + num)\r\n            }\r\n        }\r\n    }\r\n</script>\r\n\r\n\r\n// child.wpy\r\n\r\n<template>\r\n    <view @tap=\"tap\">Click me</view>\r\n</template>\r\n\r\n<script>\r\n    import wepy from 'wepy'\r\n\r\n    export default class Child extends wepy.component {\r\n        methods = {\r\n            tap () {\r\n                console.log('child is clicked')\r\n                this.$emit('childFn', 100)\r\n            }\r\n        }\r\n    }\r\n</script>\r\n\r\nslot 组件内容分发插槽\r\n在Panel组件中有以下模板：\r\n<view class=\"panel\">\r\n    <slot name=\"title\">默认标题</slot>\r\n    <slot name=\"content\">默认内容</slot>\r\n</view>\r\n在父组件中使用Panel子组件时，可以这样使用：\r\n\r\n<panel>\r\n    <view slot=\"title\">新的标题</view>\r\n    <view slot=\"content\">\r\n        <text>新的内容</text>\r\n    </view>\r\n</panel>\r\n\r\n\r\n// mixins/test.js\r\nimport wepy from 'wepy';\r\n\r\nexport default class TestMixin extends wepy.mixin {\r\n    data = {\r\n        foo: 'foo defined by page',\r\n        bar: 'bar defined by testMix'\r\n    };\r\n    methods = {\r\n    tap () {\r\n      console.log('mix tap');\r\n    }\r\n  }\r\n}\r\n\r\n// pages/index.wpy\r\nimport wepy from 'wepy';\r\nimport TestMixin from './mixins/test';\r\n\r\nexport default class Index extends wepy.page {\r\n    data = {\r\n        foo: 'foo defined by index'\r\n    };\r\n    mixins = [TestMixin ];\r\n    onShow() {\r\n        console.log(this.foo); // foo defined by index\r\n        console.log(this.bar); // bar defined by testMix\r\n    }\r\n}\r\n\r\n// mixins/test.js\r\nimport wepy from 'wepy';\r\n\r\nexport default class TestMixin extends wepy.mixin {\r\n    methods = {\r\n        tap () {\r\n            console.log('mixin tap');\r\n        }\r\n    };\r\n    onShow() {\r\n        console.log('mixin onshow');\r\n    }\r\n}\r\n\r\n// pages/index.wpy\r\nimport wepy from 'wepy';\r\nimport TestMixin from './mixins/test';\r\n\r\nexport default class Index extends wepy.page {\r\n\r\n    mixins = [TestMixin];\r\n    methods = {\r\n        tap () {\r\n            console.log('index tap');\r\n        }\r\n    };\r\n    onShow() {\r\n        console.log('index onshow');\r\n    }\r\n}\r\n\r\n\r\n// index onshow\r\n// mixin onshow\r\n// ----- when tap\r\n// index tap\r\n// mixin tap\r\n\r\n\r\nimport wepy from 'wepy';\r\n\r\nexport default class extends wepy.app {\r\n    constructor () {\r\n        // this is not allowed before super()\r\n        super();\r\n        // 拦截request请求\r\n        this.intercept('request', {\r\n            // 发出请求时的回调函数\r\n            config (p) {\r\n                // 对所有request请求中的OBJECT参数对象统一附加时间戳属性\r\n                p.timestamp = +new Date();\r\n                console.log('config request: ', p);\r\n                // 必须返回OBJECT参数对象，否则无法发送请求到服务端\r\n                return p;\r\n            },\r\n\r\n            // 请求成功后的回调函数\r\n            success (p) {\r\n                // 可以在这里对收到的响应数据对象进行加工处理\r\n                console.log('request success: ', p);\r\n                // 必须返回响应数据对象，否则后续无法对响应数据进行处理\r\n                return p;\r\n            },\r\n\r\n            //请求失败后的回调函数\r\n            fail (p) {\r\n                console.log('request fail: ', p);\r\n                // 必须返回响应数据对象，否则后续无法对响应数据进行处理\r\n                return p;\r\n            },\r\n\r\n            // 请求完成时的回调函数(请求成功或失败都会被执行)\r\n            complete (p) {\r\n                console.log('request complete: ', p);\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nWePY脏数据检查流程\r\n// 原生代码:\r\n\r\nwx.request({\r\n    url: 'xxx',\r\n    success: function (data) {\r\n        console.log(data);\r\n    }\r\n});\r\n\r\n// WePY 使用方式, 需要开启 Promise 支持，参考开发规范章节\r\nwepy.request('xxxx').then((d) => console.log(d));\r\n\r\n// async/await 的使用方式, 需要开启 Promise 和 async/await 支持，参考 WIKI\r\nasync function request () {\r\n   let d = await wepy.request('xxxxx');\r\n   console.log(d);\r\n}\r\n\r\n// 原生的事件传参方式:\r\n\r\n<view data-id=\"{{index}}\" data-title=\"wepy\" data-other=\"otherparams\" bindtap=\"tapName\"> Click me! </view>\r\n\r\nPage({\r\n    tapName: function (event) {\r\n        console.log(event.currentTarget.dataset.id)// output: 1\r\n        console.log(event.currentTarget.dataset.title)// output: wepy\r\n        console.log(event.currentTarget.dataset.other)// output: otherparams\r\n    }\r\n});\r\n\r\n// WePY 1.1.8以后的版本，只允许传string。\r\n\r\n<view @tap=\"tapName({{index}}, 'wepy', 'otherparams')\"> Click me! </view>\r\n\r\nmethods: {\r\n    tapName (id, title, other, event) {\r\n        console.log(id, title, other)// output: 1, wepy, otherparams\r\n    }\r\n}\r\n\r\n// 原生代码:\r\n\r\n<view> {{ message }} </view>\r\n\r\nonLoad: function () {\r\n    this.setData({message: 'hello world'});\r\n}\r\n\r\n\r\n// WePY\r\n<view> {{ message }} </view>\r\n\r\nonLoad () {\r\n    this.message = 'hello world';\r\n}\r\n\r\n// 原生代码:\r\n\r\n<!-- item.wxml -->\r\n<template name=\"item\">\r\n  <text>{{text}}</text>\r\n</template>\r\n\r\n<!-- index.wxml -->\r\n<import src=\"item.wxml\"/>\r\n<template is=\"item\" data=\"{{text: 'forbar'}}\"/>\r\n\r\n<!-- index.js -->\r\nvar item = require('item.js')\r\n\r\n// WePY\r\n<!-- /components/item.wpy -->\r\n <text>{{text}}</text>\r\n\r\n<!-- index.wpy -->\r\n<template>\r\n    <com></com>\r\n</template>\r\n<script>\r\n    import wepy from 'wepy';\r\n    import Item from '../components/item';\r\n    export default class Index extends wepy.page {\r\n        components = { com: Item }\r\n    }\r\n</script>\r\n\r\n\r\n请点赞！因为你的鼓励是我写作的最大动力！"}
{"title": "mpvue框架使用记录 ", "author": "2019-6-25 00:16", "pub_time": "2019-6-25 00:16", "content": "最近公司接了一个订制小程序，是从APP改成微信小程序，考虑用 mpvue 框架来开发，发现还是有些坑的，下面说一下这两天使用下来的感受。template 中不支持 methods 中的函数，也没有filter过滤器，数据要预先处理比较麻烦突然想到可以用组件来预处理数据，比如项目中图片url的拼接和替换域名创建新页面比较繁琐每次创建新页面按常规流程是:新建页面文件夹 → 新建 index.vue ， main.js ， main.json 并填入页面基本内容 → 在项目 app.json 中添加页面信息。最开始我的解决方法是创建了一个模板页面，每次新建页面的时候复制一份，重命名。但是还是很麻烦，需要手动向 app.json 中添加页面路径，干脆用node写了一个快速添加页面的小工具将工具文件 addpage.js 放在mpvue项目根目录，运行 node addpage目前有一个参数可以配置新增页面的属性，是设置vue文件中用到的预处理器类型用法： node addpage wxss ， node addpage sass填入需要创建的页面路径和标题就会在 src/pages/ 下创建页面，包含三个基本文件，并自动向app.json 中写入本次创建的路径 支持多级目录页面的创建，方便分类页面，如 demo/demo1 , demo/demo2要注意的是，输入的路径下有其他页面时，会创建失败，比如创建了 demo/demo1 后，再创建 demo 就会失败如果改变了目录结构请删除 dist 文件夹重新构建下面是addpage.js的全部代码const fs = require('fs')\r\nconst readline = require('readline')\r\nconst path = require('path')\r\nconst colors = require('colors')\r\nconst rl = readline.createInterface({\r\n  input: process.stdin,\r\n  output: process.stdout\r\n})\r\n\r\n//获取运行时附带参数，目前只定义了vue文件中的css语言类型和页面标题\r\nlet arguments = process.argv.splice(2);\r\nlet caaLang = arguments[0]\r\n\r\nlet appJson = JSON.parse(fs.readFileSync('./src/app.json', 'utf8').toString())\r\n\r\nrl.question(' 请输入页面路径: '.bgBlue, (pathStr) => {\r\n  rl.question(' 请输入页面标题: '.bgBlue, (title) => {\r\n    pageTitle = title\r\n    pageCreate(pathStr)\r\n  })\r\n})\r\n\r\nfunction pageCreate(pathStr){\r\n  let jsonPush = `pages/${pathStr}/main`\r\n  let stop = false\r\n  appJson.pages.forEach((item) => {\r\n    let pathArr = item.split('/')\r\n    let pathStrArr = pathStr.split('/')\r\n    if (pathArr.length > 3 && pathStrArr.length === 1 && pathArr.indexOf(pathStrArr[0]) !== -1) {\r\n      stop = true\r\n    }\r\n  })\r\n\r\n  if (stop) {\r\n    console.log(' 此路径下有其他页面，不可直接作为页面路径 '.bgRed);\r\n    rl.close()\r\n    return\r\n  }\r\n\r\n  if (appJson.pages.indexOf(jsonPush) !== -1) {\r\n    console.log(' 此页面已存在 '.bgRed)\r\n    rl.close()\r\n    return\r\n  }\r\n  //app.json pages数组中没有，项目结构中有，此时已有的文件夹会被删除\r\n  deleteFolder('./src/pages/' + pathStr)\r\n  try {\r\n    mkdirsSync('./src/pages/' + pathStr)\r\n  } catch (error) {\r\n    console.log(error);\r\n  }\r\n\r\n  if (writePage('./src/pages/' + pathStr)) {\r\n    //加入本次创建的页面路径\r\n    appJson.pages.push(jsonPush)\r\n    //写入app.json\r\n    fs.writeFile('./src/app.json', JSON.stringify(appJson, null, \"\\t\"), function (err) {\r\n      if (err) {\r\n        console.error(err)\r\n      }\r\n      console.log(' ----------新增成功---------- '.bgGreen)\r\n      rl.close()\r\n    })\r\n  }\r\n}\r\n\r\n//删除文件夹\r\nfunction deleteFolder(path) {\r\n  var files = [];\r\n  if (fs.existsSync(path)) {\r\n    files = fs.readdirSync(path);\r\n    files.forEach(function (file, index) {\r\n      var curPath = path + \"/\" + file;\r\n      if (fs.statSync(curPath).isDirectory()) { // recurse\r\n        deleteFolder(curPath);\r\n      } else { // delete file\r\n        fs.unlinkSync(curPath);\r\n      }\r\n    });\r\n    fs.rmdirSync(path);\r\n  }\r\n}\r\n//创建多级目录\r\nfunction mkdirsSync(dirname) {\r\n  if (fs.existsSync(dirname)) {\r\n    return true;\r\n  } else {\r\n    if (mkdirsSync(path.dirname(dirname))) {\r\n      fs.mkdirSync(dirname);\r\n      return true;\r\n    }\r\n  }\r\n}\r\n\r\n//写入目标页面的三个文件\r\nfunction writePage(path) {\r\n  try {\r\n    fs.writeFileSync(path + '/index.vue', `<template>\r\n  <div class=\"page-container\">\r\n\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  data() {\r\n    return {}\r\n  }\r\n}\r\n</script>\r\n\r\n<style lang=\"${caaLang?caaLang:'scss'}\" scoped>\r\n.page-container {\r\n  min-height: 100vh;\r\n  background-color: #f5f5f5;\r\n  background-image: linear-gradient(to bottom, #00d164, #00d164);\r\n  background-repeat: no-repeat;\r\n  background-size: 100% 170rpx;\r\n  background-position: top center;\r\n  padding-bottom: 65rpx;\r\n}\r\n</style>`, 'utf8');\r\n    fs.writeFileSync(path + '/main.js', `import Vue from 'vue'\r\nimport App from './index'\r\n    \r\nconst app = new Vue(App)\r\napp.$mount()`, 'utf8')\r\n    fs.writeFileSync(path + '/main.json', `{\r\n  \"navigationBarTitleText\": \"${pageTitle}\"\r\n}`, 'utf8')\r\n    return true\r\n  } catch (error) {\r\n    //写入错误删除该文件夹\r\n    deleteFolder(path)\r\n    console.log(' 创建页面失败 '.bgRed);\r\n    throw error\r\n  }\r\n}\r\n复制代码个人博客【花喵电台】"}
{"title": "小程序打怪之在线客服自动回复功能(node版) ", "author": "2019-6-13 00:14", "pub_time": "2019-6-13 00:14", "content": "我们知道H5页面经常需要将用户导流到APP，通过下载安装包或者跳转至应用宝市场/Appstore等方式进行导流。但是由于小程序嵌套webview时需要校验域名，因此跳转到第三方应用市场和Appstroe无法实现导流。那怎么办呢? 只能说道高一尺魔高一丈，看看微博小程序是怎么导流的:曲线救国的方式，利用小程序的在线功能可以打开H5的方式，去进行下载引导。 于是，就引出了这次文档的主题，小程序在线客服自动回复功能。:laughing:阅读本文档之前，最好已经了解过小程序客服信息官方的相关文档:1. 客服消息使用指南2. 小程序客服消息服务端接口3. 客服消息开发文档这次开发做在线客服功能也踩了不少坑，网上也查阅不少资料，但大部分的后台都是基于php或者python,java开发，node.js开发的较少，因此将这次开发的流程记录一下，供大家参考，避免大家踩坑。可能会有一些错误地方欢迎指正交流。 另外，我们用的node框架是基于koa自行封装的，在一些细节实现上和其他框架会有区别，不必纠结。需求描述小程序中点按钮跳转在线客服界面，根据关键词自动回复 客服回复判断条件，支持cms配置key，及 respond respond 支持配置以下类型，及回复内容:type内容texttext=文本回复内容linktitle=标题 description=描述 url=跳转链接 thumb_url=图片地址imageimageurl=图片地址配置后用户需要精准匹配回复条件才可收到自动回复可支持配置多个key，及对应respond除了配置的key以外的回复，可配置默认的自动回复开发流程写个跳转客服的按钮吧index.wxml<button open-type=\"contact\">转在线客服</button>\r\n复制代码后台配置登录小程序后台后，在「开发」-「开发设置」-「消息推送」中，管理员扫码启用消息服务，填写服务器地址（URL）、令牌（Token） 和 消息加密密钥（EncodingAESKey）等信息。URL服务器地址URL: 开发者用来接收微信消息和事件的接口 URL。开发者所填写的URL 必须以 http:// 或 https:// 开头，分别支持 80 端口和 443 端口。务必要记住，服务器地址必须是 线上 地址，因为需要微信服务器去访问。localhost，IP，内网地址都不行的。不然会提示 '解析失败，请检查信息是否填写正确'。那么问题来了，不同的公司都有一套上线流程，总不能为了调试URL是否可用要上到线上去测试，成本太大，也不方便。这就要引出 内网穿透 了，简单来说就是配置一个线上域名，但是这个域名可以穿透到你配置的本地开发地址上，这样可以方便你去调试看日志。 推荐一个可以实现内网穿透的工具。(非广告 :laughing:)NATAPP 具体不详细介绍，免得广告嫌疑。简单说，NATAPP有免费和付费两种模式，免费的是域名不定时更换，对于微信的推送消息配置一个月只有3次更改机会来说，有点奢侈。不定什么时候配置的域名就不能访问，得重新配置。而付费的则是固定域名，映射的内网地址也可以随时更改。楼主从免费切到付费模式，一个月的VIP使用大概十几块钱吧。2.TokenToken自己随便写就行了，但是要记住它，因为你在接口中要用的。3.EncodingAESKey随机生成即可。4.加密方式和数据格式根据自己喜欢选择，楼主选择的安全模式和JSON格式。 不同的模式和数据格式，在开发上会有不同，自己衡量。 既然这些配置都清楚，那开始码代码。验证消息的确来自微信服务器配置提交前，需要把验证消息来自微信服务器的接口写好。server.js/*\r\n     * https://developers.weixin.qq.com/miniprogram/dev/framework/server-ability/message-push.html\r\n     * 验证消息的确来自微信服务器\r\n     * 开发者通过检验 signature 对请求进行校验（下面有校验方式）。\r\n     * 若确认此次 GET 请求来自微信服务器，请原样返回 echostr 参数内容，\r\n     * 则接入生效，成为开发者成功，否则接入失败。加密/校验流程如下：\r\n     * 将token、timestamp、nonce三个参数进行字典序排序\r\n     * 将三个参数字符串拼接成一个字符串进行sha1加密\r\n     * 开发者获得加密后的字符串可与signature对比，标识该请求来源于微信\r\n     */\r\n     const crypto = require('crypto');\r\n     async wxCallbackAction(){\r\n        const ctx = this.ctx;\r\n        const method = ctx.method;\r\n     \t//微信服务器签名验证，确认请求来自微信\r\n     \tif(method === 'GET') {\r\n     \t\t// 1.获取微信服务器Get请求的参数 signature、timestamp、nonce、echostr\r\n     \t\tconst {\r\n     \t\t\tsignature,\r\n     \t\t\ttimestamp,\r\n     \t\t\tnonce,\r\n     \t\t\techostr\r\n     \t\t} = ctx.query;\r\n     \t\t\r\n     \t\t// 2.将token、timestamp、nonce三个参数进行字典序排序\r\n     \t\tlet array = ['yourToken', timestamp, nonce];\r\n     \t\tarray.sort();\r\n     \t\t\r\n     \t\t// 3.将三个参数字符串拼接成一个字符串进行sha1加密\r\n     \t\tconst tempStr = array.join('');\r\n     \t\tconst hashCode = crypto.createHash('sha1'); //创建加密类型\r\n     \t\tconst resultCode = hashCode.update(tempStr, 'utf8').digest('hex');\r\n     \t\t\r\n     \t\t// 4.开发者获得加密后的字符串可与signature对比，标识该请求来源于微信\r\n     \t\tif (resultCode === signature) {\r\n     \t\t\tconsole.log('验证成功，消息是从微信服务器转发过来');\r\n     \t\t\treturn this.json(echostr);\r\n     \t\t}else {\r\n     \t\t\tconsole.log('验证失败！！！');\r\n     \t\t\treturn this.json({\r\n     \t\t\t\tstatus: -1,\r\n     \t\t\t\tmessage: \"验证失败\"\r\n     \t\t\t});\r\n     \t\t}\r\n            \r\n     \t}\r\n     }\r\n复制代码验证接口开发完毕，后台配置可以去点提交了。配置成功会提示如下:接收消息和推送消息当用户在客服会话发送消息、或由某些特定的用户操作引发事件推送时，微信服务器会将消息或事件的数据包发送到开发者填写的 URL。开发者收到请求后可以使用发送客服消息接口进行异步回复。本文以接收文本消息为例开发:server.jsconst WXDecryptContact = require('./WXDecryptContact');\r\n    async wxCallbackAction(){\r\n        const ctx = this.ctx;\r\n        const method = ctx.method;\r\n        //接收信息时为POST请求；(完整代码自行与上面验证时的合并即可)\r\n        if(method === 'POST'){\r\n            const { Encrypt } = ctx.request.body;\r\n            //配置时选的安全模式 因此需要解密\r\n            if(!Encrypt){\r\n                return this.json('success');\r\n            }\r\n            const decryptData = WXDecryptContact(Encrypt);\r\n            await this._handleWxMsg(decryptData);\r\n            return this.json('success');\r\n \t\t}\r\n \t}\r\n \t\r\n \t//处理微信回调消息的总入口 (只处理了文本类型，其他类型自行添加)\r\n    async _handleWxMsg(msgJson){\r\n        if(!msgJson){\r\n            return ;\r\n        }\r\n\r\n        const { MsgType } = msgJson;\r\n        if(MsgType === 'text'){\r\n            await this._sendTextMessage(msgJson);\r\n        }\r\n        \r\n    }\r\n    //微信文本信息关键字自动回复\r\n    async _sendTextMessage(msgJson){\r\n \t    //获取CMS客服关键词回复配置\r\n \t    const result = await this.callService('cms.getDataByName', 'wxApplet.contact');\r\n \t\t\r\n \t\tlet keyWordObj = result.data || {};\r\n \t\r\n \t\t//默认回复default\r\n \t\tlet options = keyWordObj.default;\r\n \t\tfor(let key in keyWordObj){\r\n \t\t\t//查看是否命中配置的关键词\r\n \t\t\tif(msgJson.Content === key){\r\n \t\t\t    //CMS配置项\r\n \t\t\t\toptions = keyWordObj[key];\r\n \t\t\t}\r\n \t\t}\r\n \t}\r\n \t\t\r\n \t//获取access_token\r\n \tconst accessToken = await this._getAccessToken();\r\n \t\r\n \t/*\r\n \t* 先判断配置回复的消息类型是不是image类型\r\n \t* 如果是 则需要先通过 新增素材接口 上传图片文件获得 media_id\r\n \t*/\r\n \t\r\n \tlet media_id = '';\r\n \tif(options.type === 'image'){\r\n \t\t//获取图片地址(相对路径)\r\n \t\tlet url = options.url;\r\n \t\tconst file = fs.createReadStream(url);\r\n \t\t\r\n \t\t//调用微信 uploadTempMedia接口 具体实现见 service.js\r\n \t\tconst mediaResult = await this.callService('wxApplet.uploadTempMedia',\r\n \t\t\t{\r\n \t\t\t\taccess_token: accessToken,\r\n \t\t\t\ttype: 'image'\r\n \t\t\t},\r\n \t\t\t{\r\n \t\t\t\tmedia: file\r\n \t\t\t}\r\n \t\t);\r\n \t\t\r\n \t\tif(mediaResult.status === 0){\r\n \t\t\tmedia_id = mediaResult.data.media_id;\r\n \t\t}else {\r\n \t\t\t//如果图片id获取失败 则按默认处理\r\n \t\t\toptions = keyWordObj.default;\r\n \t\t}\r\n \t}\r\n \t\r\n \t//回复信息给用户\r\n \tconst sendMsgResult = await this.callService('wxApplet.sendMessageToCustomer',\r\n \t\t{\r\n \t\t\taccess_token: accessToken,\r\n \t\t\ttouser: msgJson.FromUserName,\r\n \t\t\tmsgtype: options.type || 'text',\r\n \t\t\ttext: {\r\n \t\t\t\tcontent: options.description || '',\r\n \t\t\t},\r\n \t\t\tlink: options.type === \"link\" ? \r\n \t\t\t\t{\r\n \t\t\t\t\ttitle: options.title,\r\n \t\t\t\t\tdescription: options.description,\r\n \t\t\t\t\turl: options.url,\r\n \t\t\t\t\tthumb_url: options.thumb_url\r\n \t\t\t\t}\r\n \t\t\t\t:\r\n \t\t\t\t{},\r\n \t\t\timage: {\r\n \t\t\t\tmedia_id\r\n \t\t\t}\r\n \t\t}\r\n \t);\r\n \t\r\n }\r\n复制代码service.jsconst request = require('request');\r\n\r\n\r\n/*\r\n* 获取CMS客服关键词回复配置\r\n* 这个接口只是为了回去CMS配置的字段回复关键字配置 返回的data数据结构如下\r\n*/\r\nasync contact(){\r\n\treturn {\r\n\t\tdata: {\r\n\t\t\t\"1\": {\r\n\t\t\t    \"type\": \"link\",\r\n\t\t\t    \"title\": \"点击下载[****]APP\",\r\n\t\t\t    \"description\": \"注册领取领***元注册红包礼\",\r\n\t\t\t    \"url\": \"https://m.renrendai.com/mo/***.html\",\r\n\t\t\t    \"thumb_url\": \"https://m.we.com/***/test.png\"\r\n\t\t\t  },\r\n\t\t\t  \"2\": {\r\n\t\t\t    \"url\": \"http://m.renrendai.com/cms/****/test.jpg\",\r\n\t\t\t    \"type\": \"image\"\r\n\t\t\t  },\r\n\t\t\t  \"3\": {\r\n\t\t\t    \"url\": \"/cms/***/test02.png\",\r\n\t\t\t    \"type\": \"image\"\r\n\t\t\t  },\r\n\t\t\t  \"default\": {\r\n\t\t\t    \"type\": \"text\",\r\n\t\t\t    \"description\": \"再见\"\r\n\t\t\t  }\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/*\r\n * 把媒体文件上传到微信服务器。目前仅支持图片。用于发送客服消息或被动回复用户消息。\r\n * https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/customer-message/customerServiceMessage.uploadTempMedia.html\r\n */\r\n \r\n async uploadTempMedia(data,formData){\r\n \tconst url = `https://api.weixin.qq.com/cgi-bin/media/upload?access_token=${data.access_token}&type=${data.type}`;\r\n \treturn new Promise((resolve, reject) => {\r\n \t\trequest.post({url, formData: formData}, (err, response, body) => {\r\n \t\t\ttry{\r\n \t\t\t\tconst out = JSON.parse(body);\r\n \t\t\t\tlet result = {\r\n \t\t\t\t\tdata: out,\r\n \t\t\t\t\tstatus: 0,\r\n \t\t\t\t\tmessage: \"ok\"\r\n \t\t\t\t}\r\n \t\t\t\t\r\n \t\t\t\treturn resolve(result);\r\n \t\t\t\r\n \t\t\t}catch(err){\r\n \t\t\t\treturn reject({\r\n \t\t\t\t\tstatus: -1,\r\n \t\t\t\t\tmessage: err.message\r\n \t\t\t\t});\r\n \t\t\t}\r\n \t\t});\r\n \t}\r\n }\r\n \r\n /*\r\n * 发送客服消息给用户\r\n * https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/customer-message/customerServiceMessage.send.html\r\n */\r\n \r\n async sendMessageToCustomer(data){\r\n \tconst url = `https://api.weixin.qq.com/cgi-bin/message/custom/send?access_token=${data.access_token}`;\r\n \treturn new Promise((resolve, reject) => {\r\n \t\trequest.post({url, data}, (err, response, body) => {\r\n \t\t\t...\r\n \t\t});\r\n \t}\r\n\r\n }\r\n \r\n复制代码WXDecryptContact.js消息加密解密文档const crypto = require('crypto'); // 加密模块\r\n\r\nconst decodePKCS7 = function (buff) {\r\n    let pad = buff[buff.length - 1];\r\n    if (pad < 1 || pad > 32) {\r\n        pad = 0;\r\n    }\r\n    return buff.slice(0, buff.length - pad);\r\n};\r\n\r\n// 微信转发客服消息解密\r\nconst decryptContact = (key, iv, crypted) => {\r\n    const aesCipher = crypto.createDecipheriv('aes-256-cbc', key, iv);\r\n    aesCipher.setAutoPadding(false);\r\n    let decipheredBuff = Buffer.concat([aesCipher.update(crypted, 'base64'), aesCipher.final()]);\r\n    decipheredBuff = decodePKCS7(decipheredBuff);\r\n    const lenNetOrderCorpid = decipheredBuff.slice(16);\r\n    const msgLen = lenNetOrderCorpid.slice(0, 4).readUInt32BE(0);\r\n    const result = lenNetOrderCorpid.slice(4, msgLen + 4).toString();\r\n    return result;\r\n};\r\n\r\n// 解密微信返回给配置的消息服务器的信息\r\nconst decryptWXContact = (wechatData) => {\r\n    if(!wechatData){\r\n        wechatData = '';\r\n    }\r\n    //EncodingAESKey 为后台配置时随机生成的\r\n    const key = Buffer.from(EncodingAESKey + '=', 'base64');\r\n    const iv = key.slice(0, 16);\r\n    const result = decryptContact(key, iv, wechatData);\r\n    const decryptedResult = JSON.parse(result);\r\n    console.log(decryptedResult);\r\n    return decryptedResult;\r\n};\r\n\r\nmodule.exports = decryptWXContact;\r\n复制代码呼~ 代码终于码完，来看看效果:总结开发并不是一帆风顺的，也遇到了一些值得留意的坑，强调一下:后台配置URL地址一定外网可访问(可以通过内网穿透解决)文件上传接口 uploadTempMedia media 参数要用 FormData数据格式 (用node的 request 库很容易实现。 urllib 这个库有坑有坑 都是泪T_T)切记接收消息不论成功失败都要返回 success ，不然即使成功接收返回消息，日志没有报错的情况下，还是出现IOS提示该小程序提供的服务出现故障 请稍后再试。"}
{"title": "微信小程序胶囊按钮返回|首页自定义导航栏详解 ", "author": "2019-6-14 00:43", "pub_time": "2019-6-14 00:43", "content": "项目代码：https://github.com/Shay0921/header-navbar.git在小程序中，从转发出来的小程序消息卡片进入，因为页面栈中只有一个，所以不会出现返回按钮，对于一些电商平台来说，当商品被转发后会很影响客户查看其它产品和首页，这时候就需要使用自定义导航栏自己写一个“胶囊按钮”。如下图所示：从别的页面点到商品页时会有返回和首页按钮；当从分享页进入到商品页时，因为页面栈只有一个，所以只有首页按钮；首先我们需要如何开启自定义导航栏，查看手册后会发现一个页面配置项：navigationStyle之前的版本此配置项只能在app.js中配置，是全局的属性，而现在可以在单独的页面json中配置，实现单独页面自定义导航栏。整体思路当使用了navigationStyle:custom后，之前的顶部标题栏会被删除，右侧的胶囊按钮则会固定在右上角。然后在当前页面添加了三个view(状态栏、标题栏、主体内容)，可以看出三块的布局，我直接写死的高度：状态栏20px，标题栏44px。这个是自定义导航栏的关键，需要去计算这两块的高度，还有返回|首页胶囊按钮的位置。基础库 2.1.0开始可以使用wx.getMenuButtonBoundingClientRect()来获得右侧胶囊按钮的位置信息，而有了这个信息，就能相对的算出我们想要在左侧添加的胶囊按钮的位置。通过wx.getSystemInfoSync()中的statusBarHeight找到状态栏的高度。目录结构├── components                  组件\r\n│  ├── headerNavbar             顶部自定义导航栏\r\n│  │  └── headerNavbar.js\r\n│  │  └── headerNavbar.json\r\n│  │  └── headerNavbar.wxml\r\n│  │  └── headerNavbar.wxss\r\n├── pages                       页面\r\n│  ├── index                    首页\r\n│  │  └── index.js\r\n│  │  └── index.json\r\n│  │  └── index.wxml\r\n│  │  └── index.wxss\r\n│  ├── navigationStyle          引入自定义导航栏的页面(单独配置了navigationStyle)\r\n│  │  └── navigationStyle.js\r\n│  │  └── navigationStyle.json\r\n│  │  └── navigationStyle.wxml\r\n│  │  └── navigationStyle.wxss\r\n│  │  └── testPage.js           路由测试页面(后面用来测试跳转显示不同胶囊按钮)\r\n│  │  └── testPage.json\r\n│  │  └── testPage.wxml\r\n│  │  └── testPage.wxss复制代码全局变量app.js在app.js中要先获得状态栏高度和右侧胶囊位置信息App({\r\n    onLaunch: function (options) {\r\n      // 这里省略掉了登录和获取用户信息等函数\r\n      // 因为我在别的页面也需要使用此信息，所以没有单独获得 statusBarHeight\r\n      wx.getSystemInfo({ // 获取设备信息\r\n        success: (res) => {\r\n          this.globalData.systeminfo = res\r\n        },\r\n      })\r\n      // 获得胶囊按钮位置信息\r\n      this.globalData.headerBtnPosi = wx.getMenuButtonBoundingClientRect()\r\n    },\r\n    globalData: {\r\n        systeminfo: {}, // 系统信息\r\n        headerBtnPosi: {} // 胶囊按钮位置信息\r\n    }\r\n})\r\n复制代码这里需要注意wx.getMenuButtonBoundingClientRect()，并不是像wx.getSystmInfo一样有success回调函数，而是像对象一样wx.getMenuButtonBoundingClientRect().height来使用。组件代码headerNavbar.wxml<!-- 自定义导航栏 -->\r\n<view class='navbar-wrap' \r\n  style='height:{{navbarHeight}}px;padding-top:{{statusBarHeight}}px;'>  \r\n  <view class=\"navbar-text\"\r\n    style='line-height:{{navbarBtn.height + navbarBtn.top}}px;'>\r\n    {{navbarData.title ? navbarData.title : \"默认标题\"}}{{navbarHeight}}\r\n  </view>\r\n  <view class=\"navbar-icon\"\r\n    wx:if='{{navbarData.showCapsule ? navbarData.showCapsule : true}}'\r\n    style=\"top:{{navbarBtn.top + statusBarHeight}}px;left:{{navbarBtn.right}}px;height:{{navbarBtn.height}}px;\"> \r\n      <image wx:if='{{haveBack}}' bindtap=\"_goBack\" class=\"floatL\" src=\"/img/navbar_back_white.png\"></image>      \r\n      <view wx:if='{{haveBack}}' class=\"floatL\"></view>\r\n      <image bindtap=\"_goHome\" src=\"/img/navbar_home_white.png\"></image>\r\n  </view>\r\n</view>\r\n<!-- 手写loading -->\r\n<view class=\"navbar-loading\" style='height:{{navbarHeight}}px;line-height:{{navbarHeight}}px;'>\r\n  <text>...</text>\r\n</view>复制代码为了适配不同手机屏幕，高度和胶囊按钮的位置都需要在html里面赋值，下面会详细的说明高度如何计算。在自定义导航栏组件中分为两部分，一个是顶部的导航栏另一个是自己写的loading。因为自定义导航栏是fixed到顶部的，为了保证不挡住下面的主体内容，我们需要在导航栏和主体内容之间添加一个跟导航栏相同的高度，class先叫做box。这样可以保证导航栏不挡着主体内容。但是会出现另一个问题，如果此页面支持下拉刷新，那么导航栏会把小程序原生的loading样式挡住，而在主体内容的前面会出现一个空白的box，虽说不影响使用，但是在用户看来会很奇怪，莫名其妙的多出来一块，box只有在loading结束后才会上去。所以在这里需要自己手写一个loading的动画效果放在组件的最底下，高度跟导航栏一样。可以看到下面的最终效果，蓝色导航条下面的三个点是小程序原生loading，再下面三个小点是自己写的loading。而我们想要的效果则是，当小程序原生的loading被当时，自己写的loading就可以替代原生的loadingheaderNavbar.js状态栏高度 = app.globalData.systeminfo.statusBarHeight需要注意胶囊位置信息的原点是在页面的左上角，所以需要转换一下，把原胶囊位置信息起名为胶囊，转换后的叫做现胶囊。/*** iphone6 的胶囊位置信息\r\n* wx.getMenuButtonBoundingClientRect() 坐标信息以屏幕左上角为原点\r\n* 胶囊宽度： 87\r\n* 胶囊高度： 32\r\n* 胶囊左边界坐标： 278\r\n* 胶囊上边界坐标： 26\r\n* 胶囊右边界坐标： 365\r\n* 胶囊下边界坐标： 58\r\n* 状态栏高度：20*/复制代码现胶囊上边距 = 胶囊上边界坐标 - 状态栏高度现胶囊右边距 = 屏幕宽度 - 胶囊右边界坐标现胶囊下边距 = 胶囊下边界坐标 - 胶囊高度 - 状态栏高度导航栏高度 = 胶囊下边界坐标 + 现胶囊下边距注意：胶囊下边界坐标包含了状态栏、胶囊高度和状态栏和胶囊高度之间的距离，因为胶囊是居中在导航栏里的，所以上边距与下边距应该一致，所以是\r\n胶囊下边界坐标 - 胶囊高度 - 状态栏高度。const app = getApp();\r\nComponent({\r\n  properties: {\r\n    navbarData: { // 由父页面传递的数据\r\n      type: Object,\r\n      value: {},\r\n      observer: function (newVal, oldVal) { }\r\n    }\r\n  },\r\n  data: {\r\n    haveBack: true, // 是否有返回按钮，true 有 false 没有 若从分享页进入则为 false\r\n    statusBarHeight: 0, // 状态栏高度\r\n    navbarHeight: 0, // 顶部导航栏高度\r\n    navbarBtn: { // 胶囊位置信息\r\n      height: 0,\r\n      width: 0,\r\n      top: 0,\r\n      bottom: 0,\r\n      right: 0\r\n    }\r\n  },\r\n  // 微信7.0.0支持wx.getMenuButtonBoundingClientRect()获得胶囊按钮高度\r\n  attached: function () {\r\n    let statusBarHeight = app.globalData.systeminfo.statusBarHeight // 状态栏高度\r\n    let headerPosi = app.globalData.headerBtnPosi // 胶囊位置信息\r\n    /**\r\n     * wx.getMenuButtonBoundingClientRect() 坐标信息以屏幕左上角为原点\r\n     * 菜单按键宽度： 87\r\n     * 菜单按键高度： 32\r\n     * 菜单按键左边界坐标： 278\r\n     * 菜单按键上边界坐标： 26\r\n     * 菜单按键右边界坐标： 365\r\n     * 菜单按键下边界坐标： 58\r\n     */\r\n    let btnPosi = { // 胶囊实际位置，坐标信息不是左上角原点\r\n      height: headerPosi.height,\r\n      width: headerPosi.width,\r\n      // 胶囊top - 状态栏高度\r\n      top: headerPosi.top - statusBarHeight,\r\n      // 胶囊bottom - 胶囊height - 状态栏height （现胶囊bottom 为距离导航栏底部的长度）\r\n      bottom: headerPosi.bottom - headerPosi.height - statusBarHeight,\r\n      // 屏幕宽度 - 胶囊right\r\n      right: app.globalData.systeminfo.screenWidth - headerPosi.right\r\n    }\r\n    let haveBack;\r\n    if (getCurrentPages().length === 1) { // 当只有一个页面时\r\n      haveBack = false;\r\n    } else {\r\n      haveBack = true;\r\n    }\r\n    this.setData({\r\n      haveBack: haveBack, // 获取是否是通过分享进入的小程序\r\n      statusBarHeight: statusBarHeight,\r\n      navbarHeight: headerPosi.bottom + btnPosi.bottom, // 原胶囊bottom + 现胶囊bottom\r\n      navbarBtn: btnPosi\r\n    })\r\n  },\r\n  methods: {\r\n    _goBack: function () {\r\n      wx.navigateBack({\r\n        delta: 1\r\n      });\r\n    },\r\n    _goHome: function () {\r\n      wx.switchTab({\r\n        url: '/pages/index/index',\r\n      });\r\n    }\r\n  }\r\n})\r\n复制代码通过 getCurrentPages() 来判断当前页面是否从分享页进入，因为如果从分享页进入页面栈中应该只有一条数据，在跳转到其他页面时页面栈的length则会增加，在其他页面就会显示出返回和首页按钮。 注意：微信7.0.0支持wx.getMenuButtonBoundingClientRect()，如果想兼容低版本的微信，只能把导航栏的高度写死，通过一些大佬的计算得出的高度：'iPhone': 64,'iPhone X': 88,'android': 68具体查看：https://developers.weixin.qq.com/community/develop/doc/0006c012dc8028f04b070dd0551004如果你使用wx.getMenuButtonBoundingClientRect()得到信息有小数，如下所示{height:\r\n24, width: 65.25, top: -0.5, bottom: -0.5, right: 101.25}那么你可能是把开发工具中的视图缩放了，还原成100%就正常了。headerNavbar.wxss.navbar-wrap {\r\n\tposition: fixed;\r\n\twidth: 100%;\r\n\ttop: 0;\r\n\tz-index: 9999999;\r\n\tbackground-color: #3281FF;\r\n\tbox-sizing: border-box;\r\n}\r\n\r\n.navbar-text {\r\n\ttext-align: center;\r\n\tfont-size: 36rpx;\r\n\tcolor: #fff;\r\n\tfont-weight: 600;\r\n}\r\n\r\n.navbar-icon {\r\n\tposition: fixed;\r\n\tdisplay: flex;\r\n\tborder-radius: 64rpx;\r\n\tborder: 0.5px solid rgba(255,255,255, 0.3);\r\n\tbox-sizing: border-box;\r\n}\r\n\r\n.navbar-icon image {\r\n\theight: 20px;\r\n\twidth: 20px;\r\n\tpadding: 5px 10px 10px;\r\n\tdisplay: inline-block;\r\n\toverflow: hidden;\r\n}\r\n\r\n.navbar-icon view {\r\n\theight: 18px;\r\n\tborder-left: 0.5px solid rgba(255,255,255, 0.3);\r\n\tmargin-top: 6px;\r\n}\r\n\r\n.navbar-loading {\r\n\tbackground: #fff;\r\n\ttext-align: center;\r\n}\r\n复制代码引用组件页面代码navigationStyle.json{\r\n    \"navigationStyle\": \"custom\", \r\n    \"enablePullDownRefresh\": true, \r\n    \"backgroundTextStyle\": \"light\", \r\n    \"usingComponents\": {\r\n        \"headerNavbar\": \"/components/headerNavbar/headerNavbar\"\r\n    }\r\n}\r\n复制代码先在需要使用自定义导航栏的页面json中添加navigationStyle:customenablePullDownRefresh:\r\ntrue         开启下拉刷新backgroundTextStyle: light是把loading的样式改成白色，这样就不会显示出来loading的三个点navigationStyle.wxml<headernavbar navbar-data=\"{{nvabarData}}\"></headernavbar> \r\n<view class=\"home-page\"> \r\n   <text>\r\n    上面是自定义导航栏↑↑↑\r\n   </text> \r\n   <text>\r\n    下面是主体内容↓↓↓\r\n   </text> \r\n   <navigator url=\"./testPage\">\r\n    跳转到测试页\r\n   </navigator> \r\n</view>\r\n复制代码navigationStyle.jsPage({\r\n    data: {\r\n        // 组件所需的参数\r\n        nvabarData: {\r\n            showCapsule: 1,\r\n            // 是否显示左上角胶囊按钮 1 显示 0 不显示\r\n            title: '组件列表' // 导航栏 中间的标题\r\n        }\r\n    },\r\n\r\n    onPullDownRefresh() {\r\n        setTimeout(() = >{\r\n            wx.stopPullDownRefresh(); // 停止下拉\r\n        },\r\n        2000);\r\n    },\r\n\r\n})\r\n复制代码注意：虽说这么做在小程序开发工具中看起来都是对的，得到的导航栏高度也是64px但是在真机上测试后，还是有偏差，在iphone8 plus上高度是60px。可以通过这张图明显看到差了几px，如果你是单独几个页面使用自定义导航，细心的用户可能会发现，但是基本不影响。如果是全局使用自定义导航，那就不存在这个问题了。项目代码：https://github.com/Shay0921/header-navbar.git"}
{"title": "微信小程序开发系列教程第七章：编辑名片页面开发 ", "author": "2016-10-12 22:14", "pub_time": "2016-10-12 22:14", "content": "编辑名片有两条路径，分为新增名片流程与修改名片流程。用户手填新增名片流程：首先跳转到我们的新增名片页面 1 需要传递用户的当前 userId，wx.navigateTo 带值跳转。Manual 为 true 设置用户走的是新增路线。新增名片页面 1 基本布局如下：取到 userId。使用微信自带的 input 组件验证也非常好用，如 maxLength 属性，可以限制用户输入长度，如我这的姓名长度是最大 5 位，直接数字 5 即可。也可以自定义一些验证效果，具体可以根据需求进行一些验证配置，取到用户输入的值，进行操作。这里绑定了自带的模态框提示组件。其中 modalHidden2 是模态框开关。另外 proptText 是需要提示的内容。即使很多输入框也支持数据动态改变，非常方便。实际效果，非常快捷，比以前省去很多事情，编写小程序，发现最大的好处可能就是我们不必去考虑一系列兼容性问题。最后还有个头像上传图片，测试了下目前上传到后台服务器还有点问题，应该是内测版本不太完善导致吧。设置的直接是背景图片。提交表单与跳转。提交表单使用的是自带的 bindsubmit 事件组件，在 button 组件上添加 formType=”submit” 即可，还有点需注意的是使用表单提交功能时 input 需加上 name 属性，这个传递方式是以键值对的形式传递的。这时候跳转到编辑页 2 页面，这个页面是根据用户填写的手机号码识别到匹配的公司，页面非常简单，一个数据循环而已，单选框日后可能还需要美化一下。同样也是一些数据绑定以及验证效果。实际渲染效果可以看到。这个和第一个编辑页面逻辑基本不相上下，一些基本验证与提交，这里就讲到前面两步骤即可，编辑页面3也是同理，这里不再过多啰嗦。修改名片流程效果图与需求，修改名片是一次性把以前填写的个人信息全部渲染出来，供用户来改动：名片图片模块，上传图片暂时还有点问题，这里就是模仿了个跳转组件，比较建议需要跳转的页面还是使用 wx.navigateTo 控制好一点，wx.navigateTo 提供了给我们不同的 3 个跳转路由，封装的都很好，而且跳转页面很多牵连到传值之类的，可以达到统一管理也可以避免一些看不到的 bug 吧，总之还是根据业务需求来定：姓名手机必填模块：个人信息模块，直接循环（block）出来：Onload 时我们请求必填与选填数据：* requiredGroup 必填中文信息* notRequiredGroup 选题中文信息* requiredGroupEn 必填英文信息* notRequiredGroupEn 选题英文信息```//请求名片对应的公司的中文信息的属性组数据，分为必填和选填//选题项变量以 no 开头requester.getOfflineCardInfoGroupFields(userId, cardId,function (res) {//debuggervar userName = res.card.userName;var mobile = res.card.mobile;var requiredGroup = res.requiredGroupCh;var notRequiredGroup = res.notRequiredGroupCh;var requiredGroupEn = res.requiredGroupEn;var notRequiredGroupEn = res.notRequiredGroupEn;var reqLen = requiredGroup.fields.length;var nreqLen = notRequiredGroup.fields.length;var reqLenEn = requiredGroupEn.fields.length;var nreqLenEn = notRequiredGroupEn.fields.length;self.setData({userName: userName,mobile: mobile,requireFields: requiredGroup.fields,notRequireFields: notRequiredGroup.fields,requireFieldsEn: requiredGroupEn.fields,notRequireFieldsEn: notRequiredGroupEn.fields,l1: reqLen,l2: nreqLen + reqLen,l3: reqLenEn + nreqLen + reqLen});self.forceUpdate();}, function (code, msg) {console.info(\"code=\" + code + \"&msg=\" + msg);});```中英文信息必填与选填渲染：这里表单提交数据转换有点复杂（大家根据业务需求来做，不必花时间研究这里的方法），获取的是数组，按照后台需要的数据格式进行转换传递过去。今天再回去理下首页 A、B、C 定点跳转功能实现方法。首先是右边小索引布局以及数据绑定，数据绑定和名片夹列表上的字母一样，该字母下面有名片则渲染出来，没有则不需要渲染，id同样是当前字母与右边显示的内容一样：数据 sort，和 group.name 数据一样：这里是因为 # 不支持设为 id（就是 id=”#”），故而进行了一个转化。点击事件：获取到当前 ID，以及绑定数据 toView 为当前 ID。首先名片列表，名片上的字母索引都在 scroll-view 里面，这个 scroll-view 必须设置好固定的高度，设置成 100% 与 100vh 是无效的，y 轴的滚动开关打开，scroll-into-view 需要跳转到它子元素的 id 上。可以看下：这个 group.name==sortmsg，等于就是 A==A,B==B 同理。在这里如顶部有些菜单栏的话，你就要注意好布局了，不然会出现向下偏移这个菜单栏的高度，其实你只要和字母索引同级下即可避免此问题（这里的顶部菜单以模板分离出去了，分离模板的时候需注意下，需要在这里绑定模板的一些数据会出现失效，具体没有继续深入研究下去）。跳转功能基本实现（ohter 就是 # 底部）。"}
{"title": "基于mpvue的小程序swiper类3d轮播 ", "author": "2019-3-21 00:43", "pub_time": "2019-3-21 00:43", "content": "前言功能：实现类3d轮播，切换效果为放大缩小 技术: 使用 mpvue框架，用小程序swiper组件以及小程序Animation动画对象项目地址： https://github.com/gzz0204/mpvue-swiper效果：演示效果图一、结构小程序swiper 改为mpvue的写法。设置previous-margin和next-margin来漏出两边的模块 设置circular使轮播无限循环绑定change事件，自定义handleChange方法获取当前swiper的index小程序swiper文档<template>  <div class=\"home_wrap\">    <swiper class=\"home_swiper\"      :previous-margin=\"previousMargin\"      :next-margin=\"nextMargin\"      :circular=\"circular\"      @change=\"handleChange($event)\">        <block v-for=\"(item, index) in datalist\" :key=\"index\">            <swiper-item>              <div :class=\"curIndex===index ? 'active_item' : 'item'\" :animation=\"index == curIndex ? animationData : animationData2\">                <!-- 卡片项，写在子组件中，详见下文的第四项 -->                <Card :data=\"item\" />              </div>            </swiper-item>        </block>    </swiper>    <!-- 指示点 -->    <div class=\"swiper_dot_wrap\">      <ul>        <li v-for=\"(item, index) in datalist\" :key=\"index\" :class=\"{'active':curIndex === index}\"></li>      </ul>    </div>  </div></template>二、js<script>import Card from '@/components/home_card'export default {  data () {    return {      curIndex: 0,      datalist: [{        coverImg: 'http://n.sinaimg.cn/sinacn20118/201/w1080h721/20190119/3311-hrvcwnk7953342.jpg',        title: '摩尔曼斯克',        desc: '摩尔曼斯克，北极圈内最大的城市，离芬兰也就半小时车程，整个城市才从极夜的天气中浮上来，太阳还未能升出地平线，城市只能靠云层的反射借光，一天只有几个小时的光亮，但红霞会持续一整天时间。'      }, {        coverImg: 'https://lh3.googleusercontent.com/IU9_NYevRO-fFjiH_hhjuxTOuDhG3cmMCWNOlnz2TBoG9jICiZevHGC0eJmvsrUwUAtbeFc=s128',        title: '安纳托利亚往事',        desc: '摩尔曼斯克2，北极圈内最大的城市，离芬兰也就半小时车程，整个城市才从极夜的天气中浮上来，太阳还未能升出地平线，城市只能靠云层的反射借光，一天只有几个小时的光亮，但红霞会持续一整天时间。'      }, {        coverImg: 'https://lh3.googleusercontent.com/xNHcyfvW2wbnSHzp9ldizNUoqhwpumx0j3QdnOlrOPH6gj4yWDif1mnaBtezpjMe9_AUKIc=s128',        title: '圣彼得堡是另一个阿姆斯特丹',        desc: '摩尔曼斯克3，北极圈内最大的城市，离芬兰也就半小时车程，整个城市才从极夜的天气中浮上来，太阳还未能升出地平线，城市只能靠云层的反射借光，一天只有几个小时的光亮，但红霞会持续一整天时间。'      }],      circular: true, // 设置衔接滑动      previousMargin: '63rpx',      nextMargin: '63rpx',      animationData: {}, // 卡片放大动画      animationData2: {} // 卡片缩小动画    }  },  components: {    Card  },  methods: {    handleChange (e) {      this.curIndex = e.mp.detail.current      this.changeActive()      this.changeNormal()    },    // 收缩    changeNormal () {      var animation2 = wx.createAnimation({        duration: 500,        timingFunction: 'ease'      })      this.animation2 = animation2      animation2.scale(0.9).opacity(0.3).step()      this.animationData2 = animation2.export()    },    // 展开    changeActive () {      var animation = wx.createAnimation({        duration: 500,        timingFunction: 'ease'      })      this.animation = animation      animation.scale(1).opacity(1).step()      this.animationData = animation.export()    }  }}</script>三、样式<style lang=\"less\" scoped>.home_swiper {  margin-top: 200rpx;  position: relative;  width: 100%;  height: 876rpx !important;  background: #303030;}.item{  transform: scale(0.9);  transform-origin: 50% 50% 0px;  opacity: 0.3;}.active_item{  transform: scale(1);  opacity: 1;}// 指示点.swiper_dot_wrap{  position: absolute;  top: 106rpx;  right: 65rpx;  width: 200rpx;  height: 15rpx;  ul{    float: right;    overflow: hidden;    li{      float: left;      width: 15rpx;      height: 15rpx;      box-sizing: border-box;      border-radius: 50%;      border: 2rpx solid #b99c6d;      margin-right: 15rpx;      &:last-child{        margin-right: 0rpx;      }      &.active{        background: #b99c6d;      }    }  }}</style>子组件card每张卡片单独拆分成了一个组件，方便修改。<template>  <div class=\"item\">    <div class=\"card\">      <!-- banner图片 -->      <div class=\"img_wrap\">        <image class=\"item_image\" :src=\"data.coverImg\"/>      </div>      <!-- 内容区域 -->      <div class=\"cont_wrap\">        <!-- 标题 -->        <div class=\"title_wrap\">          <div class=\"title\">            {{data.title}}          </div>        </div>        <!-- 描述 -->        <div class=\"desc\">{{data.desc}}</div>      </div>    </div>  </div></template><script>export default {  props: {    data: {      type: Object    }  }}</script><style lang=\"less\" scoped>.item{  height: 890rpx;  position: relative;  .card{    position: absolute;    width: 625rpx;    height: 811rpx;    background: #fff;    border-radius: 7rpx;  }}/* 当前 swiper-item*/.active_item .card{  opacity: 1;}/* banner */.img_wrap{  position: relative;  background: #303030;  /* 图片 */  .item_image{    display: block;    width: 100%;    height: 399rpx;    border-radius: 7rpx 7rpx 0 0;    z-index: 5;    opacity: 0.7;  }}/* 标题出处 */.title_wrap{  width: 560rpx;  height: 100rpx;  margin: 0 auto;  // padding-left: 130rpx;  box-sizing: border-box;  color: #b99c6d;  border-bottom: 2rpx dotted #e4dcce;  .title{    position: relative;    font-size: 30rpx;    line-height: 35rpx;    height: 70rpx;    padding-top: 30rpx;    overflow: hidden;  }}// 描述.desc{  width: 554rpx;  height: 140rpx;  margin: 0 auto;  color:#666666;  font-size: 24rpx;  line-height: 28rpx;  overflow: hidden;  margin-top: 21rpx;  text-align: justify;}</style>"}
{"title": "我们用5分钟写了一个跨多端项目 ", "author": "2019-4-3 00:13", "pub_time": "2019-4-3 00:13", "content": "cml 作为真正让一套代码运行多端的框架，提供标准的MVVM模式，统一开发各类终端。同时，拥有各端独立的 运行时框架(runtime) 、 数据管理(store) 、 组件库(ui) 、 接口(api)。此外， cml 在跨端 能力加强 、 能力统一 、 表现一致 等方面做了许多工作。今天，为了让大家的项目优雅升级，快速接入，给你带来一份丰盛的 cml迁移指南 ~源码地址： github.com/jalonjs/cml…目录结构和微信小程序一样， cml 包含一个描述整体程序的 app 和多个描述各自页面的 page 。小程序目录结构.\r\n├── components // 包含各个组件\r\n├── pages // 包含各个页面\r\n├── app.js // 包含各个组件\r\n├── app.js  // 应用启动入口\r\n├── app.json // 全局配置\r\n├── app.wxss // 全局样式\r\n└── project.config.json // 项目配置文件\r\n\r\n复制代码cml目录结构.\r\n├── dist // 各个端构建结果\r\n│   ├── alipay \r\n│   ├── baidu \r\n│   ├── wx \r\n│   ├── web  \r\n│   ├── weex \r\n│   └── config.json // 跨端配置map映射表\r\n├── node_modules // 第三方库\r\n├── mock // 模拟 接口数据 和 模板数据\r\n├── src  // 源代码开发目录\r\n│   ├── app // 应用启动入口\r\n│   ├── assets // 静态资源\r\n│   ├── components // 包含组件\r\n│   ├── pages  // 包含页面\r\n│   ├── store //数据管理\r\n│   └── router.config.json // 路由配置文件\r\n├── chameleon.config.js // 项目配置文件\r\n└── package.json // npm包配置文件\r\n\r\n复制代码如何修改配置在小程序项目里面，分为：可以在项目根目录使用 project.config.json 文件对项目进行配置。配置示例：{\r\n  \"miniprogramRoot\": \"./src\",\r\n  \"debugOptions\": {}\r\n}\r\n复制代码小程序根目录下的 app.json 文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等配置示例：{\r\n  \"pages\": [\"pages/index/index\", \"pages/logs/index\"],\r\n  \"window\": {\r\n    \"navigationBarTitleText\": \"Demo\"\r\n  },\r\n  \"networkTimeout\": {\r\n    \"request\": 10000,\r\n    \"downloadFile\": 10000\r\n  }\r\n}\r\n复制代码每一个小程序页面也可以使用 .json 文件来对本页面的窗口表现进行配置。页面的配置只能设置 app.json 中部分 window 配置项的内容，页面中配置项会覆盖 app.json的 window 中相同的配置项。配置示例：{\r\n  \"navigationBarBackgroundColor\": \"#ffffff\",\r\n  \"navigationBarTextStyle\": \"black\",\r\n  \"navigationBarTitleText\": \"微信接口功能演示\",\r\n  \"backgroundColor\": \"#eeeeee\",\r\n  \"backgroundTextStyle\": \"light\"\r\n}\r\n复制代码同样，在 cml 项目里面，分为：cml —— 项目配置chameleon.config.js 为项目的配置文件，你可以定制化构建，比如是否带hash，是否压缩等等。配置示例：// 设置静态资源的线上路径\r\nconst publicPath = '//www.static.chameleon.com/static';\r\n// 设置api请求前缀\r\nconst apiPrefix = 'https://api.chameleon.com';\r\n// 合并配置\r\ncml.config.merge({\r\n  wx: {\r\n    build: {apiPrefix}\r\n  },\r\n  alipay: {\r\n    build: {apiPrefix}\r\n  },\r\n  baidu: {\r\n    build: {apiPrefix}\r\n  },\r\n  web: {\r\n    dev: {\r\n      hot: true,\r\n      console: true\r\n    },\r\n    build: {\r\n      publicPath: `${publicPath}/web`,\r\n      apiPrefix\r\n    }\r\n  },\r\n  weex: {\r\n    build: {\r\n      publicPath: `${publicPath}/weex`,\r\n      apiPrefix\r\n    }\r\n  }\r\n})\r\n\r\n复制代码cml —— 全局配置cml 项目 app 目录下的 app.cml 文件的 <script cml-type=\"json\" /> 用来对 cml 应用 进行全局配置，具有 跨端配置 和 差异化 的能力配置示例：<script cml-type=\"json\">\r\n{\r\n  \"base\": {\r\n    \"window\": {\r\n      \"navigationBarTitleText\": \"各个端共同title\",\r\n    },\r\n    \"permission\": {\r\n      \"scope.userLocation\": {\r\n        \"desc\": \"你的位置信息将用于小程序位置接口的效果展示\"\r\n      }\r\n    }\r\n  },\r\n  \"wx\": {\r\n    \"window\": {\r\n      \"backgroundTextStyle\":\"light\",\r\n      \"navigationBarBackgroundColor\": \"#fff\",\r\n      \"navigationBarTitleText\": \"差异化 title\",\r\n      \"navigationBarTextStyle\":\"black\"\r\n    }\r\n  },\r\n  \"baidu\": {\r\n    \"window\": {\r\n      \"backgroundTextStyle\": \"light\"\r\n    }\r\n  },\r\n  \"alipay\": {\r\n      \"window\": {\r\n        \"defaultTitle\": \"Chameleon\"\r\n      }\r\n  }\r\n}\r\n</script>\r\n复制代码通过 usingComponents 配置 组件路径 注册引用的组件。配置示例：<script cml-type=\"json\">\r\n{\r\n  \"base\": {\r\n    \"usingComponents\": {\r\n      \"navi\": \"/components/navi/navi\",\r\n      \"navi-npm\": \"cml-test-ui/navi/navi\"\r\n    }\r\n  },\r\n  \"wx\": {\r\n  },\r\n  \"alipay\": {\r\n  },\r\n  \"baidu\": {\r\n  },\r\n  \"web\": {\r\n  },\r\n  \"weex\": {\r\n  }\r\n}\r\n</script>\r\n复制代码如何使用路由能力小程序配置路由app.json 配置项列表的 pages 字段用于指定小程序由哪些页面组成，每一项都对应一个页面的路径+文件名 信息。数组的第一项代表小程序的初始页面（首页）。新增/减少页面，需要对 pages 数组进行修改。如果项目有 pages/index/index.wxml 、 pages/logs/logs.wxml 两个页面，则需要在 app.json 中写{\r\n  \"pages\": [\"pages/index/index\", \"pages/logs/logs\"]\r\n}\r\n复制代码cml配置路由src/router.config.json 是路由的配置文件， cml 内置了一套各端统一的路由管理方式。相应有 cml 路由配置映射如下：{\r\n  \"mode\": \"history\",\r\n  \"domain\": \"https://www.chameleon.com\",\r\n  \"routes\":[\r\n    {\r\n      \"url\": \"/cml/h5/index\",\r\n      \"path\": \"/pages/index/index\",\r\n      \"mock\": \"index.php\"\r\n    },\r\n    {\r\n      \"url\": \"/cml/h5/logs\",\r\n      \"path\": \"pages/logs/logs\",\r\n      \"mock\": \"logs.php\"\r\n    }\r\n  ]\r\n}\r\n复制代码文件名不需要写文件后缀， cml 框架会自动去寻找对于位置的 .cml 文件进行处理。小程序使用路由打开新页面：调用 APIwx.navigateTo页面重定向：调用 APIwx.redirectTo页面返回：调用 APIwx.navigateBack打开另一个小程序：调用 API wx.navigateToMiniProgram返回到上一个小程序：调用 API wx.navigateBackMiniProgramcml使用路由依据统一资源索引URI，自适应打开不同环境同一路由PATH：打开新页面：调用 chameleon-apicml.navigateTo页面重定向：调用 chameleon-apicml.redirectTo页面返回：调用 chameleon-apicml.navigateBack打开另一个跨端应用：调用 chameleon-apicml.open返回到上一个跨端应用：调用 chameleon-apicml.close如何注册如何注册程序小程序注册程序在小程序项目里面， App() 函数用来注册一个小程序。接受一个 Object 参数，其指定小程序的生命周期回调等。示例代码App({\r\n  onLaunch(options) {\r\n    // Do something initial when launch.\r\n  },\r\n  globalData: 'I am global data'\r\n})\r\n复制代码cml注册程序示例代码<script>\r\nimport store from '../store/index.js'\r\nimport routerConfig from '../router.config.json';\r\n\r\nclass App {\r\n  data = {\r\n    store,\r\n    routerConfig\r\n  }\r\n  created(res) {\r\n  }\r\n}\r\n\r\nexport default new App();\r\n</script>\r\n复制代码细心的你会发现，小程序中 app.json app.js app.wxss 和 src/app/app.cml 的对应关系如下小程序 app.jscml项目 src/app/app.cmlapp.js<script></script>app.wxss<style></style>app.json<script cml-type=\"json\"></script>如何注册页面小程序注册页面在小程序项目里面， Page(Object) 函数用来注册一个页面。接受一个 Object 类型参数，其指定页面的初始数据、生命周期回调、事件处理函数等。示例代码：// index.js\r\nPage({\r\n  data: {\r\n    text: 'This is page data.'\r\n  },\r\n  changeText: function(e) {\r\n    // sent data change to view\r\n    this.setData({\r\n      text: 'CML'\r\n    })\r\n  }\r\n})\r\n复制代码cml注册页面示例代码<script>\r\nclass Index {\r\n  data = {\r\n    text: 'Chameleon'\r\n  }\r\n  methods = {\r\n    changeText: function(e) {\r\n      // sent data change to view\r\n      this.text = 'CML';\r\n    }\r\n  }\r\n  computed = {}\r\n  watch = {}\r\n};\r\nexport default new Index();\r\n</script>\r\n复制代码如何注册组件小程序注册组件在小程序项目里面， Component(Object) 构造器可用于定义组件，调用 Component 构造器时可以指定组件的属性、数据、方法等。示例代码Component({\r\n  properties: {\r\n    myProperty: { // 属性名\r\n      type: String, // 类型（必填）\r\n      value: '' // 属性初始值（可选）\r\n    },\r\n    myProperty2: String // 简化的定义方式\r\n  },\r\n  data: {\r\n    text: ''\r\n  }, // 私有数据，可用于模板渲染\r\n\r\n  // 生命周期函数，可以为函数，或一个在methods段中定义的方法名\r\n  attached() { }, \r\n  ready() { },\r\n  methods: {\r\n    onMyButtonTap() {\r\n      this.setData({\r\n        // 更新属性和数据的方法与更新页面数据的方法类似\r\n        text: 'wx'\r\n      })\r\n    }\r\n  }\r\n})\r\n复制代码cml注册组件示例代码<script>\r\nclass MyComponent {\r\n  props = {\r\n    myProperty: { // 属性名\r\n      type: String, // 类型（必填）\r\n      default: '' // 属性初始值（可选）\r\n    },\r\n    myProperty2: String // 简化的定义方式\r\n  }\r\n  data =  {\r\n    text: ''\r\n  } // 私有数据，可用于模板渲染\r\n\r\n  beforeMount() {}\r\n  mounted() {}\r\n  methods = {\r\n    onMyButtonTap() {\r\n      this.text = 'cml'\r\n    }\r\n  }\r\n  computed = {}\r\n  watch = {}\r\n};\r\nexport default new MyComponent();\r\n</script>\r\n复制代码如何声明生命周期统一各端应用生命周期的定义，是跨端框架的重要组成，也是迁移的必经之路。小程序声明生命周期可以在 App(Object) 、 Page(Object) 、 Component(Object) 传入 Object 参数，其指定小程序的生命周期回调等代码示例// index.js\r\nPage({\r\n  onLoad(options) {\r\n    // Do some initialize when page load.\r\n  },\r\n  onReady() {\r\n    // Do something when page ready.\r\n  },\r\n  onShow() {\r\n    // Do something when page show.\r\n  },\r\n  onHide() {\r\n    // Do something when page hide.\r\n  },\r\n  onUnload() {\r\n    // Do something when page close.\r\n  },\r\n  onShareAppMessage() {\r\n    // return custom share data when user share.\r\n  }\r\n})\r\n复制代码cml声明生命周期在 .cml 文件 <script /> 代码块返回的对象实例，其指定生命周期回调示例代码<script>\r\nclass Index {\r\n  beforeCreate(query) {\r\n    // data数据挂载到this根节点上之前，以及methods所有方法挂载到实例根节点之前\r\n    // 注意：只用页面的 beforeCreate钩子 会返回页面query\r\n    console.log('App beforeCreate: 打开当前页面路径中的参数是 ', query)\r\n  }\r\n  created() {\r\n    // data,methods里面的这些events挂载完成\r\n    console.log('App created')\r\n  }\r\n  beforeMount() {\r\n    // 开始挂载已经编译完成的cml到对应的节点时\r\n    console.log('App beforeMount')\r\n  }\r\n  mounted() {\r\n    // cml模板编译完成,且渲染到dom中完成,在整个生命周期中只执行一次\r\n    console.log('App mounted')\r\n  }\r\n  beforeDestroy() {\r\n    // 实例销毁前\r\n    console.log('App beforeDestroy')\r\n  }\r\n  destroyed() {\r\n    // 实例销毁后\r\n    console.log('App destroyed')\r\n  }\r\n};\r\nexport default new Index();\r\n</script>\r\n复制代码App 生命周期 映射小程序 app.js 中的生命周期 -> cml src/app/app.cml小程序chameleononLaunchbeforeCreateonShowmountedonHidedestroyedPage 生命周期 映射小程序 Page() 中的生命周期 -> cml src/pages/mypage/mypage.cml小程序chameleononLoadbeforeCreateonShowmountedonUnloaddestroyedonReady生命周期多态onHide生命周期多态onShareAppMessage生命周期多态Component 生命周期 映射小程序 Component() 中的生命周期 -> cml src/components/mycomponent/mycomponent.cml小程序chameleoncreatedcreatedattachedbeforeMountreadymounteddetacheddestroyed生命周期总结每个 cml 实例( App 、 Page 、 Component )在被创建时都要经过一系列的初始化过程 ————例如，需要设置数据监听、编译模板、将实例挂载到 CML节点 并在数据变化时更新 CML节点等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给开发者在不同阶段添加自己的代码的机会。cml 为 App 、 页面Page 、 组件Component 提供了一系列生命周期事件，保障应用有序执行。另外，如果你想使用某个端特定的生命周期，你可以从业务出发使用生命周期多态。数据如何响应到视图如今，双向数据绑定&单向数据流 已深入开发者日常，MVMM开发模式算是框架标配。数据绑定 、 条件渲染 、列表渲染 是如何书写的呢？示例代码小程序使用数据响应<!--wxml-->\r\n<view class=\"scroller-wrap\">\r\n    <!--数据绑定-->\r\n  <view>{{message}}</view>\r\n  <!--条件渲染-->\r\n  <view wx:if=\"{{view == 'WEBVIEW'}}\">WEBVIEW</view>\r\n  <view wx:elif=\"{{view == 'APP'}}\">APP</view>\r\n  <view wx:else=\"{{view == 'MINA'}}\">MINA</view>\r\n    <!--列表渲染-->\r\n  <view wx:for=\"{{array}}\" wx:for-index=\"index\" wx:for-item=\"item\">{{item}}</view>\r\n</view>\r\n复制代码// page.js\r\nPage({\r\n  data: {\r\n    message: 'Hello MINA!',\r\n    view: 'MINA',\r\n    array: [1, 2, 3, 4, 5]\r\n  },\r\n  onLoad() {\r\n    this.setData({\r\n      message: 'wx'\r\n    })\r\n  }\r\n})\r\n复制代码cml使用数据响应<template>\r\n<!--index.cml-->\r\n<view class=\"scroller-wrap\">\r\n    <!--数据绑定-->\r\n  <view>{{message}}</view>\r\n  <!--条件渲染-->\r\n  <view c-if=\"{{view == 'WEBVIEW'}}\">WEBVIEW</view>\r\n  <view c-else-if=\"{{view == 'APP'}}\">APP</view>\r\n  <view c-else=\"{{view == 'MINA'}}\">MINA</view>\r\n    <!--列表渲染-->\r\n  <view c-for=\"{{array}}\" c-for-index=\"index\" c-for-item=\"item\">{{item}}</view>\r\n</view>\r\n</template>\r\n<script>\r\nclass Index {\r\n  data =  {\r\n    message: 'Hello MINA!',\r\n    view: 'MINA',\r\n    array: [1, 2, 3, 4, 5]\r\n  }\r\n\r\n  beforeCreate () {\r\n    this.message = 'cml'\r\n  }\r\n};\r\nexport default new Index();\r\n</script>\r\n复制代码数据响应总结cml 运行时框架 提供了跨端响应式数据绑定系统(Data binding)，当做数据修改的时候，只需要在逻辑层修改数据，视图层就会做相应的更新。只需要将 view<-->model 交互部分逻辑，作简单迁移，便可使它成为跨多端的数据响应系统。事件交互cml 支持一些基础的事件，保障各端效果( 类型 、 绑定 、 事件对象 )一致运行。示例代码小程序使用事件<!--wxml-->\r\n<view id=\"tapTest\" data-hi=\"WeChat\" bindtap=\"tapName\">Click me!</view>\r\n复制代码// page.js\r\nPage({\r\n  tapName(event) {\r\n    console.log(event)\r\n  }\r\n})\r\n复制代码cml使用事件<template>\r\n  <view id=\"tapTest\" data-hi=\"WeChat\" c-bind:tap=\"tapName\">\r\n    <text>Click me!</text>\r\n  </view>\r\n</template>\r\n<script>\r\nclass Index {\r\n  methods = {\r\n    tapName(e) {\r\n      // 打印事件对象\r\n      console.log('事件对象:', e);\r\n    }\r\n  }\r\n}\r\nexport default new Index();\r\n</script>\r\n复制代码事件使用总结同时，还支持，用于父子组件之间的通信。另外，如果你想要使用某个端特定的事件， cml 并不会限制你的自由发挥，你可以从业务出发使用组件多态 或者接口多态 差异化实现功能。布局和外观各端描述 布局和外观 的层叠样式表(CSS)实现存在差异，包括不限于 布局 、 盒模型 、 定位、 文本 。所以， cml 框架内置跨端一致性基础样式能力。并且，定义了用于描述页面的样式规范 CMSS(Chameleon Style Sheet) 。如何导入外部样式使用 @import 语句可以导入外联样式表， @import 后跟需要导入的外联样式表的相对路径，用 ; 表示语句结束。小程序导入外部样式示例代码：/** common.wxss **/\r\n.small-p {\r\n  padding:5px;\r\n}\r\n复制代码/** app.wxss **/\r\n@import \"common.wxss\";\r\n.middle-p {\r\n  padding:15px;\r\n}\r\n复制代码cml导入外部样式详细文档示例代码：/** common.css **/\r\n.small-p {\r\n  padding: 5px;\r\n}\r\n复制代码<!-- app.cml -->\r\n<style>\r\n  @import './common.css';\r\n  .middle-p {\r\n    padding:15 cpx;\r\n  }\r\n</style>\r\n复制代码样式使用总结同时，为了统一多端尺寸单位，呈现效果一致，同时页面响应式布局， cml 项目统一采用cpx 作为尺寸单位，规定以屏幕750px（占满屏幕）视觉稿作为标准。而且，各端样式表拥有的能力不尽相同，是项目迁移的主要阵地之一。另外，如果你想要使用某个端特定的样式能力， cml 并不会限制你的自由发挥，你可以从业务出发使用样式多态注意：由于chameleon应用是 跨多端 web native 小程序 框架，如果需要跨 native ，必须使用flexbox 进行样式布局！！！组件cml 项目一切皆组件。组件(Component)是视图的基本组成单元。框架为开发者提供了一系列基础组件，开发者可以通过组合这些基础组件进行快速开发。如：<template>\r\n  <view>\r\n    <view>view 基础组件</view>\r\n    <text>text 基础组件</text>\r\n  </view>\r\n</template>\r\n复制代码同时， cml 支持简洁的组件化编程。自定义组件开发者可以将页面内的功能模块抽象成自定义组件，以便在不同的页面中重复使用。自定义组件在使用时与基础组件非常相似。如何创建自定义组件小程序创建自定义组件代码示例：Component({\r\n  properties: {\r\n    // 这里定义了innerText属性，属性值可以在组件使用时指定\r\n    innerText: {\r\n      type: String,\r\n      value: 'default value',\r\n    }\r\n  },\r\n  data: {\r\n    // 这里是一些组件内部数据\r\n    someData: {}\r\n  },\r\n  methods: {\r\n    // 这里是一个自定义方法\r\n    customMethod() {}\r\n  }\r\n})\r\n复制代码cml创建自定义组件示例代码<script>\r\nclass MyComponent {\r\n  props = {\r\n    // 这里定义了innerText属性，属性值可以在组件使用时指定\r\n    innerText: {\r\n      type: String,\r\n      value: 'default value',\r\n    }\r\n  }\r\n  data = {\r\n    // 这里是一些组件内部数据\r\n    someData: {}\r\n  }\r\n  methods = {\r\n    // 这里是一个自定义方法\r\n    customMethod() {}\r\n  }\r\n  computed = {}\r\n  watch = {}\r\n};\r\nexport default new MyComponent();\r\n</script>\r\n复制代码如何使用自定义组件使用已注册的自定义组件前，首先要进行引用声明。此时需要提供每个自定义组件的标签名和对应的自定义组件文件路径。小程序使用自定义组件代码示例：在 page.json 中进行引用声明{\r\n  \"usingComponents\": {\r\n    \"component-tag-name\": \"path/to/the/custom/component\"\r\n  }\r\n}\r\n复制代码在 page.wxml 中使用<view>\r\n  <!-- 以下是对一个自定义组件的引用 -->\r\n  <component-tag-name inner-text=\"Some text\"></component-tag-name>\r\n</view>\r\n复制代码cml使用自定义组件代码示例：在 page.cml 中 <script cml-type='json' /> 进行引用声明<script cml-type=\"json\">\r\n{\r\n  \"base\": {\r\n      \"usingComponents\": {\r\n        \"component-tag-name\": \"path/to/the/custom/component\"\r\n      }\r\n  }\r\n}\r\n</script>\r\n复制代码在 page.cml 中 <template /> 使用<template>\r\n<view>\r\n  <!-- 以下是对一个自定义组件的引用 -->\r\n  <component-tag-name inner-text=\"Some text\"></component-tag-name>\r\n</view>\r\n</template>\r\n复制代码如何实现父子组件事件通信事件系统是组件间通信的主要方式之一。自定义组件可以触发任意的事件，引用组件的页面可以监听这些事件。小程序组件通信代码示例：<!-- 页面 page.wxml -->\r\n<view>\r\n  <my-component bindcustomevent=\"onMyEvent\"></my-component>\r\n</view>\r\n复制代码// 页面 page.js\r\nPage({\r\n  methods: {\r\n    onMyEvent(e) {\r\n      console.log(e.detail) // 自定义组件触发事件时提供的detail对象\r\n    }\r\n  }\r\n})\r\n复制代码<!-- 组件 my-component.wxml -->\r\n<view>\r\n  <button bindtap=\"onTap\">点击这个按钮将触发“myevent”事件</button>\r\n</view>\r\n复制代码// 组件 my-component.js\r\nComponent({\r\n  methods: {\r\n    onTap() {\r\n      this.triggerEvent('customevent', {}) // 触发 自定义组件事件\r\n    }\r\n  }\r\n})\r\n复制代码cml组件通信代码示例：<!-- 页面 page.cml -->\r\n<template>\r\n  <view>\r\n    <my-component c-bind:customevent=\"onMyEvent\"></my-component>\r\n  </view>\r\n</template>\r\n<script>\r\nclass Index {\r\n  methods = {\r\n    // 这里是一个自定义方法\r\n    onMyEvent(e) {\r\n      console.log(e.detail) // 自定义组件触发事件时提供的detail对象\r\n    }\r\n  }\r\n};\r\nexport default new Index();\r\n</script>\r\n<script cml-type=\"json\">\r\n{\r\n  \"base\": {\r\n      \"usingComponents\": {\r\n        \"my-component\": \"path/to/the/custom/component\"\r\n      }\r\n  }\r\n}\r\n</script>\r\n复制代码<!-- 页面 path/to/the/custom/component.cml -->\r\n<template>\r\n  <view>\r\n    <button c-bind:tap=\"onTap\">点击这个按钮将触发“myevent”事件</button>\r\n  </view>\r\n</template>\r\n<script>\r\nclass MyComponent {\r\n  methods = {\r\n    // 这里是一个自定义方法\r\n    onTap() {\r\n      this.$cmlEmit('customevent', {}) // 触发 自定义组件事件\r\n    }\r\n  }\r\n};\r\nexport default new MyComponent();\r\n</script>\r\n<script cml-type=\"json\">\r\n{}\r\n</script>\r\n复制代码组件使用总结和小程序一样， cml框架 提供了大量内置组件和扩展组件，抹平多端差异，便于开发者通过组合这些组件，创建出强大的应用程序。扩展组件需要额外引入。如：<script cml-type=\"json\">\r\n{\r\n  \"base\": {\r\n      \"usingComponents\": {\r\n        \"c-dialog\": \"cml-ui/components/c-dialog/c-dialog\"\r\n      }\r\n  }\r\n}\r\n</script>\r\n复制代码在执行 cml build 构建打包时， cml 框架 会按需打包引用的内置组件和扩展组件，为代码瘦身。内置组件 和扩展组件 都是支持跨多端的，对于一些没有提供的某个端的组件，可以通过组件多态来实现。如果希望使用小程序端的原生组件，那么可以在原生标签前加上 origin-* ， cml 框架会渲染原生组件参考注意： origin-* 只能在灰度区文件中使用！！如在 map.wx.cml 文件中使用原生地图组件 <map/> ：<!-- map.wx.cml -->\r\n<template>\r\n  <origin-map\r\n    id=\"map\"\r\n    longitude=\"113.324520\"\r\n    latitude=\"23.099994\"\r\n    controls=\"{{controls}}\"\r\n    bindcontroltap=\"controltap\"\r\n    style=\"width: 100%; height: 300px;\"\r\n  ></origin-map>\r\n</template>\r\n复制代码如何调用平台接口能力在小程序里面，可以通过微信原生 API ，调起如获取用户信息，本地存储，支付功能等。示例代码try {\r\n  wx.setStorageSync('name', 'Hanks')\r\n} catch (e) {\r\n  console.error(e)\r\n}\r\n复制代码同样，在 cml 项目里面可以这样调用：示例代码import cml from 'chameleon-api'\r\ncml.setStorage('name', 'Hanks').then((res)=>{\r\n  console.log(res)\r\n},function(e){\r\n  console.error(e)\r\n})\r\n复制代码接口使用总结cml 框架提供了丰富的多态接口，可以调起各端提供的原生能力，如系统信息、元素节点信息、动画效果、本地存储、网络请求、地理位置等。请参考API 文档。chameleon-api 提供的接口都是支持跨多端的，对于一些没有提供的某个端的原生接口，可以通过接口多态来调用。"}
{"title": "微信小程序之自定义模态弹窗（带动画）实例 ", "author": "2019-4-11 00:48", "pub_time": "2019-4-11 00:48", "content": "1、基本需求。实现用户自定义弹框 带动画（动画可做参靠，个人要是觉得不好看可以自定义动画） 获取弹出框的内容，自定义事件获取 2、案例目录结构二、程序实现具体步骤1.弹框index.wxml代码<!--button--><view class=\"btn\" bindtap=\"powerDrawer\" data-statu=\"open\">来点我呀</view><!--mask--><view class=\"drawer_screen\" bindtap=\"powerDrawer\" data-statu=\"close\" wx:if=\"{{showModalStatus}}\"></view><!--content--><!--使用animation属性指定需要执行的动画--><view animation=\"{{animationData}}\" class=\"drawer_box\" wx:if=\"{{showModalStatus}}\">  <!--drawer content-->  <view class=\"drawer_title\">弹窗标题</view>  <view class=\"drawer_content\">    <view class=\"top grid\">      <label class=\"title col-0\">标题</label>      <input class=\"input_base input_h30 col-1\" name=\"rName\" value=\"可自行定义内容\"></input>    </view>    <view class=\"top grid\">      <label class=\"title col-0\">标题</label>      <input class=\"input_base input_h30 col-1\" name=\"mobile\" value=\"110\"></input>    </view>    <view class=\"top grid\">      <label class=\"title col-0\">标题</label>      <input class=\"input_base input_h30 col-1\" name=\"phone\" value=\"拒绝伸手党\"></input>    </view>    <view class=\"top grid\">      <label class=\"title col-0\">标题</label>      <input class=\"input_base input_h30 col-1\" name=\"Email\" value=\"仅供学习使用\"></input>    </view>    <view class=\"top bottom grid\">      <label class=\"title col-0\">备注</label>      <input class=\"input_base input_h30 col-1\" name=\"bz\"></input>    </view>  </view>  <view class=\"btn_ok\" bindtap=\"powerDrawer\" data-statu=\"close\">确定</view></view>2.弹框index.wxss代码/*button*/.btn {  width: 80%;  padding: 20rpx 0;  border-radius: 10rpx;  text-align: center;  margin: 40rpx 10%;  background: #000;  color: #fff;}/*mask*/.drawer_screen {  width: 100%;  height: 100%;  position: fixed;  top: 0;  left: 0;  z-index: 1000;  background: #000;  opacity: 0.5;  overflow: hidden;}/*content*/.drawer_box {  width: 650rpx;  overflow: hidden;  position: fixed;  top: 50%;  left: 0;  z-index: 1001;  background: #FAFAFA;  margin: -150px 50rpx 0 50rpx;  border-radius: 3px;}.drawer_title{  padding:15px;  font: 20px \"microsoft yahei\";  text-align: center;}.drawer_content {  height: 210px;  overflow-y: scroll; /*超出父盒子高度可滚动*/}.btn_ok{  padding: 10px;  font: 20px \"microsoft yahei\";  text-align: center;  border-top: 1px solid #E8E8EA;  color: #3CC51F;}.top{    padding-top:8px;}.bottom {    padding-bottom:8px;}.title {    height: 30px;    line-height: 30px;    width: 160rpx;    text-align: center;    display: inline-block;    font: 300 28rpx/30px \"microsoft yahei\";}.input_base {    border: 2rpx solid #ccc;    padding-left: 10rpx;    margin-right: 50rpx;}.input_h30{    height: 30px;    line-height: 30px;}.input_h60{    height: 60px;}.input_view{    font: 12px \"microsoft yahei\";    background: #fff;    color:#000;    line-height: 30px;}input {    font: 12px \"microsoft yahei\";    background: #fff;    color:#000 ;}radio{    margin-right: 20px;}.grid { display: -webkit-box; display: box; }.col-0 {-webkit-box-flex:0;box-flex:0;}.col-1 {-webkit-box-flex:1;box-flex:1;}.fl { float: left;}.fr { float: right;}3.弹框index.js逻辑代码 a.动画部分的功能实现util: function(currentStatu){    /* 动画部分 */    // 第1步：创建动画实例    var animation = wx.createAnimation({      duration: 200,  //动画时长      timingFunction: \"linear\", //线性      delay: 0  //0则不延迟    });    // 第2步：这个动画实例赋给当前的动画实例    this.animation = animation;    // 第3步：执行第一组动画    animation.opacity(0).rotateX(-100).step();    // 第4步：导出动画对象赋给数据对象储存    this.setData({      animationData: animation.export()    })    // 第5步：设置定时器到指定时候后，执行第二组动画    setTimeout(function () {      // 执行第二组动画      animation.opacity(1).rotateX(0).step();      // 给数据对象储存的第一组动画，更替为执行完第二组动画的动画对象      this.setData({        animationData: animation      })      //关闭      if (currentStatu == \"close\") {        this.setData(          {            showModalStatus: false          }        );      }    }.bind(this), 200)    // 显示    if (currentStatu == \"open\") {      this.setData(        {          showModalStatus: true        }      );    }  }三、案例运行效果图"}
{"title": "小程序canvas动画解决方案，绘制一个塔罗牌动画 ", "author": "2019-4-17 00:41", "pub_time": "2019-4-17 00:41", "content": "目前还有个问题：android上面无卡顿，但是ios直接把微信卡掉！wxml<canvas style='width:{{windowWidth}}px;height:{{height}}px;  position: fixed;' canvas-id=\"secondCanvas0\"></canvas><canvas style='width:{{windowWidth}}px;height:{{height}}px;  position: fixed;' canvas-id=\"secondCanvas1\"></canvas><view class='receivenow_view'>  <view class=\"receivenow_button_view\" bindtap='{{!start_state?\"shuffle_func\":\"card_selection_func\"}}' style='margin-top:{{height+10}}px' animation=\"{{animation3}}\">    <text>{{!start_state?\"开始洗牌\":\"开始选牌\"}}</text>  </view></view>wxss.receivenow_view {  display: flex;  flex-direction: column;  justify-content: center;  align-items: center;  padding-bottom: 80rpx;}.receivenow_button_view {  font-size: 30rpx;  color: #fff;  padding: 35rpx 190rpx;  border-radius: 60rpx;  background: linear-gradient(to right, #ff5846, #ff067a);  line-height: normal;}jsconst animationFrame = require('../../utils/requestAnimationFrame.js')const ctx0 = wx.createCanvasContext('secondCanvas0')const ctx = wx.createCanvasContext('secondCanvas1')Page({  /**   *    */  data: {    //默认canvas高度    height: 375,    //默认canvas宽度    windowWidth: 375,    //背景资源    bg: \"\",    //卡片资源    card: \"\",    //是否开始洗牌    start_state: false,    //开场动画是否结束    kaichang: false,    // 是否开始选牌    card_selection: false,    //20张卡开场动画过后的所在位置x坐标    xarrs: [],    //20张卡开场动画过后的所在位置y坐标    yarrs: [],    //开场动画执行时间    start_time: 1500,    card_width: 46,    card_height: 76.3  },  onLoad: function(options) {    var that = this    //获取手机屏幕宽度    wx.getSystemInfo({      success(res) {        let windowWidth = res.windowWidth        let height = windowWidth        that.setData({          height: height,          windowWidth: windowWidth        })      }    })    // const ctx = wx.createCanvasContext('secondCanvas')    // ctx.clearRect(0, 0, that.data.windowWidth, that.data.height)    // ctx.draw()    this.init();  },  //初始化数据，获取绘图所需图片  init() {    var doAnimationFrame = animationFrame.doAnimationFrame    this.setData({      bg: \"/img/bg.jpg\",      card: \"/img/card.png\"    })    this.draw();  },  //开始画图      draw() {    var that = this    let width = that.data.windowWidth    let height = that.data.height    let nowtime = new Date().getTime()    let time = that.data.start_time    let card_width = that.data.card_width    let card_height = that.data.card_height    //用来存储所有卡片的x坐标和移动距离    let xarrs = []    //设置所有卡片的x坐标和移动距离    for (let i = 0; i < 20; i++) {      xarrs.push([width / 18, card_width * (i * 0.5)])    }    console.log(xarrs)    //用来存储所有卡片的y坐标和移动距离    let yarrs = [      [height / 2 - card_height / 2, 0]    ]    //画一个背景    ctx0.drawImage(that.data.bg, 0, 0, width, height);    ctx0.draw()    // animationFrame.doAnimationFrame,e为回调执行时间    var rander = function(e) {      e = e ? e : nowtime      ctx.clearRect(0, 0, width, height) //清空所有的内容      //绘制卡片        for (let i = 0; i < xarrs.length; i++) {        ctx.drawImage(that.data.card, xarrs[i][0], yarrs[0][0], card_width, card_height);        //从新设置卡片的x坐标和剩余移动距离        xarrs[i] = that.move_x_func(xarrs[i][0], xarrs[i][1], time)      }      // console.log(arrs[0])            ctx.draw()      //如果开始执行动画时间到最后一次的时间大于动画执行时间则停止动画      if (e - nowtime < time) {        var id = animationFrame.doAnimationFrame(rander);      } else {        //开场动画结束保存其位置        that.setData({          xarrs: xarrs,          yarrs: yarrs,          kaichang: true        })      }    }    rander()  },  //x坐标位置，以及移动距离(px),两秒移动s,16ms移动多少;time动画持续时间返回一个arr  move_x_func(position, s, time) {    // console.log(position)    //动画持续时长两秒    position = parseFloat(position.toFixed(2))    //16ms移动的距离    let time_distance = parseFloat((s * 16 / time).toFixed(2))    s = parseFloat(s.toFixed(2))    if (s === 0) {      return [position, s];    } else {      return [position + time_distance, s - time_distance]    }  },  //y坐标位置，以及移动距离  move_y_func(position, s) {  },  //洗牌开始  shuffle_func() {    let that = this    let width = that.data.windowWidth    let height = that.data.height    let nowtime = new Date().getTime()    let time = that.data.start_time    let card_width = that.data.card_width    let card_height = that.data.card_height    let xarrs = that.data.xarrs    let yarrs = that.data.yarrs    let time1 = 0    //如果还未开场，不进行洗牌    if (!that.data.kaichang | that.data.start_state) {      return false;    }    var animation3 = wx.createAnimation({      duration: 300,      timingFunction: 'ease',    })    animation3.scale3d(0.1, 0.1, 0.1).step().scale3d(1, 1, 1).step();    that.setData({      animation3: animation3,      //洗牌开始了，改变是否洗牌的状态      start_state: true    })    let x = that.rnd(1, height / 2)    let ys = []    let xs = []    let centers = []    for (let i = 0; i < xarrs.length; i++) {      ys.push(that.rnd(height / 10, height / 8))      // xs.push(that.rnd(width / 8, width / 4))      xs.push(width / 10)      centers.push([that.rnd(width / 4, width / 2), that.rnd(height / 4, height / 2)])    }    //用户点击洗牌，执行另一个动画    var rander = function(e) {      ctx.clearRect(0, 0, width, height) //清空所有的内容       //设置中心点      ctx.translate(width / 2, height / 2);      for (let i = 0; i < xarrs.length; i++) {        //设定每次旋转的度数        // ctx.save()        ctx.rotate(time1 * Math.PI / 540);        ctx.drawImage(that.data.card, xs[i], ys[i], card_width, card_height);        // ctx.restore()        }      ctx.draw()      time1++      if (!that.data.card_selection) {        var id = animationFrame.doAnimationFrame(rander);      }    }    rander()  },  /**   * 选牌开始   * 所有当前卡牌归位   */  card_selection_func() {    let that = this    //设置开始选牌为true    that.setData({      card_selection: true    })  },  //在min和max之间取随机  rnd(min, max) {    return min + Math.floor(Math.random() * (max - min + 1));  },  /**   * 用户点击右上角分享   */  onShareAppMessage: function(options) {    var that = this;    return {      title: \"塔罗牌测试\",      path: '/pages/start/start',      imageUrl: \"/img/share.png\",      success: function(res) {        var shareTickets = res.shareTickets;        //如果分享不成功，或者不是到群        if (shareTickets.length == 0) {          return false;        }      }    }  },})requestAnimationFrame.js// 模拟 web端的requestAnimationFrame// lastFrameTime为上次更新时间var lastFrameTime = 0;var doAnimationFrame = function(callback) {  //当前毫秒数  var currTime = new Date().getTime();  //设置执行该函数的等待时间，如果上次执行时间和当前时间间隔大于16ms，则设置timeToCall=0立即执行，否则则取16-(currTime - lastFrameTime)，确保16ms后执行动画更新的函数  var timeToCall = Math.max(0, 16 - (currTime - lastFrameTime));  // console.log(timeToCall)  var id = setTimeout(function() {    callback(currTime + timeToCall);    //确保每次动画执行时间间隔为16ms  }, timeToCall);  //timeToCall小于等于16ms，lastFrameTime为上次更新时间  lastFrameTime = currTime + timeToCall;  return id;};// 模拟 cancelAnimationFramevar abortAnimationFrame = function(id) {  clearTimeout(id)}module.exports = {  doAnimationFrame: doAnimationFrame,  abortAnimationFrame: abortAnimationFrame}作者：hoarcat 原文：https://blog.csdn.net/qq_31604363/article/details/88788496"}
{"title": "微信小程序生命周期与性能指标 ", "author": "2019-5-5 00:47", "pub_time": "2019-5-5 00:47", "content": "本文将介绍微信小程序整个App的生命周期、单个页面的生命周期和组件的生命周期，并研究了这三个元素生命周期的关系，这在学习和开发过程中对理解小程序运行机制有重要意义。最终，由生命周期整理出小程序的关键指标，仅供参考。App的生命周期在app.js中有其生命周期相关的三个方法：onLaunch、onShow和onHide。首先是onLaunch，这是整个小程序的第一个生命周期回调函数，在小程序初始化完成后调用。接着，小程序将触发onShow事件，如果小程序从后台切回前台后也会触发该事件。最后，是小程序切到后台的事件onHide。Page的生命周期在每个页面注册函数Page()的参数中，有生命周期的方法：onLoad、onShow、onReady、onHide、onUnload。页面触发的第一个生命周期回调是onLoad，在页面加载的时候触发，其参数是页面的query参数，一个页面只有一次；接着是onShow，监听页面的显示，与onLoad不同，如果页面被隐藏后再次显示（例如：进入下一页后返回），也会触发该生命周期；触发onShow之后，逻辑层会向渲染层发送初始化数据，渲染层完成第一次渲染之后，会通知逻辑层触发onReady生命周期，一个页面只有一次；onHide是页面隐藏但未卸载的时候触发的，如 wx.navigateTo 或底部tab切换到其他页面，小程序切入后台等。onUnload是页面卸载时触发，如wx.redirectTo或wx.navigateBack到其他页面时。Component的生命周期组件最重要的生命周期是created、attached、detached ，包含一个组件实例生命流程的最主要时间点。首先，当组件实例刚被创建时， created生命周期被触发。此时，还不能调用setData 。 通常情况下，这个生命周期只应该用于给组件this添加一些自定义属性字段。接着，在组件完全初始化完毕并且进入页面节点树后， attached生命周期被触发。此时， this.data 已被初始化为组件的当前值，绝大多数初始化工作可以在这个时机进行。在组件离开页面节点树后， detached生命周期被触发。退出一个页面时，如果组件还在页面节点树中，则 detached 会被触发。此外，组件生命周期还有ready和move生命周期，分别在视图层布局完成和组件实例被移动到节点树另一个位置时执行。整体周期现在我们知道了App、Page、和Component分别的生命周期顺序，那么他们之间的生命周期顺序又是如何？通过开发一个简单的demo，观察运行结果，可以得到如下结论：打开页面的情况首先，前一个页面隐藏，在加载下一个页面之前，需要先初始化新页面的组件。页面首次渲染之后，会触发组件的ready，最后触发的是页面的onReady，如下图：从PageA打开pageB时的生命周期顺序离开页面的情况离开当前页面时，首先触发当前页面的卸载onUnload，接着是组件离开节点树的detached。最后显示之前的页面，触发onShow。如下图：从PageB返回到PageA的生命周期顺序打开App的情况App、Page与Component生命周期运行顺序，先从App加载然后再加载Page，在加载Page之前会先初始化该页面所用的所有组件，之后才触发页面的onLoad生命周期，如下图：打开App时的生命周期顺序切换到后台切换到后台时，小程序和页面并没有卸载，只会触发隐藏。先触发页面的onHide，接着是App的onHide。如下图：切换到后台时的生命周期顺序切换到前台切换到后台时，小程序会先触发onShow，之后才是页面的onShow。如下图：切换到前台时的生命周期顺序关键性能指标了解了小程序各个阶段的生命周期，我们可以制定出关键节点的性能指标，整理如下表：参考文档官方文档 Page：developers.weixin.qq.com/miniprogram…官方文档 App：developers.weixin.qq.com/miniprogram…官方文档 页面生命周期：developers.weixin.qq.com/miniprogram…官方文档 组件生命周期：developers.weixin.qq.com/miniprogram…"}
{"title": "小程序开发前的准备工作 ", "author": "2019-5-13 00:56", "pub_time": "2019-5-13 00:56", "content": "磨刀不误砍柴工，在开发之前做好准备工作可以大大提升开发效率、减少冗余代码，这篇文章结合自己做过的几个小程序的经验做一个总结【demo地址】。\r\n\r\n\r\n相关参考 vant-weapp、武装你的小程序——开发流程指南\r\n\r\n着手开发小程序前都有哪些工作要准备？\r\n\r\n重写小程序Page、Component函数\r\nRequest方法封装\r\nRouter路由封装\r\nLess的使用\r\nUtil的封装\r\n\r\n\r\n为什么要重写Page、Component函数？\r\n\r\n准备开发页面之前你是否经历过这样...\r\n\r\nimport store from \"../utils/store\";\r\nimport util from \"../utils/util\";\r\nimport fetch from \"../utils/fetch\";\r\nimport config from \"../utils/config\";\r\n\r\nPage ({\r\n  // ...  \r\n})\r\n复制代码每个页面都要复制粘贴 我@#$%^&*\r\n\r\n以下办法可能会解决这些问题 并且相当舒适\r\n\r\n创建Init.js 并引入到app.js里， 像这样⬇️\r\n\r\nrequire('./utils/Init.js');\r\n\r\nApp({\r\n  onLaunch: function () {}\r\n})\r\n复制代码\r\n重写Page、Component函数\r\n\r\n\r\n函数重写思考：小程序属于单页面应用，全局的页面组件注册全依靠Page、Component函数，实际上就是调用了一个函数 传入了一个对象，那我们能不能在函数调用前，对参数做一些小动作呢？\r\n\r\n先来试验一下\r\n编辑Init.js\r\n// 函数劫持 重写注册函数\r\nlet originPage = Page;\r\nPage = (opt) => {\r\n    // 在传入Page函数的参数中 添加一个util对象\r\n    opt.util = {\r\n        test () {\r\n            return 1;\r\n        }\r\n    }\r\n    return originPage(opt);\r\n}\r\n复制代码在页面onLoad方法中测试一下\r\nPage({\r\n  data: {\r\n  },\r\n  onLoad: function () {\r\n    console.log(this.util.test())\r\n  }\r\n})\r\n复制代码结果输出如下\r\n输出结果\r\n运行成功！接下来你应该懂我的意思 塞他！\r\n编辑Init.js\r\nimport _store from \"./store\";\r\nimport _util from \"./util\";\r\nimport _fetch from \"./fetch\";\r\n\r\nlet originPage = Page;\r\nPage = (opt) => {\r\n    // 把创建好的工具类引入opt参数内\r\n    opt = {\r\n        ...opt,\r\n        _store,\r\n        _util,\r\n        _fetch\r\n    }\r\n    return originPage(opt);\r\n}\r\n复制代码然后在页面中输出一下this关键字\r\n嗯...终于不用引乱七八糟的东西了\r\n注意！Component函数中如果也这么写 组件实例中并不会出现添加的对象 像这样 \r\n// Init.js\r\nimport _store from \"./store\";\r\nimport _util from \"./util\";\r\nimport _fetch from \"./fetch\";\r\n\r\nlet originComponent = Component;\r\nComponent = (opt) => {\r\n    opt.util = {\r\n        test() {\r\n            return 1\r\n        }\r\n    }\r\n    return originComponent(opt);\r\n}\r\n\r\n------------\r\n// components/img/index.js\r\nComponent({\r\n  attached () {\r\n    this.test();\r\n  },\r\n  methods: {\r\n    test() {\r\n      console.log(this.util)\r\n    }\r\n  }\r\n})\r\n\r\n复制代码运行结果\r\n但这就不代表我没有办法 \r\n编辑init.js 重写component部分\r\nComponent = (opt) => {\r\n  // Component函数的options无法直接插入参数 只能在某个生命周期函数被调用时动态赋值\r\n  let originAttached = opt.attached || function () {};\r\n  opt.attached = function(e) {\r\n    this.util = {\r\n      a() {\r\n        return 1;\r\n      }\r\n    };\r\n    return originAttached.apply(this);\r\n  }\r\n  return originComponent(opt)\r\n}\r\n复制代码运行结果\r\n最终把下面的各种工具类添加上之后 简单写个请求、跳转 大概就是这个样子\r\nPage({\r\n  data: {\r\n  },\r\n  onLoad: function ({ goodId }) {\r\n    this._fetch({\r\n      url: \"getGoods\",\r\n      data: { goodId }\r\n    }).then(res => {\r\n      if (res.length) {\r\n        this._router.go(\"detail\", { firstGoodsId: res[0].id })\r\n      }\r\n    })\r\n  }\r\n})\r\n复制代码\r\n\r\n以下是工作中各种用到的封装\r\nRequest方法封装\r\n\r\nwx.request方法封装点：请求状态、错误统一处理，以当前上下文可控制页面所有需要请求状态的组件\r\n\r\nFetch.js\r\nconst host = {\r\n  Dev: \"http://test.com\"\r\n}\r\n\r\nconst api = {\r\n  getUserInfo: \"...\",\r\n  getGoods: \"...\"\r\n}\r\n\r\nexport default function ({ url, data, showLoading = false }) {\r\n  let self = this;\r\n  changeFetchState(self, true);\r\n  showLoading && wx.showLoading({ title: showLoading })\r\n  return new Promise((resolve, reject) => {\r\n    const options = {\r\n      url: host.Dev + api[url],\r\n      method: \"POST\",\r\n      header: { \"content-type\": \"application/json\" },\r\n      data,\r\n      success: ({ data }) => {\r\n        resolve(data.data, data);\r\n      },\r\n      fail: err => {\r\n        reject(err);\r\n      },\r\n      complete() {\r\n        changeFetchState(self, false);\r\n        showLoading && wx.hideLoading();\r\n      }\r\n    };\r\n\r\n    wx.request(options);\r\n  })\r\n}\r\n// 以当前作用域调用，可控制页面需要请求状态的组件\r\nfunction changeFetchState (self, state) {\r\n  self && self.setData({ _fetchState: state });\r\n}\r\n复制代码\r\nRouter路由封装\r\n\r\n规范路由管理、传参，以{key:value}形式定义路由，重新封装路由跳转方法，方便调用。\r\n\r\nRouter.js\r\n// 路由定义\r\nconst routePath = {\r\n  \"index\": \"/pages/index/index\",\r\n  \"detail\": \"/pages/detail/index\",\r\n  \"service\": \"/pages/service/index\"\r\n};\r\n// tabbar名单 特殊处理\r\nconst tabbar = ['index', 'service']\r\n\r\nconst Router = {\r\n  // 参数转换\r\n  parse: function (data) {\r\n    if (!data) return '';\r\n    let tempArr = [];\r\n    for (let key in data) {\r\n      tempArr.push(`${key}=${encodeURIComponent(data[key])`);\r\n    }\r\n    return '?' + tempArr.join('&');\r\n  },\r\n  go: function (path = 'index', params = null, duration = 0) {\r\n    setTimeout(() => {\r\n      const isTabbar = tabbar.indexOf(path) == -1;\r\n      // 如果是tabbar用switchTab方法切换\r\n      wx[isTabbar ? 'navigateTo' : 'switchTab']({\r\n        url: routePath[path] + this.parse(params),\r\n      })\r\n    }, duration * 1000);\r\n  },\r\n  goBack: function (delta = 1, duration) {\r\n    setTimeout(() => {\r\n      wx.navigateBack({ delta })\r\n    }, duration * 1000)\r\n  }\r\n}\r\n\r\nexport default Router;\r\n复制代码\r\nLess的使用\r\n首先全局安装less插件 npm install less -g\r\nWebStorm -> Preferences\r\nTools -> File Watchers -> 新建监听文件选择Less -> 【重点】设置Output文件格式为wxss\r\n\r\nUtil通用类封装\r\n\r\n自己常用的工具大概有这几种：Storage存储、页面地址取参、获取当前上下文等等，通常Util一下也想不全都是在开发中边用边写，以下几个为例子。\r\n\r\nUtil.js\r\n// Storage相关\r\nfunction getStore (name1, name2) {\r\n  if (!name1) return false;\r\n  let baseStore = wx.getStorageSync(name1);\r\n  if (!baseStore) return false;\r\n  return name2 ? (baseStore[name2] || '') : baseStore;\r\n}\r\nfunction setStore (name, value) {\r\n  if (!name) return false;\r\n  return wx.setStorageSync(name, value);\r\n}\r\nfunction setStoreChild (name1, name2, value) {\r\n  if (!name1 || !name2) return false;\r\n  let baseStore = getStore(name1) || {};\r\n  baseStore[name2] = value;\r\n  return setStore(name1, baseStore);\r\n}\r\n/**\r\n * 获取数据类型\r\n * @param value\r\n * @returns {*}\r\n */\r\nfunction getValueType(value) {\r\n  if (typeof value === 'number') return Number;\r\n  if (typeof value === 'string') return String;\r\n  if (typeof value === 'boolean') return Boolean;\r\n\r\n  if (value instanceof Object && !value instanceof Array) return Object;\r\n  if (value instanceof Array) return Array;\r\n\r\n  return null;\r\n}\r\n/**\r\n * 获取当前页面上下文\r\n * @returns {*}\r\n */\r\nfunction getPageContext() {\r\n  var pages = getCurrentPages();\r\n  return pages[pages.length - 1];\r\n}\r\n/**\r\n * 获取元素\r\n * @param classItem\r\n */\r\nfunction $select(className, cb) {\r\n  const query = wx.createSelectorQuery().in(this)\r\n  query.select(className).boundingClientRect()\r\n  query.selectViewport().scrollOffset()\r\n  query.exec(function (res) {\r\n    cb(className.substr('0') === '#' ? res[0] : res);\r\n  })\r\n}\r\n\r\nmodule.exports = {\r\n  getStore,\r\n  setStore,\r\n  setStoreChild,\r\n  getValueType,\r\n  getPageContext,\r\n  $select\r\n}\r\n复制代码"}
{"title": "小程序实现录音时的麦克风动画效果 ", "author": "2019-5-21 00:23", "pub_time": "2019-5-21 00:23", "content": "前言\r\n这个简单的麦克风demo的创意是来源于“包你说”中的录音效果，实现的方式其实也并不难，但对于小程序中的简易动画的使用的确很实用。\r\n效果\r\n先来看个demo，gif帧数比较低，实际效果和真机测试的流畅性还是很OK的\r\n\r\n#思路\r\n通过setTimeout配合this.sedData来改变image中的src路径来生成动画。动画的播放以及隐藏则通过wx:if绑定一个自定义的参数来控制。下面就直接上代码。\r\n代码\r\nhtml\r\n    <view class='animation-talk'>\r\n        <image src='../../image/receive{{receiveImg}}.png' wx:if=\"{{showTalk}}\" mode='aspectFill'></image>\r\n    </view>\r\n    <view>\r\n        <image src='../../image/voice{{voiceNum}}-btn.png' bindlongpress=\"longPress\" bindtouchend=\"endTouch\" ></image>\r\n    </view>\r\n复制代码javascript\r\n    var playTalk //录音动画定时器\r\n    Page({\r\n        data:{\r\n            showTalk: false, //显示录音动画\r\n            receiveImg: 3, //按压播放语音动画\r\n            voiceNum: 2, //按压录音时效果图\r\n            config: app.globalData.apiUrl,//demo接口\r\n        },\r\n        //长按读语音\r\n        longPress() {\r\n            var that = this;\r\n            that.setData({\r\n                voiceNum: 1,\r\n                showTalk: true\r\n            });\r\n            that.animationTalk();\r\n            var url = that.data.config;\r\n            wx.startRecord({\r\n                success(res) {\r\n                    const tempFilePath = res.tempFilePath; //录音成功后的文件\r\n                    wx.saveFile({\r\n                        tempFilePath: tempFilePath,  //保存文件到本地并生成临时路径\r\n                        success(res) {\r\n                            wx.uploadFile({         //上传语音文件到服务器\r\n                                url: url,\r\n                                filePath: res.savedFilePath,\r\n                                name: 'file',\r\n                                formData: {\r\n                                    token: that.data.token,\r\n                                    name: 'file'\r\n                                },\r\n                                success(res) {\r\n                                    that.setData({\r\n                                        voiceUrl: JSON.parse(res.data).file_url\r\n                                    })\r\n                                    that.receivePage() //校验语音正确率，此步骤未贴出\r\n                                }\r\n                            })\r\n                        }\r\n                    })\r\n                }\r\n            })\r\n        },\r\n        // 播放录音动画\r\n        animationTalk() {\r\n            var that = this;\r\n            if (!that.data.showTalk) {\r\n                that.setData({\r\n                    receiveImg: 1\r\n                });\r\n                clearTimeout(playTalk)\r\n            } else {\r\n                switch (that.data.receiveImg) {\r\n                    case 1:\r\n                        that.setData({\r\n                            receiveImg: 2\r\n                        })\r\n                        break\r\n                    case 2:\r\n                        that.setData({\r\n                            receiveImg: 3\r\n                        })\r\n                        break\r\n                    case 3:\r\n                        that.setData({\r\n                            receiveImg: 1\r\n                        })\r\n                        break\r\n                }\r\n                setTimeout(function () {\r\n                    that.animationTalk()\r\n                }, 500)\r\n            }\r\n        },\r\n        // 录音结束\r\n        endTouch() {\r\n            var that = this;\r\n            wx.stopRecord();\r\n            that.setData({\r\n                voiceNum: 2,\r\n                showTalk: false,\r\n            })\r\n        },\r\n    })\r\n复制代码写在之后\r\n通过this.setData来制造动画事件仅仅适合项目中的简单动画效果，如若要完成其他动画特效，如我们胡建的中秋博饼的动画，则需要使用更为强大的css3中的动画效果，这一点小程序的支持也是十分给力的。"}
{"title": "微信小程序预览也可以获取数据的 ", "author": "2019-5-31 00:11", "pub_time": "2019-5-31 00:11", "content": "我们在写小程序的时候，手机端预览的发现获取不到数据，只能是用真机调试才可以，可以mac端的开发者工具对于真机调试的体验苦不堪言，各种bug（官方bug）。所以我想有没有什么办法直接使用预览也可以一样获取到数据呢。花了一天的时间，终于是成功了。我室友预览的时候一样可也以有数据。\r\n关键点：\r\n手机，服务器，保持同一局域网。\r\n第一步：开启局域网\r\n方法1）使用电脑开启共享wifi，手机连接此wifi。不过这里因为我们学校内部网需要账号登陆，所以我没采用这种方法，不过这种方法的后续流程和第二种方法差不多。\r\n方法2）手机开启热点，电脑连接此热点。\r\n1）连接后，首先找到分配给电脑的IP。mac获取IP在设置->网络，里面就可以看到。\r\n\r\n或者在终端输入ifconfig，可以找到\r\n\r\n第二步：修改服务器地址\r\n我后台使用的SpringBoot，在properties里面直接修改\r\n\r\n第三步：修改url地址：\r\n之前使用的url地址类似于：http://localhost:8080/user/login/\r\n修改后服务器地址后同一修改为：http://172.20.10.2:8080/user/login/\r\n重启后台，然后在postman测试一下：\r\n\r\nok，可以获取到数据。\r\n然后我们把小程序里的request里的url全部使用这种方法。\r\n\r\n重新编译后，测试一下可不可以获取到数据，如果之前步骤没错，肯定没问题的。\r\n我们直接使用预览，也是一样可以获取到数据的。\r\n注意点：\r\n1） 在后台修改了地址后，以后必须在热点环境下运行项目，不然会报错。（我就是有一次忘记连热点，结果一直启动失败，我还以为是8080端口占用问题）\r\n2）如果要别人预览你的小程序，得先连接你的热点，才能获取到数据。\r\n总结：\r\n对了，如果你还有了网页，那么一样可以使用这种方法在手机上访问你的界面的。\r\n小程序截图：\r\n\r\n网页手机截图："}
{"title": "如果将老项目的小程序快速改为分包模式 ", "author": "2019-5-31 00:22", "pub_time": "2019-5-31 00:22", "content": "在最开始准备制作小程序的时候，为了求开发的快速，所使用了直接page的引入方式，每次小程序加载都是全包下载。3月份之前小程序页面稳定在35个，下载耗时在1800ms左右，4月份初上线了新业务页面膨胀到52个页面时，下载耗时基本稳定在2300ms左右，随着用户反馈越来越多，所以开始准备小程序采用分包加载，来解决这个问题。5月份在分包加载之后，页面依旧稳定在52个，但是下载耗时稳定800ms左右，缩短了将近1500ms。基本做到了0业务入侵、加入npm script 来实现新建页面，同时兼容分包加载，page加载。操作流程执行命令npm run new\r\n复制代码弹出单选，并且输入路径[Info] 帮助你快速创建page文件\r\n[Info] 只局限于新目录创建\r\n[Info] 请输入文件路径，已帮你省略pages/\r\n[Info] 例子：address/addressList\r\n? 请输入文件路径：\r\n复制代码输入路径之后创建文件的提示[Info] 已创建base64.js\r\n[Info] 已创建index.js\r\n[Info] 已创建index.json\r\n[Info] 已创建index.wxml\r\n[Info] 已创建index.wxss\r\n[Info] 创建完成！！！！\r\n复制代码选择包，是主包、还是分包，并且提示，如果是tabBar中使用，只能选择主包，并且手动配置app.json的tabBar? 你想生成什么样的包： (Use arrow keys)\r\n❯ 主包，在pages中写入，如果是tabBar中使用，只能选择主包，并且手动配置app.json的tabBar\r\n  分包，在subpackages中写入\r\n复制代码单选完成之后提示新建成功[Info] 写入成功\r\n复制代码第一次分包首先我们对未分包和分包的app.json代码进行对比// 未分包\r\n\"pages\": [\r\n  \"pages/a/index\",\r\n  \"pages/b/index\",\r\n  \"pages/b/list\",\r\n]\r\n复制代码// 实现分包\r\n\"subpackages\": [\r\n  {\r\n    \"root\": \"pages/a\",\r\n    \"pages\": [\r\n      \"index\",\r\n    ]\r\n  },\r\n  {\r\n    \"root\": \"pages/b\",\r\n    \"pages\": [\r\n      \"index\",\r\n      \"list\"\r\n    ]\r\n  }\r\n]\r\n复制代码接下来看目录结构pages\r\n  |---- a\r\n        |---- index.js\r\n  |---- b\r\n        |---- index.js\r\n        |---- list.js\r\napp.json\r\n复制代码简单分一下，第一次分包的核心业务是，将pages这个普通列表，变成名为subpackages的二叉树状态结构，左子节点是root，右子节点是pages，并且右子节点是string类型，左子节点是array类型。好吧，我可以定下规则，首先我可以将 pages/a/index 这个字符串变为数组以 / 为分界的 ['pages','a','index'] 数组，然后我将前两项作为root节点的参数，用slice操作截取出来，转为字符串类型，赋值给root。之后的所有参数，我都赋值或者push给pages参数，最后我就得到了这样一个符合要求的树，最后push进subpackages即可。至于数据源，我只需要读出app.json这个文件的pages参数，并且通过我的方法写入subpackages参数即可。要点去重，因为subpackages内，root节点是唯一的，但是在pages里面可能我会截取初重复的值解决使用Map结构，把截取出的root值作为key，剩下的作为value，Map数据这种数据结构的特点就是key值唯一。let list = [\r\n  \"pages/a/index\",\r\n  \"pages/a/list\",\r\n  \"pages/a/detail/index\",\r\n  \"pages/c/list\",\r\n  \"pages/b/index\",\r\n];\r\n\r\nlet m = new Map();\r\nlet packages = [];\r\nlist.forEach(v=>{\r\n  let arr = v.split('/');\r\n  let root = arr.splice(0,2).join('/');\r\n  let pages = arr.join('/');\r\n\r\n  if(m.get(root)){\r\n    let s = m.get(root);\r\n    m.set(root,[...s, pages]);\r\n  }else{\r\n    m.set(root,[pages]);\r\n  };\r\n});\r\nfor(let [key,value] of m){\r\n  packages.push({\r\n    root: key,\r\n    pages: value,\r\n  })\r\n}\r\n\r\nconsole.log(packages);\r\n复制代码// log 出的结构\r\n[\r\n  { root: 'pages/a', pages: [ 'index', 'list', 'detail/index' ] },\r\n  { root: 'pages/c', pages: [ 'list' ] },\r\n  { root: 'pages/b', pages: [ 'index' ] }\r\n]\r\n复制代码我已经在不入侵业务的情况下实现了小程序的第一次分包，节约了我手动去改的劳动力，我个人认为，解决问题，上策用数据结构，中策写兼容代码，下策手动去改。至于，读出写入文件，我就不赘述了，google即可。创建pages的指令编写好吧，我实现了第一次的分包。然后我要思考，如果我每次要加页面的话，是不是就要去查看subpackages，找到对应的root，并且添加pages。这么重复劳动力的操作，我为什么不用脚本替代呢，是吧。核心需求编写交互式的命令输入检测输入的page是否存在不存在创建page目录，复制template根据用户选择，选择写入pages，或者写入subpackages在page文件加中预留componet文件夹，用做业务拆分，不加检测page是否存在的方法引入静态文件，保存pages级别的目录，也不被检测设计npm script{\r\n  \"subcontract\": \"node ./config/subcontract\",\r\n  \"new\": \"node ./config/new\"\r\n}  \r\n复制代码添加的package.json参数{\r\n  \"ignore-files\": [\r\n    \"**/common/**\",\r\n    \"**/component/**\",\r\n    \"<name>/**\",\r\n    \"<name>/**\",\r\n    \"<name>/**\",\r\n  ],\r\n  \"pages\": [\r\n    \"pages/<name>/index\",\r\n    \"pages/<name>/index\",\r\n    \"pages/<name>/index\",\r\n  ]\r\n}\r\n复制代码需求已经明确，我就要去找我需要用到的npm包了colors        命令行颜色\r\ninquirer      交互式命令行\r\nglob          全局搜索文件\r\nfs-extra      文件写入写出\r\npath          路径\r\nshelljs       执行shell命令\r\n复制代码分析 new.js 文件const colors = require('colors');\r\nconst inquirer = require('inquirer');\r\nconst glob = require('glob');\r\nconst fs = require('fs-extra');\r\nconst path = require('path');\r\nconst shell = require('shelljs');\r\nconst PKG = require('../package.json');\r\nconst ROOT = path.resolve(__dirname, '../');\r\n\r\nlet appJson = require('../app.json');\r\nconst promps = [{\r\n  type: 'input',\r\n  name: 'pagePath',\r\n  message: '请输入文件路径：',\r\n},\r\n{\r\n  type: 'list',\r\n  name: 'type',\r\n  message: '你想生成什么样的包：',\r\n  choices: [\r\n    {\r\n      name: '主包，在pages中写入，如果是tabBar中使用，只能选择主包，并且手动配置app.json的tabBar',\r\n      value: '1',\r\n    },\r\n    {\r\n      name: '分包，在subpackages中写入',\r\n      value: '2',\r\n    },\r\n  ],\r\n}];\r\nconst logger = {\r\n  info(msg) {\r\n    console.log(`[Info] ${colors.green(msg)}`);\r\n  },\r\n  warn(msg) {\r\n    console.log(`[Warn] ${colors.yellow(msg)}`);\r\n  },\r\n  error(msg) {\r\n    console.log(`[Error] ${colors.red(msg)}(／‵Д′)／~ ╧╧`);\r\n  },\r\n};\r\n\r\nlogger.info('帮助你快速创建page文件');\r\nlogger.info('只局限于新目录创建');\r\nlogger.info('请输入文件路径，已帮你省略pages/');\r\nlogger.info('例子：xxxxx/xxxx');\r\n复制代码这是代码中的常量部分和默认提示部分，我写了logeer对象来作为提示输出的默认颜色，promps作为我交互命令行的基础配置。引入package.json我的主要目的是因为我屏蔽了一些文件 ignore-files 和 pages ，想这两个参数的文件夹我是不会检测的。function checkFile(name) {\r\n  const options = {\r\n    ignore: [\r\n      '**/*.js',\r\n      '**/*.wxss',\r\n      '**/*.wxml',\r\n      '**/*.json',\r\n    ],\r\n    cwd: 'pages/',\r\n  };\r\n  const files = glob.sync('**', options);\r\n  if (files.some((v) => v === name)) {\r\n    logger.error('输入的目录已经存在，已终止！！！！');\r\n    return false;\r\n  };\r\n  return name;\r\n};\r\n复制代码检查文件夹是否存在这是检测文件是否存在的方法，我只需要得到路径，即可检测这个路径是否在目录中存在。function buildFile(name) {\r\n  const options = {\r\n    cwd: 'template/page',\r\n  };\r\n  const files = glob.sync(`**`, options);\r\n\r\n  files.forEach((v)=>{\r\n    const file = v.split('.tp')[0];\r\n    fs.copy(`${ROOT}/template/page/${v}`, `${ROOT}/pages/${name}/${file}`, (err) => {\r\n      if (err) {\r\n        console.error(err);\r\n        return false;\r\n      }\r\n    });\r\n    logger.info(`已创建${file}`);\r\n  });\r\n  logger.info('创建完成！！！！');\r\n  return true;\r\n};\r\n复制代码这是复制文件夹并且复制模版文件的方法，我准备了tempalte这个文件夹，用来存储我写的模版文件，创建完成之后，我直接复制进去即可function subcontract(res) {\r\n  inquirer.prompt(promps[1]).then((answers)=>{\r\n    if (answers.type === '1') {\r\n      PKG['ignore-files'].push(`${res}/**`);\r\n      PKG['pages'].push(`${res}/index`);\r\n      appJson['pages'].push(`pages/${res}/index`);\r\n      fs.writeFileSync(`${ROOT}/app.json`, JSON.stringify(appJson, null, 2));\r\n      fs.writeFileSync(`${ROOT}/package.json`, JSON.stringify(PKG, null, 2));\r\n      logger.info('写入成功');\r\n    };\r\n    if (answers.type === '2') shell.exec('npm run subcontract');\r\n  });\r\n};\r\n复制代码这是选择pages还是subcontract的方法，选择了subcontract，我直接执行我上面写的小程序分包方法 subcontract.js 即可。如果选择pages，我会将它加入package.json中的 ignore-files对象，这个对象表式这些文件名不被subcontract脚本检测。async function inquirers() {\r\n  const {pagePath} = await inquirer.prompt(promps[0]);\r\n  const path = pagePath.replace(/\\s+/g, '');\r\n\r\n  if (!path) {\r\n    logger.error('输入有失误，已终止！！！！');\r\n    return false;\r\n  };\r\n  if (/.*[\\u4e00-\\u9fa5]+.*$/.test(path)) {\r\n    logger.error('请不要输入中文符号，已终止！！！！');\r\n    return false;\r\n  };\r\n\r\n  return path;\r\n};\r\n复制代码检测输入值是否合法，并且去除空格( async function() {\r\n  const inquirerRes = await inquirers();\r\n  const checkFileRes = inquirerRes && checkFile(inquirerRes);\r\n  const buildFileRes = checkFileRes && buildFile(checkFileRes);\r\n  buildFileRes && subcontract(checkFileRes);\r\n})();\r\n复制代码最后组装，inquirerRes变量负责判断输入值是否正确。然后进入checkFile，来检测文件夹是否重复。调用buildFile方法，创建文件夹，复制模版文件。最后调用subcontract来判断是分包还是主包。subcontract.js 分析const glob = require('glob');\r\nconst fs = require('fs');\r\nconst path = require('path');\r\nconst colors = require('colors');\r\nconst ROOT = path.resolve(__dirname, '../');\r\nconst PAG = require('../package.json');\r\nlet appJson = require('../app.json');\r\n\r\nconst ignoreFiles = PAG['ignore-files'];\r\nconst pages = PAG['pages'];\r\nconst logger = {\r\n  info(msg) {\r\n    console.log(`[Info] ${colors.green(msg)}`);\r\n  },\r\n  warn(msg) {\r\n    console.log(`[Warn] ${colors.yellow(msg)}`);\r\n  },\r\n  error(msg) {\r\n    console.log(`[Error] ${colors.red(msg)}(／‵Д′)／~ ╧╧`);\r\n  },\r\n};\r\n\r\nconst subcontract = () => {\r\n  const options = {\r\n    ignore: ignoreFiles,\r\n    cwd: 'pages/',\r\n  };\r\n  const files = glob.sync('**/index.js', options);\r\n\r\n  let subcontractMap = new Map();\r\n  files.forEach((v)=>{\r\n    let arr = v.split('.')[0].split('/');\r\n    let root = arr.shift();\r\n    let page = arr.join('/');\r\n\r\n    if (subcontractMap.has(root)) {\r\n      let pages = subcontractMap.get(root);\r\n      pages.push(page);\r\n      subcontractMap.set(root, pages);\r\n    } else {\r\n      subcontractMap.set(root, [page]);\r\n    }\r\n  });\r\n\r\n  let subcontractList = [];\r\n  subcontractMap.forEach((v, k)=>{\r\n    subcontractList.push({\r\n      root: `pages/${k}`,\r\n      pages: v,\r\n    });\r\n  });\r\n\r\n  return subcontractList;\r\n};\r\n\r\nappJson.subpackages = subcontract();\r\nappJson.pages = pages;\r\nfs.writeFileSync(`${ROOT}/app.json`, JSON.stringify(appJson, null, 2));\r\nlogger.info('写入成功');\r\n复制代码这个方法其实和小程序第一次分包的方法大同小异。只不过我修改了数据源的获取，第一次我是读取app.json的pages，这里我是根据目录来的，以及加入了ignoreFiles来做文件屏蔽。以及一些友好提示。结尾项目优化的道路还有很长这只是最最初步的方案。为什么我开始不直接选择分包呢？因为项目开始的时候还没有分包，而且如果有，我感觉分包机制可能会带给开发者出错的可能性，我为了将项目工期缩短，出错可能性降低，我也不会选择一开始就分包。当业务增长到一定量，以及业务逐渐趋向于稳定时候，我就可以根据业务的特性，去做相对应的事情。这种方式我称之为技术迭代。在何时的时候，选择何时的业务，坚决不过度设计。到此为止，其实我最想输出的是思路。我关于上中下，三策的理解，我对业务的理解。谢谢。"}
{"title": "小程序swiper轮播CSS3动画及跳转到指定swiper-item实现思路 ", "author": "2019-6-3 00:08", "pub_time": "2019-6-3 00:08", "content": "需要解决的问题近几日一直在看怎样制作微信小程序的swiper轮播图。因为我既需要生成小程序的代码，也需要生成H5版代码，如果编写两套效率会比较低下，所以选择了 uni-app 。uni-app 已经在基础组件 swiper 中已经直接支持了轮播动画。我主要需要解决的是以下几个问题：animate.css\r\nswiper-item\r\n以下就是我整个制作的思路过程，仅供参考。另外，代码是 uni-app 开发，所以在小程序中和H5中测试都没有问题。另外为了方便 小程序 开发同学了解，会提供 小程序 版代码和 uni-app代码供参考。代码实现在H5开发中经常使用的就是 animate.css 。在微信中自然是支持的，因为微信会对上传的小程序有大小限制，所以这里我使用了一个极简化的 animate.css ，其中删掉了很多 -webkit-animation 开头的css3。因为我们只需要在小程序和H5中运行，这样做影响也不大。如果需要的话，可以从下面的代码中获取。我们先来看下代码：<template>\r\n    <view class=\"content\">\r\n        <button type=\"primary\" @tap=\"goChange\">跳转到第二屏</button>\r\n        <swiper class=\"content-swiper\" :vertical=\"true\" :indicator-dots=\"true\" :autoplay=\"false\" :interval=\"3000\" :duration=\"1000\" @change=\"changeSwiper\" @animationfinish=\"changeFinish\" :current-item-id=\"item_id\" circular=\"true\">\r\n            <swiper-item item-id=\"slide0\">\r\n                <view class=\"swiper-item\">\r\n                    <image src=\"../../static/uni.png\" :class=\"animate_0\"></image>\r\n                </view>\r\n            </swiper-item>\r\n            <swiper-item item-id=\"slide1\">\r\n                <view class=\"swiper-item\">\r\n                    <image src=\"../../static/uni.png\" :class=\"animate_1\"></image>\r\n                </view>\r\n            </swiper-item>\r\n            <swiper-item item-id=\"slide2\">\r\n                <view class=\"swiper-item\">\r\n                    <image src=\"../../static/uni.png\" :class=\"animate_2\"></image>\r\n                </view>\r\n            </swiper-item>\r\n            <swiper-item item-id=\"slide3\">\r\n                <view class=\"swiper-item\">\r\n                    <image src=\"../../static/uni.png\" :class=\"animate_3\"></image>\r\n                </view>\r\n            </swiper-item>\r\n        </swiper>\r\n    </view>\r\n</template>\r\n\r\n<script>\r\n    export default {\r\n        data() {\r\n            return {\r\n                item_id: 'slide2',\r\n                animate_0: 'animated swing',\r\n                animate_1: '',\r\n                animate_2: '',\r\n                animate_3: ''\r\n            }\r\n        },\r\n        onLoad() {\r\n\r\n        },\r\n        methods: {\r\n            changeSwiper(event){    // 清空除了当前swiper以外的所有动画\r\n                let current = event.detail.current;    // 当前页下标\r\n                this.item_id = 'slide'+current;     // 这里必须记录，否则只能跳转一次\r\n                switch (current){\r\n                    case 0:\r\n                        this['animate_1'] = this['animate_2'] = this['animate_3'] = '';\r\n                    break;\r\n                    case 1: \r\n                        this['animate_0'] = this['animate_2'] = this['animate_3'] = ''; \r\n                    break;\r\n                    case 2:\r\n                        this['animate_0'] = this['animate_1'] = this['animate_3'] = '';\r\n                    break;\r\n                    case 3:\r\n                        this['animate_0'] = this['animate_1'] = this['animate_2'] = '';\r\n                    break;\r\n                }\r\n\r\n            },\r\n            changeFinish(event){ // swiper动画完成之后，给当前swiper添加动画效果\r\n                let current = event.detail.current;\r\n                switch(current){\r\n                    case 0: \r\n                        this['animate_0'] = 'animated swing';\r\n                    break;\r\n                    case 1:\r\n                        this['animate_1'] = 'animated shake';\r\n                    break;\r\n                    case 2:\r\n                        this['animate_2'] = 'animated tada';\r\n                    break;\r\n                    case 3:\r\n                        this['animate_3'] = 'animated heartBeat';\r\n                    break;\r\n                }\r\n            },\r\n            goChange(){\r\n                this.item_id = 'slide1';\r\n            }\r\n        }\r\n    }\r\n</script>\r\n\r\n<style lang=\"scss\">\r\n    @import '../../common/animate.css';\r\n    \r\n    .content {\r\n        text-align: center;\r\n        .content-swiper{\r\n            height: 100vh;\r\n            \r\n            image{\r\n                height: 200upx;\r\n                width: 200upx;\r\n                margin-top: 200upx;\r\n            }\r\n        }\r\n    }\r\n</style>首先 uni-app 支持sass。在css中直接引入了简洁版 animate.css 。 问题①之后通过查看文档，发现 circular 这个参数可以实现类似H5页面使用 swiper.js loop 参数的功能。这里我掉到了 uni-app 和 微信小程序 文档描述的坑中。因为一直在找 loop （循环）这个参数，我甚至都以为实现不了这个无限循环的功能了呢。原来 小程序 中这个参数叫做 circular （圆形）。o(╯□╰)o 问题③因为我这里要实现一个竖屏的滑动效果，所以将参数 vertical 设置为 true 。在 uni-app 中，通过 change 事件，可以监听每一个轮播屏的改变。在这个事件中，我记录的当前屏的下标 current 。然后将 非当前屏 的全部css3动画取消掉。最后在 animationfinish 事件中，当 swiper 滑动动画结束后，给当前屏的元素添加css3动画。 问题②在 uni-app 中有个 current-item-id 参数，代表当前所在滑块的 item-id 。这个文档我看了好久，才明白。原来是需要在 swiper-item 中指定上 item-id 。然后当用户点击事件触发时，修改绑定到 current-item-id 上的值即可。我的代码初始化时指定到了 item-id 为 slide2 这一屏上。 问题④最后一个问题时 uni-app 中隐藏掉H5导航栏。只需要在 pages.json 中设置 titleNView 为false 即可。我将代码托管到了 腾讯云开发者平台 ，需要的话可以参考。在代码目录 unpackage/dist/build/h5 中，就是生成好的H5版页面。需要注意的是，要部署到web服务器使用，不支持本地file协议打开。微信小程序代码<!--index.wxml-->\r\n<view class=\"container\">\r\n    <button bindtap='goChange'>跳转到</button>\r\n    <swiper vertical=\"true\" circular=\"true\" current=\"{{currentId}}\" indicator-dots=\"true\" bindchange=\"changeSwiper\" bindanimationfinish=\"changeFinish\">\r\n        <swiper-item>\r\n            <image src='../../static/uni.png' class='animated {{animate_0}}'></image>\r\n        </swiper-item>\r\n        <swiper-item>\r\n            <image src='../../static/uni.png' class='animated {{animate_1}}'></image>\r\n        </swiper-item>\r\n        <swiper-item>\r\n            <image src='../../static/uni.png' class='animated {{animate_2}}'></image>\r\n        </swiper-item>\r\n    </swiper>\r\n</view>\r\n//index.js\r\nconst app = getApp()\r\n\r\nPage({\r\n    data: {\r\n        currentId: 0,\r\n        animate_0: 'swing',\r\n        animate_1: '',\r\n        animate_2: ''\r\n    },\r\n    onLoad: function() {\r\n\r\n    },\r\n    goChange: function() {\r\n        this.setData({\r\n            currentId: 2\r\n        });\r\n    },\r\n    changeSwiper: function(event) {\r\n        let current = event.detail.current;\r\n        switch (current) {\r\n            case 0:\r\n                this.setData({\r\n                    animate_1: '',\r\n                    animate_2: ''\r\n                });\r\n                break;\r\n            case 1:\r\n                this.setData({\r\n                    animate_0: '',\r\n                    animate_2: ''\r\n                });\r\n                break;\r\n            case 2:\r\n                this.setData({\r\n                    animate_0: '',\r\n                    animate_1: ''\r\n                });\r\n                break;\r\n        }\r\n    },\r\n    changeFinish: function(event) {\r\n        let current = event.detail.current;\r\n        switch (current) {\r\n            case 0:\r\n                this.setData({\r\n                    animate_0: 'swing',\r\n                });\r\n                break;\r\n            case 1:\r\n                this.setData({\r\n                    animate_1: 'shake',\r\n                });\r\n                break;\r\n            case 2:\r\n                this.setData({\r\n                    animate_2: 'tada',\r\n                });\r\n                break;\r\n        }\r\n    }\r\n})"}
{"title": "小程序setData()使用和注意事项 ", "author": "2019-6-3 00:24", "pub_time": "2019-6-3 00:24", "content": "注意：\r\n\r\n直接修改this.data，而不调用this.setData()，是无法改变当前页面的状态的，会导致数据不一致\r\n仅支持可以JSON化的数据\r\n单次设置的数据不能超过1024KB，尽量避免一次设置过多的数据\r\n不要把data中的任何一项的value设为undefined，否则这一项将不能被设置，可能会有潜在的问题\r\n\r\n代码示例：\r\nPage({\r\n\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n data: {\r\n    value:\"初始值\"    //定义一个变量value，赋值为：“初始化”\r\n\r\n  },\r\n   /**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  onLoad: function (options) {\r\n\r\n  }\r\n  })复制代码直接在wx:request()的success回调函数中使用this.setData()会报这样一个错误：因为这里的this是相对于wx:request()的当前对象解决：因为这里的wx:rewuest()是在页面加载时调用，所以我们可以在onLoad（）中定义一个变量that ，将this赋值给that，那么此时的that代表相对于onLoad（）的当前对象，然后在success回调函数中直接使用that.setData()即可。如果是获取实例方式：var that; 全局定义that变量\r\n\r\nvar option = {    data: { }};\r\n\r\nvar requestCallback =function (err, data) {    if (err) {          ************************    } else {\r\n\r\n        that.setData({          cosImage: data.headers.Location        })\r\n    }};\r\n\r\noption.simpleUpload = function () {  that = this;  //这里定义 this \r\n\r\n    // 选择文件    wx.chooseImage({        count: 1, // 默认9        success: function (res) {            **********************************            }, requestCallback);        }    })};\r\n//获取应用实例Page(option);\r\n\r\n复制代码还有一个需要注意到地方就是：如果在onReady（）函数中调用setData（）方法，那么通过这个方法设置的值只能刷新一次，若需要再次刷新，需要清除缓存。data: {\r\n    isChecked: [true, true, true, true, true, true, true, true, true, true, true]\r\n}\r\n复制代码\r\n如上，如果我想动态修改isChecked里面指定某个下标的值怎么办？\r\n下面我来说怎么动态修改一个对象的某元素的值。上面这个是索引下标，等会还有个key-value的例子。\r\n代码：\r\nclick: function (e) {    \r\n    var id = e.target.id//根据点击不同的view获取对应的id值\r\n    var str = \"isChecked[\" + id + \"]\"//重点在这里，组合出一个字符串\r\n    this.setData({\r\n      [str]: false//用中括号把str括起来即可\r\n    })\r\n}\r\n复制代码\r\n看注释。点击->触发对应事件->来到click函数这里，根据点击的view获取对应的id，修改指定下标的isChecked。\r\n上面这个isChecked的索引是从0到n的，即可以通过isChecked[0]、isChecked[1]来访问。可以在操作的过程中打印日志看一下数据类型。\r\n\r\n哦，对了，在wxml中如果要绑定isChecked中元素的值，可以这么：\r\n<view class=\"{{isChecked[2]?'main_view':'main_view_clicked'}}\" bindtap='click' bindlongpress='cancelclick' id='2' bindtap='click'></view>\r\n不要在意那个三目运算，反正类似于js中访问方式，也是isChecked[index]。同理，下面的key-value类型的就可以通过isChecked[index].key来绑定数据了。\r\n\r\n下面是key-value类型的：\r\ndata: {\r\n    isChecked: [\r\n      { \r\n        key: true \r\n      },\r\n      { \r\n        key: true \r\n      },\r\n      { \r\n        key: true\r\n      }\r\n    ]\r\n}\r\n复制代码\r\n直接写操作方式了（因为就跟上面只有一点点的区别）：\r\n    var str = \"isChecked[\" + id + \"].key\"\r\n    this.setData({\r\n      [str]: false\r\n    })复制代码结束~"}
{"title": "微信小程序性能,行为收集探针实现 ", "author": "2019-6-3 09:52", "pub_time": "2019-6-3 09:52", "content": "​小程序的主要开发语言是 JavaScript ，小程序的开发同普通的网页开发相比有很大的相似性。对于前端开发者而言，从网页开发迁移到小程序的开发成本并不高，但是二者还是有些许区别的。​网页开发渲染线程和脚本线程是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应，而在小程序中，二者是分开的，分别运行在不同的线程中。网页开发者可以使用到各种浏览器暴露出来的 DOM API，进行 DOM 选中和操作。而如上文所述，小程序的逻辑层和渲染层是分开的，逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，因而缺少相关的DOM API和BOM API。这一区别导致了前端开发非常熟悉的一些库，例如 jQuery、 Zepto 等，在小程序中是无法运行的。同时 JSCore 的环境同 NodeJS 环境也是不尽相同，所以一些 NPM 的包在小程序中也是无法运行的。​网页开发者需要面对的环境是各式各样的浏览器，PC 端需要面对 IE、Chrome、QQ浏览器等，在移动端需要面对Safari、Chrome以及 iOS、Android 系统中的各式 WebView 。而小程序开发过程中需要面对的是两大操作系统 iOS 和 Android 的微信客户端，以及用于辅助开发的小程序开发者工具，小程序中三大运行环境也是有所区别的运行限制基于安全考虑，小程序中不支持动态执行 JS 代码，即：不支持使用 eval 执行 JS 代码 不支持使用 new Function 创建函数​网页开发者在开发网页的时候，只需要使用到浏览器，并且搭配上一些辅助工具或者编辑器即可。小程序的开发则有所不同，需要经过申请小程序帐号、安装小程序开发者工具、配置项目等等过程方可完成。小程序运行机制小程序启动小程序启动会有两种情况，一种是「冷启动」，一种是「热启动」。热启动：假如用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需将后台态的小程序切换到前台，这个过程就是热启动；冷启动：用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动，即冷启动。 小程序没有重启的概念。前台/后台状态当用户点击右上角胶囊按钮关闭小程序，或者按了设备 Home 键离开微信时，小程序并没有直接销毁，而是进入了后台状态；当用户再次进入微信或再次打开小程序，小程序又会从后台进入前台。小程序销毁需要注意的是：只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。当小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后（目前是5分钟）小程序会被微信主动销毁。 当小程序占用系统资源过高，可能会被系统销毁或被微信客户端主动回收。 在 iOS 上，当微信客户端在一定时间间隔内（目前是 5 秒）连续收到两次及以上系统内存告警时，会主动进行小程序的销毁，并提示用户 「该小程序可能导致微信响应变慢被终止」。 建议小程序在必要时使用 wx.onMemoryWarning 监听内存告警事件，进行必要的内存清理。小程序更新机制未启动时更新开发者在管理后台发布新版本的小程序之后，如果某个用户本地有小程序的历史版本，此时打开的可能还是旧版本。微信客户端会有若干个时机去检查本地缓存的小程序有没有更新版本，如果有则会静默更新到新版本。总的来说，开发者在后台发布新版本之后，无法立刻影响到所有现网用户，但最差情况下，也在发布之后 24 小时之内下发新版本信息到用户。用户下次打开时会先更新最新版本再打开。启动时更新小程序每次冷启动时，都会检查是否有更新版本，如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上。如果需要马上应用最新版本，可以使用 wx.getUpdateManager API 进行处理。小程序探针开发难点与重点无法直接拦截/监听请求微信请求统一通过微信API完成 ，请求模块已被微信方封装，且小程序的运行环境不是浏览器对象，不像web应用那样重写封装很自如。三种运行环境的监控兼容性保证Android 上，js运行环境是 X5 内核iOS 上，js 运行环境是 JavaScriptCore开发工具上， j s运行环境是 nwjs（chrome内核）用户行为无法直接监听小程序逻辑层运行时无法获取DOM和BOM,无法像传统网页开发一样使用DOM事件API,无法全局监听事件.sdk需轻量小程序包大小有限制,单包最大为2M,分包情况下,不能超过8M,所以sdk需轻量数据收集量大，尽量减少性能损耗需要设计缓存池,制定上报策略不影响业务（基本需求）探针缓存池与上报策略探针收集到的数据主要分为两种,一种是基本数据,还有一种是事件特性数据.特性数据在下面关键事件中将会提到基础数据基本数据是每条上报日志都包含的数据。其中一部分,在初始化探针后就获取到，并且不会改变.这部分数据,业务相关的由用户配置,其余数据由探针内部生成或者调用wx.getSystemInfoSync API获取另一部分，随着用户行为，比如页面切换、登陆,或者环境变化,如网络变化时,将会改变.network数据通过 wx.getNetworkType 与 wx.onNetworkStatusChange获取 title部分在下面的关键事件有讲到事件特性数据![]( user-gold-cdn.xitu.io/2019/5/30/1…上报策略探针内部将会缓存对应日志,防止小程序Storage清空时,遗失数据.数据上报只要上报,就将缓存的日志清空,防止上报失败导致缓存的日志越积越多探针关键事件捕获关键事件类型改写App config对于App类主要改写config上的\"onShow\", \"onHide\", \"onError\", 'onLaunch'这几个生命周期缓存钩子函数给config上的方法挂上钩子,对config中未配置对应生命周期,加上默认生命周期回调对config包含了\"onShow\", \"onHide\", \"onError\",'onLaunch'生命周期函数,执行完原方法后再调用钩子函数启动事件(start)小程序启动,获取小程序启动场景值.重写App的config,通过onLaunch触发. 获取小程序启动场景值scene,页面路径path,页面search,通过页面路径与 __wxConfig对象获取页面title.退出到后台(pause)小程序切换到后台,重写App的config,通过onHide触发切回前台(resume)小程序从后台唤醒,获取切回小程序场景值scene.重写App的config,通过onShow触发(第一次触发onShow除外)异常捕获由于小程序的全局监听方法wx.onError只有2.1.2及以上才支持,为了兼容,需要重写App的config,通过onError触发.改写Page config这一部分与改写App config大同小异,主要看事件的获取页面停留(page_stay)onHide与onUnload时触发,获取用户在当前页面停留的时间.对于分享转发页面导致onHide触发的场景,不进行页面停留上报.页面切换(page)每次切换页面(onShow)时触发,获取当前页面路径,参数,title页面初次渲染时长页面首次打开或销毁后首次打开,页面渲染所花费的时间,重写Page的config,通过onReady触发.页面分享(share)用户分享转发页面时触发,通过重写Page的config,onShareAppMessage触发.由于页面分享会触发当前页面的onShow,onHide生命周期,为了数据准确,通过设置变量isPause来甄别.用户行为捕获由于用户行为总是与事件相关,对于事件,小程序无法直接监听dom事件,这里采取的方案是对App、Page、Component、Behavior的config进行改写,判断,判断config上的属性是否为函数,并且函数的形参是否为事件源,如果是事件源,说明该函数与用户行为现关联对于Component、Behavior只需对其config.method上的方法进行hook通过形参是否具有currentTarget属性判断当前是否为事件函数对于不存在自定义事件属性的点击事件,认定为点击事件,对于存在的,认定为自定义事件点击事件(click)由于小程序的逻辑层与渲染层是分开的,逻辑层运行在JSCore中,没有完整的浏览器对象,缺少dom与bom相关api,无法在body上设置全局的点击事件监听方法.为了实现事件的监听,探针通过改写Page 、Component和Behavior的config,对config上的所有属性进行区分,判断当前属性是否为函数,并且该函数触发时,形参上是否具有currentTargey属性来区分形参是否为事件对象,以此监听页面事件.对于tap与longpress事件,探针认定为点击事件.类型触发条件tap手指触摸后马上离开longpress手指触摸后，超过350ms再离开，如果指定了事件回调函数并触发了这个事件，tap事件将不被触发自定义事件(log)直接在事件函数内调用探针暴露的自定义事件上报方法会导致业务代码与探针耦合度过高.探针结合事件的监听通过在绑定了事件的小程序标签上添加自定义属性,来实现自定义事件的上报.由于事件触发时的事件源经微信内部封装过,自定义属性的获取目前只支持数据属性data-xxx的形式获取,所以在非手动调用时,可以在触发点击事件的小程序标签上增加data-event 与 data-log来添加低耦合的自定义事件代码.改写wx对象实现api事件捕获api事件(api)覆写wx对象,对wx.request方法的config进行重写,获取api(数据接口地址)、api_method(数据接口请求方式)、api_status(数据接口响应状态码)、api_response_time(数据接口响应时间(ms))、api_response_content_length (数据接口响应内容长度(byte))小程序的api基本都挂载在全局对象wx上,直接修改wx上面的属性,将会报错,直接赋值失败(小程序内部对此做出了限制)thirdScriptError \r\n sdk uncaught third Error \r\n Cannot set property request of #<Object> which has only a getter \r\n TypeError: Cannot set property request of #<Object> which has only a getter\r\n复制代码替代方案使用Object.getOwnPropertyDescriptors获取到wx对象的属性描述符,将微信对象重新赋值为空对象,循环属性描述符,判断当前描述符的键是否为request,并进行改造request属性描述符,其他情况使用Object.defineProperty方法定义属性由于for in循环获取不到Symbol类型的键,为了兼容wx对象将来引入Symbol作为wx对象键的情景,使用Object.getOwnPropertySymbols方法获取到属性描述符中的Symbol,再重新定义属性这一块代码太多了,不好截图,直接上代码吧// 重写wx.request\r\n  rewriteWxRequest() {\r\n    const that = this;\r\n    \r\n    // return \r\n    // 重写wx对象start\r\n    const descriptorObj = Object.getOwnPropertyDescriptors(wx);\r\n    let oldWx = this.oldWx = wx;\r\n    wx = {};\r\n    for (let i in descriptorObj) {\r\n      if (i === 'request') {\r\n        const desObj = descriptorObj[i];\r\n        let oldGet = desObj.get;\r\n        desObj.get = function(...args){\r\n          let oldRequest = oldGet.apply(this, args);\r\n          return function(params){\r\n            const {\r\n              url,\r\n              method = 'GET',\r\n              success = function(){},\r\n      \r\n            } = params;\r\n            // 检查API请求是否在忽略的url中\r\n            const ignoreUrls = that.conf.api_ignore_urls;\r\n            if (url && isIgnoreApi(url, ignoreUrls)) {\r\n              return oldRequest.call(this, params);\r\n            }\r\n            // 处理自定义 api url trim func\r\n            let apiTrimUrl = null;\r\n            if (that.conf.api_property_cb) {\r\n              try {\r\n                apiTrimUrl = that.conf.api_property_cb(url) || null;\r\n              } catch (e) {\r\n                apiTrimUrl = null;\r\n              }\r\n            }\r\n\r\n            const timeStamp = Date.now();\r\n            const apiData = {\r\n              api: apiTrimUrl || cutAPIUrl(url),\r\n              api_method: method.toUpperCase(),\r\n              api_status: undefined,\r\n              api_response_time: 0,\r\n              api_response_content_length: 0,\r\n            }\r\n            return oldRequest.call(this, {\r\n              ...params,\r\n              success (res) { // 成功回调\r\n                try {\r\n                  const {\r\n                    data,\r\n                    statusCode\r\n                  } = res\r\n                  apiData.api_status = statusCode;\r\n                  apiData.api_response_time = Date.now() - timeStamp;\r\n                  if (data) {\r\n                    let AB = {};\r\n                    if(typeof ArrayBuffer !== undefined) {\r\n                      AB = ArrayBuffer;\r\n                    }\r\n                    if (data instanceof AB && data.byteLength !== undefined) {\r\n                      apiData.api_response_content_length = data.byteLength;\r\n                    } else {\r\n                      if (typeof data === 'string') {\r\n                        apiData.api_response_content_length = data.length || 0;\r\n                      } else {\r\n                        apiData.api_response_content_length = JSON.stringify(data).length || 0;\r\n                      }\r\n                    }\r\n                  } else {\r\n                    apiData.api_response_content_length = 0;\r\n                  }\r\n                  that.reportApi(apiData)\r\n                } catch (e) {\r\n                  that.consoleErr(e);\r\n                }\r\n                success.call(this, res);\r\n              },\r\n            })\r\n          }\r\n        }\r\n        Object.defineProperty(wx, i, desObj)\r\n      } else {\r\n        Object.defineProperty(wx, i, descriptorObj[i])\r\n      }\r\n    }\r\n    // 对微信将来引入Symbol的情况进行兼容,防止丢失以Symbol为键的情况\r\n    if (Object.getOwnPropertySymbols && typeof Object.getOwnPropertySymbols === 'function') {\r\n      Object.getOwnPropertySymbols(descriptorObj).forEach(val => {\r\n        Object.defineProperty(wx, val, descriptorObj[val])\r\n      })\r\n    }\r\n    // 重写wx对象end\r\n  }\r\n复制代码待优化错误异常无法定位到源码目前只支持原生框架和mpvue框架,并且不能适用微信第三方插件自定义事件无法像web探针,在任意标签上添加"}
{"title": "利用watch在小程序中实现全局状态共享 ", "author": "2019-6-4 00:43", "pub_time": "2019-6-4 00:43", "content": "在之前开发微信小程序的时候，获取用户信息、openid还有地理位置这些信息的时候，都是采用 Promise 的方式异步获取，但是这样的话在页面和App.js中都获取就可能造成 请求重复 的问题。比如为了在每个页面都能获取到这些共享信息，都会选择在App.js中进行获取，然后在页面级进行获取，这两次获取的时间间隔较小时就可能导致前一个请求还未获取到数据，后一个请求就会再次进行获取，这样就产生了两次请求。还有一个问题就是书写麻烦(虽然也能通过async await简化)，比如onLoad() {\r\n    app.getUserInfo()\r\n    .then(userInfo => {\r\n        \r\n    }).catch(err => { /* 错误处理 */ });\r\n    \r\n    // 如果同时需要userInfo和openid，可能就是如下形式：\r\n    Promise.all([app.getUserInfo(), app.getOpenid()])\r\n    .then(res => {\r\n        \r\n    }).catch(err => { /* 错误处理 */ });\r\n}\r\n复制代码正好周末的时候突然想到了vue的watch语法，利用一些相关的知识，就可以解决这个麻烦的问题了。解决思路双向绑定vue的双向绑定原理，3.0将会采用Proxy监听数据变化，不过考虑到小程序这边的Proxy兼容性我不知道，所以采用了2.0的Object.defineProperty来监听数据的变化。主要还是拦截设置的操作，在进行赋值时，将新旧值通知至监听者。观察者模式在页面级的onLoad 监听 app.globalData 各个键名的事件 ，而在app.js的onLoad中则使用Object.defineProperty重新定义app.globalData，这样一旦app.globalData相应的键值发生了变化，就会通知监听的页面该值发生了变化。模块化的引用观察者模式导出的是一个对象（类实例），而不是一个类，所以在导入的时候这个对象是共享的，就可以通过这个对象将app.js和其他页面联系起来。至于模块加载的实质，ES6模块加载的机制，与CommonJS模块完全不同。感兴趣的可以去看看这个。封装Page小程序的Page函数本身是不支持watch，但是我们可以自定义一个函数，进行参数合并就可以了。在页面onLoad时先遍历watch属性，对app.globalData进行监听，可以参考vue的watch用法。页面onUnload时就会进行销毁，此时也应该取消监听，这些我都封装过了，不用手动处理了。有了这些思路，用不了多久，一个雏形就出来了，经过手动测试，感觉没什么问题，我就发布到npm了，大家感兴趣的可以安装体验一下。安装npm i wx-watch -S --production\r\n复制代码使用// app.js\r\nvar { watchData, } = require('/miniprogram_npm/wx-watch/index.js');\r\n\r\nApp({\r\n  onLaunch() {\r\n    this.watchData(); /* 监听this.globalData的变化，并触发事件，其他页面监听的值必须在globalData中预先定义，否则无法监听 */\r\n  },\r\n  watchData,\r\n  globalData: {\r\n    userInfo: null,\r\n  }\r\n});\r\n\r\n// 其他需要监听globalData的页面.js\r\nvar { getPage } = require('../../miniprogram_npm/wx-watch/index.js');\r\nconst app = getApp();\r\n\r\n/**\r\n * getPage(页面参数，app) app必传，因为封装的时候访问不到，就只能传参了\r\n*/\r\ngetPage({\r\n  watch: {\r\n    userInfo(userInfo, oldUserInfo) {\r\n      console.log(`来自app.glodalData的userInfo`);\r\n    }\r\n  },\r\n  // 其他参数\r\n}, app)\r\n复制代码github: github.com/ma125120/wx…要是用的还行，欢迎star。要是有问题，欢迎提交issue。"}
{"title": "小程序如何做全局重新加载 ", "author": "2019-6-4 00:44", "pub_time": "2019-6-4 00:44", "content": "背景：随着业务的增加，我们服务器需要计算大量的用户数据，导致用户跟客服反应页面不能正常展示。反馈给开发后，我们一看，是服务器异常的错误。So，产品想看下我们到底有多少用户页面不能正常展示？方案：后端人员直接在阿里云后台去查哪些接口异常 前端做一个服务器报错页，这样产品在小程序后台能看到这个页面的PV,UV技术方案因为业务庞大，所以我们不可能区在每个页面加上重新加载的逻辑。所以初步考虑使用全局重新加载。需要解决的问题都有哪些？1、首先我们要有网络请求失败的全局控制权（要不然就需要在每个页面处理失败的情况） 2、需要定义好网络失败后是如何跳转到重载页（R）的（用wx.redirectTo，wx.reLaunch还是其他） 3、点击错误页的“重新加载”，如何返回或跳转到出错页(E)（用wx.redirectTo，wx.reLaunch还是其他） 4、跳转到出错页后，如何重新加载数据（把所有请求都放在Page.onShow()里面?） 5、那如果从出错页的上个界面(P)传到出错页（E）options，那重载页（R）又将如何处理？ 6、点击重新加载跟返回，我们希望效果效果一样，又该如何操作？实践的方式如下1、第一个问题： 比较好解决，我们基于wx.request已经封装了为fetch（如果还在用wx.request的项目可以考虑封装下，好处多多）。基于fetch我们可以用res.statusCode来判断服务器是否出错。 2、第二个问题： 暂且先不说具体的跳转方式是怎样的，就跳转的url这个怎么定义也需要我们来讨论下。为什么这么说，因为我们的架构涉及到了分包。分包加载意味着我们的代码不仅仅是在pages下面，还放在了package下。 基于此，我们在跳转的时候，url能直接写成'../serverError/serverError'吗？在主包下面可以正常跳转，但是在分包下，路径是'package/serverError/serverError'，这样跳肯定不行。url应该是根目录下的路径，所以'/pages/serverError/serverError'。 路径确认后，我们可以跳转了。如果是wx.redirectTo（关闭当前页面，跳转到应用内的某个页面），想象下关闭E跳转到R，点击重新加载，再关闭R跳转到E，这么跳转路径复杂，用户体验不好，并且options的参数需要逐级传递。wx.reLaunch类似。我们用所以我们选择wx.navigateTo。 3、第三个问题： 综合问题二的解释，跳回到E，我们用wx.navigateBack。 4、第四个问题： 如果从R用wx.navigateBack回到E的话，肯定会触发E.onShow()方法。但是有些请求我们除了写在Page.onShow()里，还有些是写在Page.onLoad()里的，所以我们必须想办法调起E.onLoad()。 大家对于getCurrentPages()这个方法肯定不陌生，官方定义是来获取当前页面栈，我们一般用它来获取当前页面路径。其实在这个过程中，我们是能拿到当前页面的实例的，并且实例里面有route（页面路径）options（页面传递参数）data(页面初始参数)以及各种function()等等。 利用previousPageClass()我们可以拿到E的实例，也就可以拿到E.options，当然我们也可以调E.onLoad()。 util.js// 获取当前路径function currentPagePath() {  let pageData = getCurrentPages()  if (pageData.length >= 1) {    let len = pageData.length - 1    let data = pageData[len]    return data.route  } else {    return ''  }}// 获取上个界面的实例function previousPageClass() {  let pageData = getCurrentPages()  if (pageData.length >= 2) {    let len = pageData.length - 2    let preClass = pageData[len]    return preClass  } else {    return ''  }}module.exports = {  currentPagePath,  previousPageClass}第五个问题： 基于问题的四的方案，我们可以调E.onLoad(E.options)来将我们的参数回传回去。 第六个问题： 点击返回，相当于页面卸载，也就是执行了R.onUnload(),这个时候我们只需要执行E.onLoad(E.options)这个方法，把options传过去，以及调用起E.onLoad()就OK了。 但是点击重新加载，我们是调的wx.navigateBack()，这个方法也会走R.onUnload()。这是时候可能有些苦恼了，我们隐藏掉返回按钮？发现官方并没有提供此方法。禁用R.onUnload()，好像也不行。因为R.onUnload()是在点击重新加载后才执行的，所以我们可以记录下用户是否点击了重新加载的行为。然后我们通过记录的行为，即便用户点击了重新加载，然后触发了R.onUnload()，我们不去执行E.onLoad(E.options)就OK了。 // pages/serverError/serverError.jsimport { previousPageClass } from '../../utils/util.js'let isClickReload = falsePage({  onLoad: function (options) {    isClickReload = false  },  onUnload: function () {    if(!isClickReload) {      this.callbackParams()    }      },  /**   * 点击事件   */  clickReload: function (e) {    isClickReload = true    wx.navigateBack()    this.callbackParams()  },  // 点击返回，参数回传  callbackParams: function () {    let preOptions = previousPageClass().options    previousPageClass().onLoad(preOptions)  }})至此所有问题，基本都已解决。 Demo代码附上，欢迎参考。"}
{"title": "滴滴小程序框架Mpx支持小程序跨平台开发，可直接转换已有微信小程序 ... ", "author": "2019-6-4 00:49", "pub_time": "2019-6-4 00:49", "content": "Mpx是一款致力于提高小程序开发体验和效率的增强型小程序框架，目前在滴滴公司内部支撑了包括滴滴出行小程序，滴滴出行广场小程序，青桔单车，黑马电单车，小桔养车，小桔加油在内的小程序生态；自去年11月开源以来，Mpx也吸纳了众多外部开发者的加入，基于Mpx开发了开走吧，好免街，花忆等小程序。\r\n长期以来，Mpx优秀的开发体验和强大的稳定性得到了内外开发者的一致认可和好评，这非常符合Mpx的设计初衷。但是在各大厂商陆续推出自己的小程序平台，且各家的技术标准都不统一的今天，单纯地提高某一个平台的开发体验已经不能满足广大小程序开发者们的诉求，一套代码在多小程序平台运行已经成为一个现实上的刚需。为了解决这个小程序开发的痛点，Mpx发布了2.0版本，适配了目前业内已经发布的所有小程序平台(微信、支付宝、百度、头条、qq)，并且提供了直接将现有微信小程序编译输出到其他平台运行的能力。\r\nMpx2.0版本新增的主要特性主要包含：\r\n\r\n完整支持了目前业内已发布的所有小程序平台(微信，支付宝，百度，qq，头条)；\r\nMpx小程序跨平台开发，支持将已有的Mpx微信项目编译输出到其他已支持的小程序平台中运行，点击查看详情；\r\n小程序原生组件跨平台编译，支持将已有的微信原生组件编译输出到其他已支持的小程序平台中运行；\r\n深度分包优化，编译过程中进行精准分包资源判断，所有分包only的资源(组件、js、外部样式、外部模板、wxs，图像媒体等)都会精确输出到分包目录中；\r\nrender函数中完整支持wxs模块，关于render函数点击查看详情；\r\n支持了模板引入，内联wxs，自定义tabbar，独立分包，workers，云开发等原生能力，进一步完善原生兼容性。\r\n\r\n同业内主流的小程序跨端框架相比，Mpx更专注于小程序开发本身，在小程序开发中具备以下优势：\r\n\r\n基于小程序自身的技术标准进行增强，没有进行过重的DSL转换，开发时遇到的坑会更少；\r\n完全兼容原生小程序技术规范，0成本迁移原生小程序项目;\r\n跨平台开发以跨小程序平台为目标，大部分差异抹平工作在编译阶段进行，大大减少运行时适配层增加的包体积；\r\n支持业内微信小程序组件库(如vant、iView等)直接转换到其他小程序平台运行;\r\n非常重视小程序性能，提供了深度的setData和包体积优化。\r\n\r\n关于Mpx更详细的介绍可以查看官方文档和这篇文章。\r\nGithub：github.com/didi/mpx\r\n跨平台开发\r\n作为2.0版本的核心能力，Mpx的跨平台开发能力允许用户直接将已有小程序项目编译输出到其他已支持的小程序平台中运行。微信小程序作为小程序概念的提出者，有着最广泛的生态覆盖，因此我们优先支持了将微信小程序编译为其他平台小程序的能力。基于这个能力，用户不仅能跨平台编译微信Mpx项目，甚至能够将微信的原生自定义组件也编译到其他小程序平台进行运行，这意味着我们的跨平台项目能够直接使用一些社区内已有的UI组件库生态(如vant、iView等)，极大地提高了跨平台开发的适用范围。\r\n设计理念\r\nMpx框架的核心设计理念在于增强，增强是指在小程序已有的原生能力基础上做加法，拓展小程序的开发能力，提高小程序的开发体验和效率。这个设计理念使Mpx给开发者带来了更强的确定性和可预期性，更低的学习上手和调试成本。基于这个理念，Mpx在不同的小程序平台中进行了差异性的增强适配，并参考各个平台的模板指令风格提供了不同的增强模板指令集，让用户在各小程序平台中都可以以增强的方式去最大限度地使用平台自有的原生能力。\r\n我们在对Mpx提供跨平台能力的支持时也遵循了增强的核心设计理念。简单来讲，Mpx的跨平台能力是在多平台能力的基础上，在编译和运行时增加了一层转换层，将源平台的代码转换为目标平台的代码之后，再按照既有的目标平台的处理逻辑进行增强，同时我们也提供了一套完善的条件编译机制，让用户自行实现少数框架无法转换的部分。\r\n\r\nMpx跨平台开发流程示意图\r\nMpx跨平台能力设计思路明显区别于业内已有的其他小程序跨平台框架，主要差异在于：\r\n\r\nMpx以小程序本身的DSL作为基准，而没有使用web框架(React,Vue)的DSL；\r\nMpx主要通过编译和运行时转换的方式处理平台差异，没有提供额外的差异抹平层(基础组件库等)。\r\n\r\n之所以采用这种设计，主要基于以下原因：\r\n\r\nMpx主要以跨小程序平台为目标，目前各大小程序平台的技术规范具有一定相似性，绝大部分平台差异能够通过编译和运行时手段抹平，同时省去的差异抹平层也能够进一步减少框架运行时体积；\r\n使用小程序本身的DSL作为基准允许用户直接在已有项目中使用跨平台能力，对于原生小程序项目或组件也能够使用该能力进行跨平台输出；\r\n结合完善的条件编译支持，该方案能够在满足用户跨平台需求的同时仍然允许用户最大限度地使用各个小程序平台提供的能力，完全延续了Mpx增强的核心设计理念。\r\n\r\n使用方法\r\nMpx跨平台开发的使用方式非常简单，用户只需在MpxWebpackPlugin创建时传入mode和srcMode参数指定源平台和目标平台，当srcMode和mode不一致时，框架会读取相应的配置对项目进行编译和运行时转换。\r\n// 微信转支付宝\r\nnew MpxWebpackPlugin({\r\n  // mode指定目标平台，可选值有(wx|ali|swan|qq|tt)\r\n  mode: 'ali',\r\n  // srcMode指定源码平台，默认值同目标平台一致 \r\n  srcMode: 'wx' \r\n})\r\n复制代码差异抹平\r\n目前各大厂商的小程序技术规范在宏观层面上大致保持一致，但是技术细节方面存在很多差异，大致划分为以下几个部分：\r\n\r\n模板语法/基础组件差异\r\njson配置差异\r\nwxs语法差异\r\n页面/组件对象差异\r\napi调用差异\r\nwebview bridge差异\r\n\r\n其中，对于模板语法/基础组件、json配置和wxs中的静态差异，我们主要通过编译手段进行转换处理，对于这部分差异中无法转换的部分会在编译阶段报错指出；而对于页面/组件对象、api调用和webview bridge中js运行时的差异，我们主要通过运行时手段进行处理，对应的无法转换部分也会在运行时中报错指出。\r\n值得注意的是，我们在跨平台转换中做的工作不仅是对可转换的技术标准进行转换映射，对于一些目标平台中不存在的能力，我们也尽可能地通过编译和运行时手段提供了模拟和支持，最大限度地减少用户在跨平台开发中需要付出的额外工作量。以差异性最大但现实场景也最多的微信转支付宝为例，Mpx模拟提供了许多微信中支持但支付宝中未支持的能力：\r\n\r\n组件自定义事件\r\n组件间关系\r\n获取子组件实例\r\nobservers/property observer\r\n内联wxs\r\n外部样式类\r\n\r\n对于原生自定义组件的跨平台转换，我们会对其进行简单的运行时注入，使其能够使用Mpx框架提供的运行时转换能力。\r\n条件编译\r\n对于框架无法抹平的差异部分，会在编译和运行时报错指出，对于这部分错误，我们提供了完善的条件编译机制让用户能够自行编写目标平台的patch进行修复，该能力也能用于实现具有平台差异性的业务逻辑。\r\n上文中提到Mpx通过读取用户传入的mode和srcMode来决定是否以及如何对项目进行转换，mode和srcMode分别代表整个项目构建的目标平台和源平台，条件编译能够让用户在项目中创建声明了自身平台属性(localSrcMode)的文件和代码块。在项目构建中，框架会优先加载带有localSrcMode声明且localSrcMode与项目目标平台匹配(localSrcMode===mode)的文件和代码块，这部分文件和代码块需要完全依照自身声明的平台标准进行编写，Mpx不会对其进行任何编译和运行时的跨平台转换。\r\nMpx提供了三种维度的条件编译，分别是文件维度，区块维度和代码维度，用户可以根据平台差异的覆盖范围灵活选择使用。\r\n性能优化\r\nMpx框架专注于小程序开发，在性能优化方面我们做过很多尝试和努力，主要集中在两个方面：\r\n\r\n运行时的setData优化\r\n编译构建时的包体积优化\r\n\r\nsetData优化\r\n数据响应是Mpx运行时增强的核心能力，该能力让用户在小程序开发中能够像Vue中一样使用watch和computed特性，并且用直接赋值的方式操作数据驱动视图更新，而不需要手动调用setData方法，换言之框架接管了小程序中的setData调用。\r\n通过各大小程序平台的设计原理和性能优化建议可以得知，setData对于小程序的性能表现非常重要，而setData优化的两大方向在于：\r\n\r\n尽可能减少setData调用的频次\r\n尽可能减少单次setData传输的数据\r\n\r\n为了实现setData的优化，我们在模板编译过程中对于每个组件的模板都生成了一个渲染函数(render function)，该函数模拟模板的渲染逻辑，在每次执行时访问当次渲染所需的数据，并将当次访问过的数据路径记录下来作为函数返回值返回。\r\n在运行时，框架会在每个组件创建时创建一个render watcher，该watcher追踪渲染函数，当渲染依赖数据发生变更时异步执行渲染函数，在render watcher回调中得到渲染函数返回的数据路径，基于这些路径与上一次的缓存数据进行diff比对，过滤掉未发生变化的数据后得到最小必要数据，最后调用setData将最小必要数据发送到真实的小程序渲染层更新视图。\r\n基于这个机制，当数据发生变更时，只有当前渲染依赖的那部分数据发生变更才会异步地触发render watcher的执行，而每次执行后也只有实际发生变更的那部分数据会被setData发送到渲染层。这样用户就能自由地根据业务需求来操作数据，无需关注setData的调用优化，框架能够自动进行程序上最优的setData调用，在提升用户开发体验的同时也提升了程序性能。\r\n在1.x版本中，渲染函数内无法执行wxs的逻辑，对于含有wxs的组件有可能降级到全量设置数据的模式，在2.0版本中，我们将wxs模块转译处理为js可执行的代码后注入到js bundle中，含有wxs的渲染函数也能够正常访问并执行wxs逻辑。\r\n\r\nsetData优化示意图\r\n包体积优化\r\n类似于运行时对于setData的接管，Mpx在编译阶段接管了项目的资源管理。得益于webpack强大的插件机制，Mpx开发了一个深度定制的webpack插件，基于webpack完成小程序的打包构建工作。用户在使用Mpx开发小程序时可以不受限制地使用npm依赖、最新的es特性和css预处理器等现代web开发能力。与此同时，Mpx在包体积优化上也做了很多工作，让用户专注于业务开发而无需花费过多精力进行包体积管理，我们所做的优化工作如下：\r\n\r\n打包构建工作完全基于依赖分析，任何没有被引用的资源都不会出现在dist当中；\r\n对于npm组件和页面的构建也完全基于依赖分析按需打包，不会copy整个miniprogram_dist目录，也不需要执行构建npm，使用体验和包体积均优于微信小程序自身的npm支持方案；\r\n基于webpack提供的能力进行公共模块抽取和代码压缩等优化工作；\r\n完善的分包支持，对所有资源进行从属分析，将所有分包only的资源都输出到分包目录中。\r\n\r\n分包作为微信小程序中优化包体积的核心手段(类似于异步按需加载)，Mpx对其进行了完善的支持。为了精确地标记出分包only的资源，我们在构建时将主包和分包的依赖收集步骤拆分开来串行处理，先处理主包，再处理分包。在主包的处理过程中，将主包页面中引用的所有非js资源(组件、外部样式、外部模板、wxs，图像媒体等)都记录下来，在处理分包时，对分包内引用的非js资源都进行检查，如果被主包引用过则输出到主包中，否则标记为分包only的资源输出到分包目录下。\r\n对于js模块资源，我们在脚手架中生成的构建配置中提供了辅助函数，便于用户进行分包bundle的配置，经过该配置后，分包only的公用模块会被打入分包bundle输出到分包目录下，其余的公共模块会正常打入主bundle中。\r\n在跨平台开发中，我们建议用户使用Mpx提供的packages来定义分包，这样在转换到不支持分包的小程序平台时会自动降级为同步包进行处理。\r\n\r\n分包构建示意图\r\n渐进迁移\r\nMpx提供了良好的渐进迁移支持，对于使用原生或其他小程序框架的开发者来说，采用渐进迁移的方式逐步引入Mpx进行开发成本并不大。\r\n在2.0版本中我们进一步完善了Mpx的原生兼容性，跟进支持了各个小程序平台最新的技术能力，如自定义tabbar，独立分包，分包预加载，workers，云开发等能力，同时补齐了一些1.x版本遗漏的支持。得益于此，对于使用原生小程序开发的开发者来说，迁移Mpx的成本几乎为0，用户只需将对应页面组件的构造函数替换为Mpx提供的createPage/createCompnent，即可使用Mpx提供的各种增强能力。\r\n对于使用其他框架的开发者，Mpx也提供了局部构建的机制，允许用户将特定的页面和组件单独构建输出为原生组件，用户只需手动或者编写脚本输出的原生组件整合进原有项目中即可。\r\n未来规划\r\n作为滴滴公司内部小程序生态的基础设施，我们会对Mpx框架进行长期的维护更新，确保能在第一时间支持各个小程序平台最新的技术特性。与此同时，我们也会进一步完善框架的基础能力，目前已排上日程待支持能力包括：\r\n\r\ni18n\r\nts支持\r\n单元测试支持\r\n\r\n在跨平台能力方面，我们也会根据社区的反馈和建议，以及小程序的标准化进程，对其进行持续的完善与更新。\r\n最后，如果你专注小程序开发，关注开发体验和产品性能，那Mpx会是你最好的选择。"}
{"title": "微信小程序WebSocket实践 ", "author": "2019-6-5 00:23", "pub_time": "2019-6-5 00:23", "content": "微信基础库1.7.0之后的版本提供了新版的WebSocket API，考虑到兼容性问题，尝试整合新旧两种版本的API，进行简单的封装。从以下几个角度对微信小程序中所提供的WebSocket API封装API兼容性重连机制小程序WebSocket API旧版WebSocket API的使用创建 - wx.connectSocket发送消息 - sendSocketMessage监听事件 - onSocketOpenlet socketOpen = false\r\nconst socketMsgQueue = []\r\n// 连接socket\r\nwx.connectSocket({\r\n  url: 'test.php'\r\n})\r\n// 监听打开事件\r\nwx.onSocketOpen(function(res) {\r\n  socketOpen = true\r\n  for (let i = 0; i < socketMsgQueue.length; i++){\r\n    sendSocketMessage(socketMsgQueue[i])\r\n  }\r\n  socketMsgQueue = []\r\n})\r\n// 发送消息\r\nfunction sendSocketMessage(msg) {\r\n  if (socketOpen) {\r\n    wx.sendSocketMessage({\r\n      data:msg\r\n    })\r\n  } else {\r\n    socketMsgQueue.push(msg)\r\n  }\r\n}新版WebSocket API的使用支持1.7.0+，连接后会返回一个SocketTask对象，在该对象上监听该连接的各种事件与执行发送消息等操作。let socketTask = wx.connectSocket({\r\n  url: 'test.php'\r\n})\r\n// 监听打开事件\r\nsocketTask.onOpen(function(res) {\r\n  socketOpen = true\r\n  // 发送信息\r\n  socketTask.send({msg: \"hello world\"})\r\n})并发数1.7.0 及以上版本，最多可以同时存在\t5 个\tWebSocket 连接。1.7.0 以下版本，一个小程序同时只能有一个\tWebSocket 连接，如果当前已存在一个 WebSocket 连接，会自动关闭该连接，并重新创建一个\tWebSocket 连接。模块封装简单封装封装一个兼容新旧socketAPI的模块，仅考虑存在单个socket连接的情况创建与事件监听新版: 在socket连接时会返回一个socketTask对象，监听事件是在该对象的基础上进行旧版: 直接使用wx放进行创建与监听方法统一创建与添加监听函数init() {\r\n  let st = this.connect()\r\n  this.listen(st)\r\n  this.manualClose = false\r\n}创建连接connect() {\r\n  let st = wx.connectSocket(this.config.server)\r\n  return st\r\n}添加事件监听函数listen(st) {\r\n  if (st !== undefined) {\r\n    this.ws = st\r\n    this.ws.onOpen(() => this.openHandle())\r\n    this.ws.onError(() => this.errorHandle())\r\n    this.ws.onClose(() => this.closeHandle())\r\n    this.ws.onMessage(res => this.messageHandle(res))\r\n  } else {\r\n    wx.onSocketOpen(() => this.openHandle())\r\n    wx.onSocketError(() => this.errorHandle())\r\n    wx.onSocketClose(() => this.closeHandle())\r\n    wx.onSocketMessage(res => this.messageHandle(res))\r\n  }\r\n}重连机制预设标记位retryLock = false; // 避免多次同时重连\r\nsocketOpen = false; // 连接状态\r\nmanualClose = false; // 主动断开标记在连接关闭监听函数中执行重连closeHandle() {\r\n  console.info('WebSocket closed')\r\n  this.socketOpen = false\r\n  this.retryLock = false\r\n  // 不论是error还是close都会触发close事件，统一在这里进行重连\r\n  // 初次连接失败不进行重连(失败不会进入到onOpen的监听事件中，那时未声明retryTimes变量)\r\n  this.retryTimes !== undefined && this.reconnect()\r\n}判断重连锁与是否主动断开进行重连reconnect() {\r\n  if (this.retryLock) return\r\n  this.retryLock = true\r\n  // 若manualClose为true，表明不是主动断开\r\n  if (!this.manualClose) {\r\n    // 开始重连\r\n    setTimeout(() => {\r\n      this.retry()\r\n    }, this.retryInterval)\r\n  }\r\n}重连函数，包含重连次数的限制retry() {\r\n  if (\r\n    this.socketOpen ||\r\n    (this.retryTimes > 0 && this.retryCount <= this.retryTimes)\r\n  ) {\r\n    console.warn(`reconnect ending. reconnect ${this.retryTimes} times`)\r\n    if (!this.socketOpen) {\r\n      this.config.closeCallback()\r\n    }\r\n    return\r\n  }\r\n  this.retryTimes += 1\r\n  console.warn(`[ ${this.retryTimes} ]th reconnect WebSocket...`)\r\n  this.init()\r\n}消息队列添加消息队列，当重连后自动发送缓存消息openHandle() {\r\n  this.retryTimes = 0\r\n  this.socketOpen = true\r\n  this.retryLock = false\r\n\r\n  this.messageQueue.map(e => this.send(e))\r\n  this.messageQueue = []\r\n}若发送时断开则先将消息缓存到消息队列中send(value) {\r\n  let data = this.msgWrapper(value)\r\n  data = JSON.stringify(data)\r\n  if (!this.socketOpen) {\r\n    this.messageQueue.push(data)\r\n  } else {\r\n    if (this.ws) {\r\n      this.ws.send({ data })\r\n    } else {\r\n      wx.sendSocketMessage({ data })\r\n    }\r\n  }\r\n}辅助函数添加一些包裹消息格式的工具函数messageIndex = 0;\r\nhelper = {\r\n  isPlainObject: val =>\r\n    Object.prototype.toString.call(val) === '[object Object]',\r\n  nextId: () => {\r\n    this.messageIndex += 1\r\n    return this.messageIndex\r\n  },\r\n  id: () => Date.now() + '.' + this.helper.nextId()\r\n};\r\nmsgWrapper(data) {\r\n  let msg = data\r\n  if (this.helper.isPlainObject(msg)) {\r\n    if (msg.type) {\r\n      return msg\r\n    } else {\r\n      return this.msgWrapper({ type: 'message', msg, id: this.helper.id() })\r\n    }\r\n  } else {\r\n    return this.msgWrapper({ type: 'message', msg, id: this.helper.id() })\r\n  }\r\n}完整代码export default class WXWebSocket {\r\n  messageQueue = []; // 消息队列\r\n  retryLock = false; // 避免多次同时重连\r\n  socketOpen = false;\r\n  manualClose = false; // 主动断开标记\r\n  constructor(config) {\r\n    this.config = config || {}\r\n    // 重连间隔\r\n    this.retryInterval =\r\n      this.config.retryInterval && this.config.retryInterval > 100\r\n        ? this.config.retryInterval\r\n        : 3000\r\n    // 重连次数\r\n    this.retryCount = this.config.retryCount || 5\r\n    this.init()\r\n  }\r\n  init() {\r\n    let st = this.connect()\r\n    this.listen(st)\r\n    this.manualClose = false\r\n  }\r\n  connect() {\r\n    let st = wx.connectSocket(this.config.server)\r\n    console.log('current socket: ', st)\r\n    return st\r\n  }\r\n  listen(st) {\r\n    // 添加监听事件\r\n    if (st !== undefined) {\r\n      // 若存在SocketTask，则要通过readyState判断状态\r\n      // CONNECTING: 0\r\n      // OPEN: 1\r\n      // CLOSING: 2\r\n      // CLOSE: 3\r\n      this.ws = st\r\n      this.ws.onOpen(() => this.openHandle())\r\n      this.ws.onError(() => this.errorHandle())\r\n      this.ws.onClose(() => this.closeHandle())\r\n      this.ws.onMessage(res => this.messageHandle(res))\r\n    } else {\r\n      wx.onSocketOpen(() => this.openHandle())\r\n      wx.onSocketError(() => this.errorHandle())\r\n      wx.onSocketClose(() => this.closeHandle())\r\n      wx.onSocketMessage(res => this.messageHandle(res))\r\n    }\r\n  }\r\n  close() {\r\n    this.manualClose = true\r\n    if (this.ws) {\r\n      this.ws.close()\r\n    } else {\r\n      wx.closeSocket()\r\n    }\r\n  }\r\n  send(value) {\r\n    console.log('send value: ', value)\r\n    let data = this.msgWrapper(value)\r\n    data = JSON.stringify(data)\r\n    if (!this.socketOpen) {\r\n      // add new message to queue\r\n      this.messageQueue.push(data)\r\n    } else {\r\n      if (this.ws) {\r\n        this.ws.send({ data })\r\n      } else {\r\n        wx.sendSocketMessage({ data })\r\n      }\r\n    }\r\n  }\r\n  openHandle() {\r\n    console.info('WebSocket connected')\r\n    this.retryTimes = 0\r\n    this.socketOpen = true\r\n    this.retryLock = false\r\n\r\n    this.messageQueue.map(e => this.send(e))\r\n    this.messageQueue = []\r\n  }\r\n  errorHandle() {\r\n    console.error('WebSocket error')\r\n    this.socketOpen = false\r\n  }\r\n  closeHandle() {\r\n    console.info('WebSocket closed')\r\n    this.socketOpen = false\r\n    this.retryLock = false\r\n    // 不论是error还是close都会触发close事件，统一在这里进行重连\r\n    // 初次连接失败不进行重连(失败不会进入到onOpen的监听事件中，那时未声明retryTimes变量)\r\n    this.retryTimes !== undefined && this.reconnect()\r\n  }\r\n  reconnect() {\r\n    if (this.retryLock) return\r\n    this.retryLock = true\r\n    // 若manualClose为true，表明不是主动断开\r\n    if (!this.manualClose) {\r\n      // 开始重连\r\n      setTimeout(() => {\r\n        this.retry()\r\n      }, this.retryInterval)\r\n    }\r\n  }\r\n  retry() {\r\n    if (\r\n      this.socketOpen ||\r\n      (this.retryTimes > 0 && this.retryCount <= this.retryTimes)\r\n    ) {\r\n      console.warn(`end reconnect. reconnect ${this.retryTimes} times`)\r\n      if (!this.socketOpen) {\r\n        this.config.closeCallback()\r\n      }\r\n      return\r\n    }\r\n    this.retryTimes += 1\r\n    console.warn(`[ ${this.retryTimes} ]th reconnect WebSocket...`)\r\n    this.init()\r\n  }\r\n  messageHandle(res) {\r\n    this.config.responseCallback(res)\r\n  }\r\n  msgWrapper(data) {\r\n    let msg = data\r\n    if (this.helper.isPlainObject(msg)) {\r\n      if (msg.type) {\r\n        return msg\r\n      } else {\r\n        return this.msgWrapper({ type: 'message', msg, id: this.helper.id() })\r\n      }\r\n    } else {\r\n      return this.msgWrapper({ type: 'message', msg, id: this.helper.id() })\r\n    }\r\n  }\r\n  messageIndex = 0;\r\n  helper = {\r\n    isPlainObject: val =>\r\n      Object.prototype.toString.call(val) === '[object Object]',\r\n    nextId: () => {\r\n      this.messageIndex += 1\r\n      return this.messageIndex\r\n    },\r\n    id: () => Date.now() + '.' + this.helper.nextId()\r\n  };\r\n}使用创建连接let socketTask = new WXWebSocket({\r\n  server: this.wsServerOption,\r\n  responseCallback: e => {\r\n    let { data } = e\r\n    let { msg } = JSON.parse(data)\r\n    this.msgStack.push(msg)\r\n  },\r\n  closeCallback: () => {\r\n    this.socketTask = null\r\n  }\r\n})\r\nthis.socketTask = socketTask发送消息sendWSMessage(msg) {\r\n  this.msgStack.push(msg)\r\n  this.socketTask && this.socketTask.send(msg)\r\n},关闭连接closeWS() {\r\n  if (!this.socketTask) return\r\n  if (this.socketTask.socketOpen) {\r\n    this.socketTask.close()\r\n    this.socketTask = null\r\n  }\r\n}"}
{"title": "微信小程序上传文件小结 ", "author": "2019-6-11 00:09", "pub_time": "2019-6-11 00:09", "content": "前言后端用的是\tRails ActiveStorage direct_upload 的处理方式, 前端被要求：MD5-Base64\r\nsigned_id\r\n相关知识因为目前开发任务重且紧，暂时略过此部分，只记录结论要点，后续有时间再补充相关知识要点小结3.0 上传文件（后端 Rails: activeStorage）Step 1: 计算文件MD5-Base64摘要小程序中前端无法获取文件的Binary格式 ，因此无法自行或使用第三方库来计算文件的\tMD5值，但幸运的是，小程序也提供了API来做这件事，请使用：\twx.getFileInfo将获得的\tMD5 值转为\tBase64 格式。可使用此项目中\tutils/base64.js 的\tencode 方法，该方法适用于转换字符串。也可使用\tCryptoJS 库，需要注意的是，\tCryptoJS.enc.Base64.stringify 需要的参数是\tWordArray 格式，不能直接传\tString ，要先用\tCryptoJS.enc.Utf8.parse 转换一下字符串Step 2: 上传文件到上一步返回的指定\tdirect_upload 地址小程序前端无法直接获得文件的\tBinary 格式传给后端，但可以通过\twx.uploadFile 上传文件，通过此接口发送请求，后端可获取到文件\tBinary 格式后端提供的上传文件接口需符合\twx.uploadFile 的要求，即\t请求方式为\tPOST , 并指定所需文件\tkey 名（而不是直接要求把\tBinary 文件丢在请求\tbody 中）"}
{"title": "当微信小程序遇上TensorFlow - tensorflow.js篇 ", "author": "2019-6-11 00:24", "pub_time": "2019-6-11 00:24", "content": "在上一篇推送《 重磅好消息！TensorFlow开始支持微信小程序 》中，介绍了TensorFlow开始支持微信小程序平台，并计划将我之前开发的人工智能微信小程序 识狗君 使用tensorflow js改写。这个端午节，趁着放假，空余时间比较多，开始研究微信小程序中如何使用tensorflow.js。在写下上一篇推送后，我简单尝试过在微信小程序中使用tensorflow.js，发现直接使用还是存在一点问题，所以本次的目标是走通简单的流程：加载预训练模型mobilenet，可以用来识别图片所属分类。示例代码位于: https://github.com/mogoweb/aidog请切换到tfjs分支。运行起来，效果是这样的：嗯，示例是简单了一点，但所有使用tensorflow js的关键步骤都包括。下面就简要描述一下我所遇到的坑及解决之道：loadLayersModel无法加载模型使用tfjs定义模型，训练模型并进行预测都没问题，但是使用 loadLayersModel 加载预训练模型，却出现如下错误：Uncaught (in promise) Error: Unable to find the fetch() method. Please add your own fetch() function to the global namespace.为什么会出现这个问题呢，原来tfjs-core为了可移植性，平台相关的操作，由各平台自行实现。从网络上获取数据就是这样的平台相关操作，浏览器、Node各有自己的实现方法。浏览器的实现依赖于fetch API，而微信小程序上，非常遗憾的看到了一条更新日志：微信小程序中，网络请求可以通过 wx.request 实现，问题是如何实现全局的fetch函数呢？这可难倒了我。在网上搜索的时候，发现了一个项目：https://github.com/HunterXuan/wx-tfjs-core.git\r\n原来这哥们早就研究过将tfjs移植倒微信小程序平台，写了几篇博客，值得看一看。参考了他的修改，我也完成了tfjs-core的改造，参考我在GitHub上建的项目:https://github.com/mogoweb/wechat-tfjs-core.git\r\n我的修改有点不同，新定义了PlatformMP，主要是考虑到微信小程序和普通浏览器还有一些差异，以后存在差异的代码都放到PlatformMP里面实现。是不是还有更好的方法，比如不需要修改tfjs的代码，在微信小程序里面实现全局fetch函数？我不太确定，希望前端高手指点。预训练模型被墙由于一些众所周知的原因，访问Google的服务总是不顺畅。我长期挂VPN，这倒不是问题。关键是，如果在微信小程序中访问Google，这就有些麻烦，不可能期望用户能够个个玩转VPN。幸运的是，tfjs上有一个issue： Model accessibility issues in China #1375 。里面给出了临时解决方案，我们可以通过镜像：https://cnpmjs.org/mirrors/tfjs-models/ 获取模型。这个镜像能够存在多久还是个未知数，可能最靠谱的还是将模型同步下来，自己存储。这种方式还没有来得及研究，有时间再看看。获取图像数据在tfjs-examples中，是通过： tf.browser.fromPixels 接口获取图像数据，但在微信小程序中却行不通，因为微信小程序平台中移除掉了document对象。好在以前在开发 识狗君 微信小程序识研究过通过wx canvas获取图像数据，具体实现请参考源码。有一点需要注意，通过canvas获取到的图像数据是RGBA格式，而mobilenet模型接收的却是RGB，为此我写了一个转换函数：// RGBA to RGB\r\nvar rgbData = new Uint8Array(res.width * res.height * 3);\r\nlet idx = 0;\r\nfor (let i = 0; i < res.data.length; i +=4) {\r\n  rgbData[idx] = res.data[i];\r\n  rgbData[idx + 1] = res.data[i + 1];\r\n  rgbData[idx + 2] = res.data[i + 2];\r\n  idx += 3;\r\n}感觉这个函数实现得效率有些低，是否有更好的方法，还请高手指教。async / await作为一名浏览器内核开发人员，平常也接触一些js代码，但前端发展实在太迅猛了，好些新式的js代码已经完全看不懂。比如在 tfjs-examples 代码中，就有许多async / await等用法，模块导出也有好几种方式，Promise又是什么鬼？搞的我头晕脑胀，多亏了知识搜索能力还不错，遇到问题就Google，每次都能逢凶化吉。要在微信小程序中使用async / await，需要打开项目配置的增强编译开关：待完善问题模型每次都需要从网络加载，需要研究如何利用微信小程序的storage，这样模型可以缓存到本地，避免每次从网络加载。由于微信小程序包有大小限制，所以将模型打包到小程序不可能。将自己的模型转化为tfjs模型，并在微信小程序中使用。不修改tfjs-core，将平台相关代码放到微信小程序中实现。你还可以看：当微信小程序遇上TensorFlow：Server端实现当微信小程序遇上TensorFlow：Server端实现补充当微信小程序遇上TensorFlow：小程序实现当微信小程序遇上TensorFlow：接收base64编码图像数据当微信小程序遇上TensorFlow：终章识狗君微信小程序的部署"}
{"title": "细数百度小程序踩的坑 ", "author": "2019-6-11 00:32", "pub_time": "2019-6-11 00:32", "content": "最近接触百度小程序挺多，开发了几个产品，都快被百度的小程序折磨死。真的是不想吐槽了，接下来我就讲讲我遇到的坑与一些经验。1. s-for这个for循环的写法为 s-for='arr' 或者 s-for = 'item,index in arr' 。这些到没什么，主要是s-for不能循环常数。。。这让我从微信小程序转到百度小程序不太习惯。。。官方回应说什么底层diff差异哦，后面会修复。不知道现在修复好没。2. 自定义组件之命名与路径引用组件的时候，在json文件中，usingComponents 选项里填入要引入的组件并自定义名称：\"my-radio\":\"/components/bd-radio/bd-radio\"。需要注意的是：这个组件的名称不支持驼峰和大写写法。路径支持绝对路径和相对路径。3. 自定义组件之组件通讯子组件 this.triggerEvent('getchange', idx); 触发事件，getchange是父组件需要接收的事件名，第二个参数是需要传回去的数据，最好是object，其它的参数，在2.0.3之前不支持。父组件 <my-radio bindgetchange='getSex'></my-radio> bindgetchange bind后面的就是子组件传过来的事件名，再后面一个(getSex)就是父组件中定义的函数，接收的时候e.detail，就是自组件传过来的数据4. 获取索引值如果要获取s-for中当前点击元素的索引值，只有在元素上添加 data-idx='{{index}}' 自定义属性，然后点击事件里面，通过：e.currentTarget.dataset.idx 获取。5. swan.request百度小程序的 swan.request 只支持 https协议。如果你不小心接口弄成了HTTP协议的url，在开发者工具上完全没问题，但是真机调试的话，如果你运气好，就没问题，运气不好在某些手机上就会出现接口无反应的情况，并且swan.request 的fail打印出： illegal request 非法请求。但是又没报错。所以，这个情况的提示也是不明显的，谁知道那个非法请求是接口还是url地址的错啊。还有就是百度好像并没有对这个接口中的url进行encodeURIComponent，所以如果有中文，那自己需要进行编码一次。6. swan.setStorageSyncswan.setStorageSync 这个同步的存储数据接口，官方文档说：参数支持String key, Object/String data。我第一次使用这个接口的时候，没注意看参数，结果传了一个布尔值进去，但是使用swan.getStorageSync获取的时候，始终获取不了，结果发现数据最外层包了一个data属性。即正常是xxx:true，实际上取出来是 data:{xxx:true} 也是醉了。。。不支持的至少给个错误提示啊。。。7. rich-text使用rich-text富文本组件的时候<rich-text node=\"{{a.b}}\"></rich-text>\r\n//如果a是后台取的，在js的data中初始化的时候，如果a设置为null，有可能会报错，导致页面复制相同的内容，即出现两个相同的内容连在一起。所以最好设置为 {} 空对象。而且如果遇到识别不了的标签会停止渲染，并且不会有错误提示。。。我遇到过几次出现两个相同的内容连在一起的情况，忘了截图的，具体怎样出现的也忘了。。。8. image 组件出现 image load faild如果遇到某些时候图片路径是正确的，但是出现 image load faild 这个错误，我也不知道怎么解决。官方回答说不影响开发就行。。。特别是从一个页面navgitor或者其它的跳转方式跳转到另外的页面，就有可能会出现这种情况。而且图片还是本地的。。。官方回复说：image图片地址只支持https协议，并且在小程序后台进行域名配置，或者百度域名的图片，不满足条件的话，图片将无法正常显示。不过有时候还是会出现上面的问题。9. H5支付 转到 百度支付 swan.requestPolymerPayment关于百度小程序支付：最开始我天真的以为，web-view嵌套一个已经完善的H5商城，支付的时候也可以直接使用自己对接的H5的支付。因为在本地预览时，不管安卓还是IOS，都可以支付成功，没问题。但是只要一发布上线，支付的时候就调不起微信或者支付宝的支付弹窗了。都不能跳转到支付弹窗的页面。安卓机全部不得行，IOS没问题。抓包发现结果返回正常，没有错误。我估计是百度官方屏蔽了。官方给出的回答是：为保护用户的资金安全，小程序的web-view不支持自行调用第三方支付服务。如有支付需求，建议接入百度收银台。。。但是，但是，但是。。。我看到苏宁易购的百度小程序就是使用的自己对接的第三方支付，并没有使用百度的支付接口。。。我就很奇怪了，为撒子苏宁易购就可以？？？10. web-view的src也可以使用localhostweb-view的src也可以弄成IP地址的情况。比如我本地使用vue-cli运行了一个项目，假设为http://localhost:8087/szxgcs/detail.html。这时我把localhost改成自己的IP地址，然后在web-view的src中：<web-view src='http://192.168.xxx.xxx:8087/szxgcs/detail.html'></web-view>\r\n//这样就能运行在本地的代码了 11. 使用未申明的变量，有可能会没错误提示有时候在某些接口中，或者request的data中，使用that.data.xxx的时候，由于我粗心，that没有声明。所以在运行的时候，发现调接口没反应。但是又没有提示哪里有错，就很懵逼。所以一定要检查某些变量是否声明的。不过现在好像改好了，不声明会报错了。12. swan.setPageInfo接入百度信息流接入百度信息流的申请，就是在页面配置swan.setPageInfo，如果小程序首页是web-view嵌套的页面，不是百度小程序原生开发的页面。那么就会申请不了。现在默认都是接入了百度信息流的，所以如果没配置，会出现让你配置的警告信息。建议代码写成swan.setPageInfo && swan.setPageInfo({配置内容}) ，如果不这样写，按照官方的写法，在真机调试中，会报错。13. 发布审核时设置基础库版本高一点。建议发布审核的时候，把开发者平台 --- 设置 --- 基本设置 --- 基础库最低版本设置 设置高一点。低版本出现了问题，如果是百度的问题，官方是不会给你修复的，这是官方技术人员回复我的原话。一般设置3.xxx以上就可以了，3.xxx以前的没多少用户了。这样也可以避免审核的时候测试人员在低版本测试，出现不清楚原因的bug。14. s-if不能和s-for一起用。有可能出现不可预知的错误。还有就是 s-if 一定要写在最前面，不然有可能也会出现一些小问题。。。.假如需要给组件传递内容，这个内容是异步获取的，那么在组件里，获取的时候，有可能会遇到获取不到传过来的内容，这个很正常。在H5的vue中，我使用v-if来避免获取不了的情况。类似：</ child :sendval='data' v-if='data' >\r\n//data初始化为false，这样，只有在data真实获取到内容的时候，才渲染组件。\r\n//但是，在百度小程序中，判断条件必须写在前面即：\r\n<child  s-if='data' :sendval='data' ></child>\r\n//不然，还是会出现获取不了内容的情况 15. swan.createSelectorQuery() 有时需要延时获取宽高等信息。swan.createSelectorQuery()这个获取dom元素的接口，如果获取的dom元素是动态添加的，那么，在调用boundingClientRect获取宽高等信息的时候，是需要延时获取的。这个在组件中更明显，就算组件加了s-if，在数据成功返回之后再渲染组件，但是渲染的过程也需要耗时，所以，不能及时地获取到元素的信息。就算使用swan.nextTick()也没作用，有时候也会获取不到。我设置setTimeout延时一般是150ms16. swan.nextTick()swan.nextTick()就是提供一个异步操作。从来就没用过，官方的描述也是云里雾里的。感觉和vue的nextTick不太一样。因为我试过相同情况下相同的代码，两个的表现不一样。17. 慎用sConsoleweb-view中的h5页面跳转到小程序会打开两次。这个情况是打开了SConsole调试面板的，关闭之后就不会出现这个情况。其它情况使用sConsole也有可能会出现某些小问题。。。18. getSwanIdgetSwanId在开发者工具上，返回的是SWAN-DEVELOP，而真机上是一段长度为几十个的字母和数字组成的字符串。19. css单位css单位基本都支持，不过如果是rpx这种，小程序会自动转换成vw或者vh，所以你会看到控制台里的单位都是vw或者vh20. getStoragegetStorage获取本地不存在的数据，默认进入success，不会进入fail回调21. 分享到贴吧这个功能，官方有说明： 这里是接入文档       这里是简单说明。在代码中配置好，并且上线小程序后，我以为这样就能申请分享白名单了。。。然而，按钮竟然没给我激活，点不动。。。搞不清楚原因。。。然后就放弃了 上面这些是真实遇到的情况，真的累，本来只花一天的时间搞得定的内容，一路踩坑结果多花了两三倍的时间。。。逐渐怀疑我是不是做程序员的料。。。后面还会继续开发百度小程序，估计又会折寿了。。。"}
{"title": "我写小程序像菜虚鲲—— 唱，跳，rap，篮球 ", "author": "2019-6-11 00:38", "pub_time": "2019-6-11 00:38", "content": "引言大家好，我是练习时长两年半的个人练习生菜虚鲲，我喜欢唱，跳，rap，篮球，Music！为了避免律师含，就不po鲲鲲的原图咯~在小作坊待久了，都忘记自己的本职工作当初进来是一枚Android开发了，写写下APP和py脚本，偶尔帮人修修电脑。感觉如果自己大只点，可能饮水机的水都要我来换了…因为一些原因，旧APP不再更新迭代了，新的APP没开始做，不想赔钱把我开掉，就把我晾着摸鱼。而我自己比较腊鸡，感觉出去会找不到好的工作（不想再去小作坊，一个人玩好累，感觉再这样下去，会废掉…）晾着摸鱼不做事，工资照发，管理肯定不愿意啊，要给我找点事做做咯：要不你学下前端吧，做下小程序，后面做APP了，你再回去做APP…我TM，说得好像学东西不用学习成本一样，特别是跨域，最怕最后四不像，啥也什么都学得半桶水，如果真转的话，我更想转后端，毕竟前端技术更新换代速度实在是太快了，是真的快，学不来学不来。唉，自己又不是大神，人在屋檐下，不得不低头，安慰自己：小程序外包的单子挺多的，毕竟开发一个小程序的成本比APP少太多，很多甲方爸爸动不动就要做一个小程序，学了小程序，以后可以接点外包苟活下…自己摸索着玩了一个多星期，有点意思：老规矩，记录下自己的学习过程，方便自己日后回顾，也方便后来者。看过网上很多《从零开始学习微信小程序开发》类型的教程，大都废话太多，或者不是真的零基础入门，学着学着者突然来些高深玩意，看得我头皮发麻读者一脸懵逼，笔者深知自学循序渐进的重要性。另外，之前群里有小火汁问我学东西为啥那么快，其实，我学东西还真不快，主要有几点：顺带分享下自己的学习姿势吧~① 兴趣驱动 ：「 你想学 」而非「 要你学 」，主动去探索而非被动接受。② 专注 ：心无旁骛，别一下折腾这个，一下子又折腾那个，三分钟热度。③ 反思总结 ：及时总结归纳，形成自己的知识脉络，同时反思学习过程中的一些问题。④ 去实践 ：你掌握多少知识，取决于你能调用多少，而非记忆了多少知识。⑤ 度 ：把握一个度，知道自己要学习到什么程度，不要去钻牛角尖，等等。大概就这些，笔者是前端小白，并不会深刨，只是希望初学者学完这个系列可以撸出一个简单基本的小程序。现学现卖，难免有错，还望海涵，欢迎前端大神指出。如无意外，一周1-2更。不要有太多期待，因为还在准备Android面试相关。废话就那么多，开始本系列教程。Tips：个人觉得学习小程序最佳的学习方式就是肝官方文档~微信小程序官网： developers.weixin.qq.com/miniprogram…0x1、你看这个面又长又宽（开发环境搭建）官网点击：「 指南 」-> 「 开始 」1、申请账号账号可以申请也可以不申请不是一定要申请账号，如果你只是想 自己瞎玩不发布 的话，可以跳过这一步。当然，你也可以申请，申请后会给你的小程序分配一个「 AppID 」，类似于身份标识。可以在小程序后台，依次点击「 设置 」->「 开发设置 」获取到这个「 AppID 」：2、下载安装微信开发者工具官网依次点击「 工具 」-> 「 下载 」，或者直接打开下述链接跳转下载：developers.weixin.qq.com/miniprogram…用哪个版本看个人喜欢，笔者用的是 开发版 ，你也可以使用稳定版，下载完以后，无脑下一步安装即可。安装完后，其实就可以直接进行小程序开发，只是微信开发者工具自带的IDE比较简陋，没有自带api智能提醒和语法高亮等，写起代码来不是很顺手，所以一般只是拿微信开发者工具来「 看下运行效果 」和「 调试 」，写代码的话用的看看 运行效果，调试 ，二用第三方的IDE来编写代码，常见的两款组合：VS Code + minapp插件Sublime Text 3 + Sublime wxapp插件笔者使用的是前者，接着说下VS Code的下载安装。3、下载安装VS Code并安装minapp插件VS Code直接在官网下载就好： code.visualstudio.com/ ，默认英文。如果你想使用中文可以按快捷键：Windows 或 Linux => Ctrl + Shift + PMac => Command + Shift + P然后在弹出的对话框中输入：「 Configure Language 」，如图：接着点击「 Install additional languages… 」，如图：点击后左侧会出现一个插件安装的，选择中文，如图：安装完，提示重启，重启后就是中文了，接着安装一波minapp插件。点击左侧边栏的第四个图标，然后搜索栏键入「 minapp 」，然后点击Install进行安装，如图：。安装后可能需要重启，重启即可。除此之外，还安利一个插件：「 wechat-snippet 」，自动生成微信代码片段，如果想了解更多插件可见VS官网： marketplace.visualstudio.com/0x2、就像这个碗又大又圆（创建项目）直接打开微信开发者工具，可以「 新建项目 」或者「 导入项目 」，填写项目相关的信息，这里如果你没有申请账号的话可以用随机生成的AppID，如图所示：0x3、你们来这里吃饭（界面熟悉）创建后会自动生成相关代码，创建后的页面如图所示：简单介绍下，圈住的页面内容如下：简单说下页面中圈住的部分都是些什么：① 菜单栏 ：提供项目，文件，编辑等相关操作，自己点开看就知道了。② 视图开关 ：控制模拟器，编辑器和调试器视图的显示和隐藏。③ 模拟器 ：模拟小程序在手机上的界面效果，上面的栏可以进行模拟器的相关配置： 模拟器分辨率、缩放比例、连接网络方式、模拟操作、是否静音、独立成小窗口。④ 编辑器-项目文件目录 ：小程序文件目录，顶部菜单依次为：添加文件、搜索文件、 从硬盘打开、折叠某个目录，隐藏。⑤ 编辑器-文件内容编辑 ：就是编写代码的地方。⑥ 调试器 ：定制版的Chrome开发者工具，用于调试：页面结构，CSS，抓包，AppData等。⑧ 编译相关 ：可以选择编译选项：普通编译，添加编译模式(直接打开特定页面)或通过二维码编译，点击编译即可进行编译。点击预览可以生成二维码，然后在手机上查看效果。⑨ 真机调试 ：同样是生成二维码扫描看效果，不过多了调试功能。⑩ 切后台 ：切换场景值。⑪ 清缓存 ：就是清理缓存，可以清理：数据，文件，授权，网络，登录状态。⑫ 版本管理 ：小程序项目Git版本管理。⑬ 详情 ：项目的相关信息，项目配置，以及域名信息配置。⑭ 页面路径 ：当前页面的路径，场景值和页面参数。关于微信开发者工具的界面的简单介绍就到这里，接着我们来说下小程序的基本结构。0x4、觉得饭很好吃（基本结构）1、四类文件小程序一般由下面四类文件组成：json ： 配置文件 ，页面和开发工具的相关配置。wxml ： 模板文件 ，堆砌控件形成小程序页面，有点像HTML。wxss ： 样式文件 ，调整页面样式，有点像CSS。js ： 脚本逻辑文件 ，完成一些逻辑处理操作，比如发起请求，事件触发等。简单点说： wxml里写页面，wxss里写样式，js里写逻辑，json里改配置。2、三个重要的配置文件① 开发工具配置 ：「 project.config.json 」开发者工具的统一配置，界面设置以及云函数相关，更多可见：developers.weixin.qq.com/miniprogram…② 小程序全局配置 ：「 app.json 」比如：页面路径列表，默认窗口，底部tab栏，网络超时等，更多可见：developers.weixin.qq.com/miniprogram…③ 单页面配置 ：「 page.json 」使用「 同名.json 」文件来对本页面的窗口表现进行配置，会覆盖app.json的window中相同的配置项，更多可见：developers.weixin.qq.com/miniprogram…0x5、就像我给你们拉面一样很开心（小程序初体验）接着，通过编写一个简陋的页面，来体验下小程序的开发~1、全局窗口配置先来配置一波小程序的窗口，要求如下：蕾姆蓝背景，白色文字，菜单栏显示抠腚男孩打开 app.json 文件，添加下述配置：\"navigationBarBackgroundColor\": \"#5A78EA\",\r\n\"navigationBarTitleText\": \"抠腚男孩\",\r\n\"navigationBarTextStyle\": \"white\"\r\n复制代码编译运行后，效果如图所示：2、编写简陋页面接着开始着手编写这个简陋页面，定义一个顶部头像，新建 asserts 文件夹，用来存放 静态资源文件 ，接着往 index.wxml 中添加一个image控件：<image src=\"../../assets/codingboy.png\" />\r\n复制代码编译运行后，效果如图所示：3、调整样式可以，很骚气，但是作为头像有点太大了，调整一下它的样式，打开 index.wxss ，添加一个类选择器：.user-icon-image{\r\n    width: 150rpx;\r\n    height: 150rpx;\r\n}\r\n复制代码image标签设置一下这个选择器：<image class=\"user-icon-image\" src=\"../../assets/codingboy.png\"/>\r\n复制代码编译运行后，效果如图所示：Tips：这里还可以利用 宽高自适应 的，即：设置宽度，保持原图宽高比不变，高度自动变化。为image标签设置属性：mode=\"widthFix\"，效果是一样的。4、获取用户授权这里有个需求：如果已经获取了用户授权，就显示微信头像，否则显示这个默认头像在 index.wxml 中添加一个用于获取用户昵称和头像的按钮：<button open-type=\"getUserInfo\">获取头像昵称</button>\r\n复制代码编译运行后，点击按钮会弹出一个授权对话框：点击允许即可完成授权，但是授权的信息并没有保存起来。5、获取授权信息授权是授权了，但是信息却没有拿到，button有一个属性： bindgetuserinfo ，当用户点击按钮时，会返回获取到的用户信息，我们在这里绑定一个保存用户信息的回调函数，在 index.js 中添加下述代码直接把授权信息给打印出来：getUserInfo: function (e) {\r\n    app.globalData.userInfo = e.detail.userInfo\r\n    console.log(app.globalData.userInfo)\r\n}\r\n复制代码接着 index.wxml 中绑定一下：<button open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\">获取头像昵称</button>\r\n复制代码清一波缓存，然后重新编译，点击获取头像昵称的按钮，对话框授权，在Console可以看到用户的相关信息：6、保存授权信息授权信息可以获取到了，接下来我们通过定义一个变量的方式把信息保存下来，另外，我们还需要定义一个变量作为是否获得授权信息的标记，用于控制显示微信头像还是默认头像，打开 index.js 添加下述代码：Page({\r\n    data: {\r\n        userInfo: {}, //用户信息\r\n        hasUserInfo: false, //是否有用户信息\r\n    }\r\n})\r\n复制代码修改下getUserInfo函数，修改后的代码如下：getUserInfo: function (e) {\r\n    app.globalData.userInfo = e.detail.userInfo\r\n    this.setData({\r\n        userInfo: e.detail.userInfo,\r\n        hasUserInfo: true\r\n    })\r\n}\r\n复制代码另外授权信息，其实可以通过 app.globalData.userInfo 获取，在程序初始化的时候在onLoad函数中去获取下，添加一个 onLoad 函数，代码如下：onLoad: function () { \r\n    if (app.globalData.userInfo) {\r\n        this.setData({\r\n            userInfo: app.globalData.userInfo,\r\n            hasUserInfo: true\r\n         })\r\n    }\r\n}\r\n复制代码7、wx:if，wx:elif，wx:else判断结构接着在 index.wxml 中通过 wx:if 判断是加载默认图还是微信头像，代码如下：<block wx:if=\"{{!hasUserInfo}}\">\r\n    <image class=\"user-icon-image\" src=\"../../assets/codingboy.png\" mode=\"widthFix\" />\r\n    <button open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\">获取头像昵称</button>\r\n</block>\r\n<block wx:else>\r\n    <image class=\"user-icon-image\" src=\"{{userInfo.avatarUrl}}\" mode=\"widthFix\" />\r\n    <text>{{userInfo.nickName}}</text>\r\n</block>\r\n复制代码运行后可以看到显示的是微信用户昵称和头像，如图：接着调整一下样式，外层包一个view，接着让这两个东西居中：.user-icon-wrapper{\r\n  display:flex;                 \r\n  justify-content: center; \r\n  flex-direction: column;\r\n  align-items: center\r\n} \r\n复制代码有点挤，顶部加padding，图片圆角，调整背景颜色， index.wxss 添加：page {\r\n  background: #f6f6f6;\r\n  position: relative;\r\n  padding-top: 30rpx;\r\n  color: #323233;\r\n}\r\n\r\n.user-icon-wrapper{\r\n  display:flex;                 \r\n  justify-content: center; \r\n  flex-direction: column;\r\n  align-items: center\r\n} \r\n\r\n.user-icon-image{ \r\n  width: 150rpx;\r\n  border-radius: 20rpx;\r\n}\r\n\r\n.authorize-button{\r\n  margin-top: 30rpx;\r\n}\r\n\r\n.nickname-text{\r\n  margin-top: 30rpx;\r\n}\r\n复制代码接着修改下 index.wxml ，代码如下：<!-- index.wxml -->\r\n<block wx:if=\"{{!hasUserInfo && canIUse}}\">\r\n    <view class=\"user-icon-wrapper\">\r\n        <image class=\"user-icon-image\" src=\"../../assets/codingboy.png\" mode=\"widthFix\" />\r\n        <button class=\"authorize-button\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\">\r\n            获取头像昵称\r\n        </button>\r\n    </view>\r\n</block>\r\n<block wx:else>\r\n    <view class=\"user-icon-wrapper\">\r\n        <image class=\"user-icon-image\" src=\"{{userInfo.avatarUrl}}\" mode=\"widthFix\" />\r\n        <text class=\"nickname-text\">{{userInfo.nickName}}</text>\r\n    </view>\r\n</block>\r\n复制代码运行结果如下：8、单机版天气预报(wx:for循环结构)只是点击授权然后获取头像显示，感觉好low，跟官方的例子有啥区别，加个天气预报的东东吧，这里采用的天气接口是： 魅族天气API ，接口地址如下：aider.meizu.com/app/weather…访问看下，返回的数据如下：开发初期，为了提高开发的效率，会先造假数据，前后端约定好接口的返回数据。由后端写一个接口返回假数据，或者前端本地跑一个mock服务器，也可以直接写死在程序中。这里为了方便，直接写死，在 index.js 的page中添加下述数据：city: '深圳',\r\nprovince: '广东省',\r\nrealtime: {\r\n  img: \"1\",\r\n  sD: \"72\",\r\n  sendibleTemp: \"25\",\r\n  temp: \"25\",\r\n  time: \"2019-04-17 16:35:08\",\r\n  wD: \"西南风\",\r\n  wS: \"1级\",\r\n  weather: \"多云\",\r\n  ziwaixian: \"N/A\"\r\n},\r\nindexes: [{\r\n  abbreviation: \"uv\",\r\n  alias: \"\",\r\n  content: \"辐射较弱，涂擦SPF12-15、PA+护肤品。\",\r\n  level: \"弱\",\r\n  name: \"紫外线强度指数\"\r\n},\r\n{\r\n  abbreviation: \"pp\",\r\n  alias: \"\",\r\n  content: \"建议用露质面霜打底，水质无油粉底霜，透明粉饼，粉质胭脂。\",\r\n  level: \"控油\",\r\n  name: \"化妆指数\"\r\n},\r\n{\r\n  abbreviation: \"yd\",\r\n  alias: \"\",\r\n  content: \"天气较好，且紫外线辐射不强，适宜户外运动。\",\r\n  level: \"适宜\",\r\n  name: \"运动指数\"\r\n},\r\n{\r\n  abbreviation: \"xc\",\r\n  alias: \"\",\r\n  content: \"洗车后，只能保持1天车辆清洁，不太适宜洗车。\",\r\n  level: \"较不适宜\",\r\n  name: \"洗车指数\"\r\n},\r\n{\r\n  abbreviation: \"ct\",\r\n  alias: \"\",\r\n  content: \"天气较热，衣物精干简洁，室内酌情添加空调衫。\",\r\n  level: \"热\",\r\n  name: \"穿衣指数\"\r\n},\r\n{\r\n  abbreviation: \"gm\",\r\n  alias: \"\",\r\n  content: \"感冒较易发生，干净整洁的环境和清新流通的空气都有利于降低感冒的几率，体质较弱的童鞋们要特别加强自我保护。\",\r\n  level: \"较易发\",\r\n  name: \"感冒指数\"\r\n}],\r\n复制代码接着index.wxml添加控件：<button style=\"margin-top: 50rpx\">刷新天气</button>\r\n<view style=\"height: 100rpx;flex-direction:column;\">\r\n  <text>城市：{{city}}</text>\r\n  <text>省：{{province}}</text>\r\n  <text>天气：{{realtime.weather}}</text>\r\n  <text>温度：{{realtime.temp}}°C</text>\r\n  <text>湿度：{{realtime.sD}}</text>\r\n  <text>更新时间：{{realtime.time}}</text>\r\n  <text>风向：{{realtime.wD}}</text>\r\n  <text>风力：{{realtime.wS}}</text>\r\n</view>\r\n复制代码运行结果如下：文字都堆叠到一起了，设置下样式：.message-text {\r\n  margin-left: 15rpx;\r\n  display: block;\r\n  margin-top: 50rpx;\r\n}\r\n复制代码接着每个text设置下message-text这个类选择器，运行效果如下：接着把indexes里的数据也显示出来，通过 wx:for 循环生成结点：<block wx:for=\"{{indexes}}\" wx:for-item=\"item\" wx:key=\"key\">\r\n    <text>{{item.name}}：{{item.abbreviation}}</text>\r\n    <text>{{item.content}}</text>\r\n    <text>{{item.level}}</text>\r\n</block>\r\n复制代码运行后结果如下：文本都堆在一起密密麻麻的，写个样式：.indexes-text {\r\n  display: block;\r\n  margin-left: 15rpx;\r\n}\r\n\r\n.indexes-text-last{\r\n  display: block;\r\n  margin-left: 15rpx;\r\n  padding-bottom: 50rpx;\r\n}\r\n复制代码运行结果如下：9、网络版天气预报(wx.request发起请求)单机版的就完成了，接着通过 wx.requests 来请求接口，实现一个网络版的天气预报。index.js中新增刷新天气的函数：refreshWeather: function () {\r\n    var that = this\r\n    wx.request({\r\n      url: 'http://aider.meizu.com/app/weather/listWeather',\r\n      data: {\r\n        'cityIds': '101280601'\r\n      },\r\n      method: 'GET',\r\n      headers: {\r\n        'User-Agent:': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36',\r\n        'Host': 'aider.meizu.com'\r\n      },\r\n      success: function (res) {\r\n        if (res.data.code == 200) {\r\n          that.setData({\r\n            weather: res.data.value[0]\r\n          })\r\n        }\r\n      },\r\n    })\r\n  },\r\n复制代码接着按钮设置下点击时触发这个网络请求：<button style=\"margin-top: 50rpx\" bindtap=\"refreshWeather\">刷新天气</button>\r\n复制代码因为接口是http的，还需要微信开发者工具点开 详情 ，勾选下：接着点击运行，点击刷新天气，在Network选项卡可以看到发出的请求信息：然后咧，微信小程序的视图层和逻辑层类似MVVM模式，逻辑层只需对数据对象更新，即可改变视图层的数据数据显示，这里setData后，对应的控件也会改变。到此一个非常简单的天气预报小程序就完成了。小结本节介绍了微信小程序开发环境的搭建，开发一个简易天气小程序体验了一波微信小程序，相信读者对于微信小程序有个基本的了解了，接下来的章节会慢慢细化一些知识点，比如控件定位，UI相关，请求封装，开源开发框架WePY等等，敬请期待~如果本文对你有所帮助，欢迎留言，点赞，转发 素质三连，谢谢:kissing_heart:~"}
{"title": "小程序营销组件：红包雨、大转盘、九宫格翻牌…… ", "author": "2019-6-12 00:23", "pub_time": "2019-6-12 00:23", "content": "前言商城没几个营销活动能叫商城吗？这里你能找到的有：1.红包雨2.大转盘3.九宫格翻牌4...所以就来几个组件吧，写的不好轻踩，对你有帮助记得给个小星星哦直接上链接github链接运行例子git clone https://github.com/sunnie1992/soul-weapp.git\r\n复制代码微信开发者工具打开项目营销组件大转盘 \"pages/wheel/index\" 九宫格翻牌 \"pages/gridCard/index\" 红包雨 \"pages/packetRain/index\" 页面\"pages/filter/index\" 功能筛选筛选预览"}
{"title": "微信小程序前端实现自定义分享 ", "author": "2019-6-13 00:06", "pub_time": "2019-6-13 00:06", "content": "目前手上有一个小程序的项目，希望转发时分享消息的界面能够自定义,然而微信小程序只提供设置图片的url和title。/**\r\n     * 用户点击右上角分享\r\n     */\r\n    onShareAppMessage: function() {\r\n        return {\r\n          imageUrl:'',\r\n          title:''\r\n        };\r\n    }\r\n复制代码实现我们要转发的显示内容多了一点东西: 头像 ， 用户名 和 点赞数。好在这个排版不是很复杂，所以我们思考了一下通过canvas去生成一张图片再return canvas所生成的图片url。代码如下（其实还要作出一些显示上的优化，具体你们自己去调试）： 先在页面里新建一个canvas 标签<canvas canvas-id=\"canvasid\" style=\"width: 375px; height: 500px;\" wx:if=\"{{canvasShow}}\"></canvas>\r\n复制代码let context = wx.createCanvasContext('canvasid')\r\n     context.drawImage(back.path, 0, 60, backWidth, backHeight) //绘制下方背景图\r\n     //绘制圆形头像，参考教程：https://www.jianshu.com/p/9a6ee2648d6f 第二种方法\r\n\r\n      context.save();\r\n      var d = 2 * 25;\r\n      var cx = 0 + 25;\r\n      var cy = 0 + 25;\r\n      context.arc(cx, cy,25, 0, 2 * Math.PI);\r\n      context.clip();\r\n      context.drawImage(avatar.path, 0,0, d, d);\r\n      context.restore();\r\n      //绘制名字和点赞数\r\n      context.setFontSize(14)\r\n      context.fillText('userName', 70, 32)\r\n      let zanLength = ('100' + '次赞').length\r\n      context.fillText('100'+ '次赞', 375 - 14 * zanLength, 32)\r\n      //执行draw进行渲染 并返回图片url\r\n      context.draw(true, () => {\r\n        //此方法应执行在draw的回调中\r\n        wx.canvasToTempFilePath({\r\n          x: 0,\r\n          y: 0,\r\n          width: 375,\r\n          height: 400,\r\n          destWidth: 375,\r\n          destHeight: 400,\r\n          canvasId: 'canvasid',\r\n          success(res) {\r\n        //设置onShareAppMessage所返回的数据格式\r\n           let shareInfo = {\r\n              title: 'customTitle',\r\n              imageUrl\r\n            }\r\n           //隐藏画布\r\n            that.setData({\r\n              canvasShow: false\r\n            })\r\n          }\r\n        })\r\n      });\r\n复制代码然而！ 在canvas中绘制的图片要在真机上显示出来是有问题的（画布污染），非同源的图片在canvas不会显示出来的。后来我们使用 wx.getImageInfo 去获取图片信息，通过里面的地址去显示图片(相当于是把图片转了一道)。wx.getImageInfo({\r\n                src: imgUrl,\r\n                success: function(res) {\r\n                     /**拿到返回值res[0].path,再把该值作为canvas绘制图片的路径 \r\n                        context.drawImage(res[0].path,x,x,x)**/\r\n                    let drawImgUrl =  res[0].path\r\n                }\r\n            }); \r\n复制代码emmmm....文章很短暂，这里只是提供一下解决的思路，希望能帮助到大家~"}
{"title": "express启用https小记 ", "author": "2019-5-21 00:31", "pub_time": "2019-5-21 00:31", "content": "前言遇到了一个需求，想要扫码后，进入微信小程序的某一个页面，这就要求二维码携带参数。微信小程序开发文档很简单，但不太具体。经百度和折腾，在express中成功获得了带参数的二维码。总结以下几步，供参考。1.express项目中引入http请求工具为什么要在服务端引入这个工具？因为还需要用这个工具去找微信服务端拿access_token接口凭证，来保证安全。笔者用的是axios。cmd进入根目录，npm安装。# npm i axios --save肯定需要写一个获得二维码的接口。在写这个接口的文件中引入axios即可，接口路由的写法不具体展开介绍。import express from 'express';\r\nimport axios from 'axios'; //引入axios库\r\nlet qrcode= express.Router();\r\nqrcode.post('/getQrode',async (req,res)=>{\r\n    try {\r\n        ...\r\n        //待写接口内容区域\r\n    } catch (error) {\r\n        throw error;\r\n    }\r\n})\r\nexport default qrcode;复制代码引入了库，定义了路由，也定义了一个post接口。第一步准备完毕。2.获取access_token找微信服务端拿access_token，需要用上刚刚引入的axios工具了。通过官方文档介绍，获取access_token需要三个参数，一个常量grant_type，两个变量分别是appid和secret（注册小程序的时候就会获得）修改接口即可获得access_tokenimport express from 'express';\r\nimport axios from 'axios';\r\nlet qrcode= express.Router();\r\nqrcode.post('/share',async (req,res)=>{\r\n    try {\r\n        let appid = 'wxc********b7a';\r\n        let secret = '2bfa**************e8682';\r\n        let url = `https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=${appid}&secret=${secret}`\r\n        axios.get(url).then(res2=>{\r\n            //access_token就在res2中\r\n            let access_token = res2.data.access_token;\r\n            //待继续补充区域\r\n        });\r\n    } catch (error) {\r\n        console.log(error)\r\n    }\r\n})\r\nexport default qrcode;复制代码拿到了access_token接口凭证了，继续下一步。3.获取二维码的二进制数据阅读文档，得知需要进一步传参，请求微信服务端获取二维码的buffer数据。需要携带的参数可以写在scene中。其他参数文档中介绍的已经很具体。然而，这里有两个坑要注意！第一个坑：access_token参数要写在url中，不然请求后会报未传access_token的错。第二个坑：要设置响应格式，否则请求回来的buffer数据总是被编译成String字符串，造成文件损坏，就无法转化为正常图片（这个折磨了我好久）import express from 'express';\r\nimport axios from 'axios';\r\nlet qrcode = express.Router();\r\nqrcode.post('/share',async (req,res)=>{\r\n    try {\r\n        let appid = 'wxc********b7a';\r\n        let secret = '2bfa**************e8682';\r\n        let url = `https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=${appid}&secret=${secret}`\r\n        axios.get(url).then(res2=>{\r\n            let scene = req.body._id;//开发者自己自定义的参数\r\n            axios(\r\n                {\r\n                    headers:{\"Content-type\":\"application/json\"},\r\n                    method: 'post',\r\n                    responseType: 'arraybuffer',\r\n                    url: 'https://api.weixin.qq.com/wxa/getwxacodeunlimit?access_token='+access_token+'',\r\n                    data:{\r\n                        scene:scene,\r\n                        page:'pages/infor/main',\r\n                        width: 280\r\n                    }\r\n                }\r\n            ).then(res3=>{\r\n                //请求到的二维码buffer就在res3中\r\n                //待完善区域\r\n            })\r\n        });\r\n    } catch (error) {\r\n        console.log(error)\r\n    }\r\n})\r\nexport default qrcode;复制代码第二次axios请求，用option配置的方式，设置了responseType，避开了第二个坑。二维码的buffer数据就在res3中。4.用buffer生成图片只要buffer数据是完整的，就能正确生成二维码。因为需要生成图片，所以需要引用fs模块和path模块。import express from 'express';\r\nimport axios from 'axios';\r\nimport path from 'path';\r\nimport fs from 'fs';\r\nlet qrcode= express.Router();\r\nqrcode.post('/share',async (req,res)=>{\r\n    try {\r\n        let appid = 'wxc********b7a';\r\n        let secret = '2bfa**************e8682';\r\n        let url = `https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=${appid}&secret=${secret}`;\r\n        axios.get(url).then(res2=>{\r\n            let access_token = res2.data.access_token;\r\n            let scene = req.body._id;\r\n            axios(\r\n                {\r\n                    headers:{\"Content-type\":\"application/json\"},\r\n                    method: 'post',\r\n                    responseType: 'arraybuffer',\r\n                    url: 'https://api.weixin.qq.com/wxa/getwxacodeunlimit?access_token='+access_token+'',\r\n                    data:{\r\n                        scene:scene,\r\n                        page:'pages/infor/main',\r\n                        width: 280\r\n                    }\r\n                }\r\n            ).then(res3=>{\r\n                let src = path.dirname(__dirname).replace(/\\\\/g,'/')+`/public/photo/${req.body._id}.png`;\r\n                fs.writeFile(src, res3.data, function(err) {\r\n                    if(err) {console.log(err);}\r\n                    res.json({msg:ok});\r\n                });\r\n            })\r\n        });\r\n    } catch (error) {\r\n        console.log(error);\r\n        res.json({error})\r\n    }\r\n})\r\n\r\nexport default qrcode;复制代码就会在根目录下的public/photo文件夹中生成制定名称的二维码图片。供小程序访问调用。后记获取二维码后，可以在前端利用canvas进行图片绘制，也可以在后端生成图片。可根据业务需求自行选择。希望对有需要的朋友能够有帮助。"}
{"title": "小程序系列--如何使用分包加载 ", "author": "2019-5-22 00:20", "pub_time": "2019-5-22 00:20", "content": "在小程序开发的过程中，小程序的体积会随着版本的迭代变的越来越大，这时候我们就希望能够将小程序分成多个包从服务器下载，这样既可以加快首屏的渲染也便于后续按需加载的实现。小程序在 微信客户端 6.6.0，基础库  1.7.3  及以上版本开始支持 分包功能。在构建小程序分包项目时，构建会输出一个或多个分包。每个使用分包小程序必定含有一个 主包 。所谓的主包，即放置默认启动页面/TabBar 页面，以及一些所有分包都需用到公共资源/JS 脚本；而 分包 则是根据开发者的配置进行划分。在小程序启动时，默认会下载主包并启动主包内页面，当用户进入分包内某个页面时，客户端会把对应分包下载下来，下载完成后再进行展示。配置方法配置例子{\r\n  \"pages\": [\"pages/index\", \"pages/shopcart\"],\r\n  \"subpackages\": [\r\n    {\r\n      \"root\": \"packageA\",\r\n      \"pages\": [\"pages/mine\", \"pages/order\"]\r\n    },\r\n    {\r\n      \"root\": \"packageB\",\r\n      \"name\": \"pack2\",\r\n      \"pages\": [\"pages/detail\", \"pages/pay\"]\r\n    }\r\n  ]\r\n}├── app.js\r\n├── app.json\r\n├── app.wxss\r\n├── packageA\r\n│   └── pages\r\n│       ├── mine\r\n│       └── order\r\n├── packageB\r\n│   └── pages\r\n│       ├── pay\r\n│       └── detail\r\n├── pages\r\n│   ├── index\r\n│   └── shopcart\r\n└── utils打包原则声明  subpackages  后，将按  subpackages  配置路径进行打包， subpackages  配置路径外的目录将被打包到 app（主包） 中app（主包）也可以有自己的 pages（即最外层的 pages 字段）subpackage  的根目录不能是另外一个  subpackage  内的子目录tabBar  页面必须在 app（主包）内引用原则packageA  无法 require  packageB  JS 文件，但可以 require  app 、自己 package 内的 JS 文件packageA  无法 import  packageB  的 template，但可以 require  app 、自己 package 内的 templatepackageA  无法使用  packageB  的资源，但可以使用  app 、自己 package 内的资源"}
{"title": "小程序开发经验：多页面数据同步 ", "author": "2019-5-22 00:35", "pub_time": "2019-5-22 00:35", "content": "在很多的产品中，都会存在跨页面间需要数据同步，如下示例：\r\n\r\n为了更好的理解该场景，我们再详细描绘一下：\r\n\r\n本场景包括4个页面：动态广场、个人中心、我的动态、动态详情\r\n首先，进入动态广场页，请求加载数据，展示动态列表，其中，我们用绿色内阴影区分该条动态是“我的”，其他未加内阴影的表示是“别人的”；\r\n然后，进入个人中心页，请求加载数据，展示获赞数量；\r\n点击我的动态，进入我的动态页，请求加载数据，展示我的动态列表；\r\n点击其中一条动态，进入动态详情页，请求加载数据，进行点赞操作；\r\n在第5步中，点赞成功后，回退到我的动态页，可以看到该条动态点赞状态和数量发生变化，已经同步；\r\n再回到到个人中心页，也可以看到获赞数量发生变化，已经同步；\r\n再回到动态广场页，也可以看到对应的一条动态点赞状态和数量发生变化，已经同步；\r\n\r\n下面我们来探讨一下这个场景的实现，在此之前，我们先要了解在点赞时，该场景中各页面的状态及关系。\r\n\r\n\r\n如上图所示，当我们在点赞时，4个页面都已经在是打开的（4个webview）。当我们点赞成功时，点击左上解返回时，动态详情页的webview关掉，直接看到下一层webview，也就是我的动态页，这个页面是已经存在的。其他页面也是如此。\r\n那对于这些已经存在的页面，我们应该如何同步更新数据呢？\r\n当然，如果比较懒，可以直接在onShow的时候重新拉数据渲染页面。但显然这是非常低级、不可取也没必要的做法。重新拉数据需要耗时，页面重新渲染也会看到闪屏，关键是根本没必要重新拉数据，因为数据发生了变化，前端是知道的。\r\n所以我们可以这样做，在动态详情页点赞成功时，保存一个数据到全局globalData中去，回到我的动态页，在onShow中去检测全局globalData中是否有点赞变化的数据，有的话，就读取出来去更新相应的动态。\r\n// 动态详情页js\r\nonLike() {\r\n  ...\r\n  success: () => {\r\n    App.globalData.like = {\r\n      fid: 10001,\r\n      likes: 1,\r\n      hasLike: true         \r\n    }\r\n  }\r\n}\r\n\r\n// 我的动态页js\r\nonShow() {\r\n  if(App.globalData.like !== null) {\r\n    // 读取globaldata.like数据去更新\r\n    this.doUpdata()\r\n    // 特别需要注意，更新完后，需要把globaldata.like清掉，不然下次onShow还会继续走到该逻辑\r\n    App.globalData.like = null\r\n  }\r\n}\r\n复制代码这样似乎可以达到我们的目的，无请求、纯前端局部更新。\r\n但这样还存在一个问题，当我们再退回到个人中心页时，要检查下获赞数量是否需要更新，以及回到动态广场页时，也要检查点赞有没有发生变化。但在这两个页面onShow去判断App.globalData.like时，都已经检测不到了，因为该数据已经在我的动态页onShow中置为null了。\r\n概括来说，在点赞时，只生产了一条数据，但有多个消费者，哪个页面先把数据消费了，其他页面也就无法检测到数据了。\r\n由此，我们想到那就使用EventBus来处理。\r\n首先，我们自己实现一套简单的EventBus。\r\n\r\n源码见：git.weixin.qq.com/xinyuanliu/…\r\n\r\n在小程序启动时，初始化EventBus：\r\nconst Event = require('/util/events.js').default\r\n\r\nApp({\r\n  events: null,\r\n  onLaunch(options) {\r\n    this.initEvents()\r\n    // doOtherThings\r\n  },\r\n  initEvents() {\r\n    this.events = new Event()\r\n  },\r\n  emitFeedsLike(data) {\r\n    this.events.emit('feedsLike', data)\r\n  },\r\n  emitPublishFeeds(data) {\r\n    this.events.emit('publishFeeds', data)\r\n  },\r\n  ...\r\n}\r\n复制代码各个页面在onLoad时，注册监听事件(在此以我的动态页为例)：\r\n// 我的动态.js\r\nconst App = getApp()\r\n\r\nPage({\r\n  data: {\r\n    list: []\r\n  },\r\n  onLoad: function (options) {\r\n    ...\r\n    // 监听点赞事件广播\r\n    ↓ 重点在这里 ↓\r\n    App.events.on('feedsLike', data => {\r\n      console.log('我的动态页面收到点赞变化通知：', data)\r\n      // 进行更新操作\r\n    })\r\n    // 监听发布事件广播\r\n    ↓ 重点在这里 ↓\r\n    App.events.on('publishFeeds', data => {\r\n      console.log('我的动态页面收到发布动态通知：', data)\r\n      // 进行更新操作\r\n    })\r\n  },\r\n  ...\r\n})\r\n复制代码然后在动态点赞时，发出事件通知。（这里一条动态是封装成组件，不属于某一个页面，点赞事件也是封装在组件内）\r\nconst App = getApp()\r\n\r\nComponent({\r\n  properties: {...},\r\n  methods: {\r\n    // 点赞\r\n    tapLike(e) {\r\n      let { likes, hasLike } = this.data\r\n\r\n      likes += (hasLike && -1 || 1)\r\n      hasLike = !hasLike\r\n\r\n      this.updateFeeds(likes, hasLike).then(() => {\r\n        this.setData({\r\n          likes,\r\n          hasLike\r\n        })\r\n\r\n        // 广播事件\r\n        ↓ 重点在这里 ↓\r\n        App.emitFeedsLike({\r\n          uid: this.data.uid,\r\n          fid: this.data.fid,\r\n          likes,\r\n          hasLike\r\n        })\r\n      })\r\n    },\r\n    ...\r\n  }\r\n})\r\n复制代码这样，我们便在小程序中实现了一套跨页面数据同步的方案。\r\n直观上这已经非常完美的实现了我们的需求。但在小程序中存在一个与我们常规经验不太一致的地方。那就是页面在关掉后，它里面的对象并没有销毁，这点是因为小程序的逻辑层是共用一个进程。\r\n因此，每次进入页面，都会注册一次监听事件，而退出页面后，该事件并不会销毁。这样的话，多次重复进入页面，就会注册多个重复事件，当事件发生时，就会执行多次响应。请仔细观察下图！\r\n为了避免该现象出现，我们切记要在页面的onUnload事件中，主动销毁监听事件。\r\nPage({\r\n  eventsListener: {},\r\n  data: {\r\n    list: []\r\n  },\r\n  onLoad: function (options) {\r\n    ...\r\n    // 监听点赞事件广播\r\n    ↓ 重点在这里 ↓\r\n    this.eventsListener.feedsLike = App.events.on('feedsLike', data => {\r\n      console.log('我的动态页面收到点赞变化通知：', data)\r\n      // 进行更新操作\r\n    })\r\n    // 监听发布事件广播\r\n    ↓ 重点在这里 ↓\r\n    this.eventsListener.publishFeeds= App.events.on('publishFeeds', data => {\r\n      console.log('我的动态页面收到发布动态通知：', data)\r\n      // 进行更新操作\r\n    })\r\n  },\r\n  ↓ 重点在这里 ↓\r\n  onUnload() {\r\n    for (let i in this.eventsListener) {\r\n      App.events.remove(i, this.eventsListener[i])\r\n    } \r\n  },\r\n  ...\r\n})\r\n复制代码至此，我们在小程序中完美的实现了跨页面/组件、多页面数据同步。\r\n本文研究的demo均可以小程序中体验，项目源码：git.weixin.qq.com/xinyuanliu/"}
{"title": "微信小程序-渐入渐出动画效果实现 ", "author": "2019-5-28 00:01", "pub_time": "2019-5-28 00:01", "content": "在做小程序列表展示的时候，接到了一个需求。需要在列表展示的时候加上动画效果。设计视频效果如下图：需要在进入列表页的时候，依次展示每一条卡片，在展示完成后需要隐藏掉当天之前的卡片。实现思路实现该动画效果，首先需要给每个卡片添加一个css动画。因为每个卡片的显示是有时间间隔的，以及考虑到展示完成后的隐藏效果，所以动画效果需要用js动态去添加。在看了微信开发文档后，发现微信小程序提供了Animation的一个动画对象，具体看了里面的参数后发现，是可以实现需求上的效果的。具体使用如下api:wx.createAnimation(Object object) 创建一个animation对象。最后通过动画实例的export方法导出动画数据传递给组件的 animation 属性。里面有如下参数：duration（动画持续时间，单位 ms）,timingFunction（动画的国度效果）,delay（动画延迟）创建的animation对象，本次实现过程中需要用到如下属性：Animation.export() 可以导出动画队列，export 方法每次调用后会清掉之前的动画操作。Animation.step(Object object) 表示一组动画完成。可以在一组动画中调用任意多个动画方法，一组动画中的所有动画会同时开始，一组动画完成后才会进行下一组动画。比如一组动画结束了，就以step()结尾Animation.translateY(number translation) 在 Y 轴平移的距离，单位为 pxAnimation.opacity(number value) 透明度 0-1的取值范围看到上面这些属性，合理使用的话，那么实现需求提到动画效果那是稳稳的。实现步骤封装一个方法，用来创建动画，并方便调用/**\r\n * 动画实现\r\n * @method animationShow\r\n * @param {that} 当前卡片\r\n * @param {opacity} 透明度\r\n * @param {delay} 延迟\r\n * @param {isUp} 移动方向\r\n */\r\n  animationShow: function (that,opacity, delay, isUp) {\r\n    let animation = wx.createAnimation({\r\n      duration: 1000,\r\n      timingFunction: 'ease',\r\n      delay: delay\r\n    });\r\n    <!--考虑到还需要隐藏掉当天之前的卡片，做如下判断来赋予不同的动画效果-->\r\n    if (isUp == 'down') {\r\n      animation.translateY(0).opacity(opacity).step().translateY(-80).step();\r\n    } else if (isUp == 'up') {\r\n      animation.translateY(0).opacity(opacity).step().translateY(-140).opacity(0).step()\r\n    } else {\r\n      animation.translateY(0).opacity(opacity).step()\r\n    }\r\n    let params = ''\r\n    params = animation.export()\r\n    return params\r\n  }, \r\n复制代码初始化每个卡片的样式首先每个卡片的位置相对于自身往Y轴平移80像素，并且把透明度设置为0。这样就可以进入页面的时候再往下平移并且让卡片逐渐显示。\r\n.init{\r\n  opacity: 0;\r\n  transform: translateY(-80px)\r\n}\r\n复制代码处理数据循环处理每一条数据，通过调用封装的方法，来获得该卡片应该拥有的动画属性for (let i = 0; i < transData.length; i++) {\r\n    if (i == 0) {\r\n      transData[i].animation = that.app.slideupshow(that, 1, 0, 'up')\r\n    } else {\r\n      transData[i].animation = that.app.slideupshow(that, 1, (i + 1) * 10, 'down')\r\n    }\r\n  }\r\n复制代码跟设计视频中的动画风格基本保持一致，美滋滋。"}
{"title": "微信小程序：功能升级中页面（图片等比缩放） ", "author": "2019-5-28 00:08", "pub_time": "2019-5-28 00:08", "content": "在程序开发中，难免会要考虑一些基础业务以外的功能，如错误提示、升级提示、维护提示等...有时候因为时间问题，产品可能只开发部分功能就上线了，而为了让用户知道有这么一个功能，未开发完全的功能则仅放置一个入口，此时就需要一个升级/维护的提示页面...功能升级中.png如上图：这个页面很简单，一张图片，一行文字，在代码上，都不需要写任何js代码。仅需改动wxml和wxss即可；<!--pages/error/update.wxml--><view class='vertical'>  <image class='image' src='../../images/icon-update.png' mode='widthFix'></image>  <text class='text'>功能升级中...</text></view>在这里，唯一需要注意的是mode='widthFix'，之所以能保持image显示的图片等比缩放，就是通过mode控制的，该属性默认值是scaleToFill，即拉伸充满image容器。另外还有一些其他值，参考官方文档即可，这里不介绍了... wxss/* pages/error/update.wxss */.vertical{  display: flex;  flex-direction: column;  align-items: center;}.bg-white {  background-color: #ffffff;}.image {  margin-top: 30%;  width: 200rpx;}.text {  margin-top: 50rpx;  font-size: 40rpx;  color: #333333;}wxss同样很简单，关键点在于纵向布局vertical，它包含了元素纵向排列flex-direction: column;及居中align-items: center; 图片最后，则是在images中放入图片icon-update.png 简书：ThinkinLiu 博客: IT老五这只是一个简单的功能升级页面，同时，你也可以将图片和文字改改，改为维护页、错误页或者其他提示页..."}
{"title": "微信小程序统计Trello、掘金积分程序，Promise做异步处理 ", "author": "2019-5-28 00:24", "pub_time": "2019-5-28 00:24", "content": "Trello是一款团队管理工具。本文介绍的是使用微信小程序做一个积分排名的项目，从微信小程序端去调用Trello的接口、获取掘金上面的文章,按照特定的规则去积分。项目开始之前需要做一些准备工作：注册 Trello 账号-->注册为开发者 -->获取 trello 开发者的key -->生成 token。然后进入Trello API 文档获取需要的接口。成为微信小程序开发者，具体步骤请参考 developers.weixin.qq.com/miniprogram…获取genetalks_大数据里面的所有文章。提示：使用微信开发者工具发请求前先把：微信开发者工具（右上角） --> 详情 --> 不校验合法域名、web-view（业务域名）、TLS 版本以及 HTTPS 证书 (✔ 上)本次项目所做的小程序，微信扫码进入积分规则如下练习题在 Trello 里面,获取对应的 board（Trello 中的看板 ）里面有 list(board 里面的任务列表) 里面有 card（对应任务、题目）。按照一定的约定在对应的 board 里面去创建 list --> card，完成了对应的任务才能去归档，然后获得对应的 board 里面归档的 card 对应参与排名者应该获得的积分。只有博客在掘金里面，因此需要获取掘金里面的文章，但是掘金平台方面没有提供 api 接口，那么就只有自己去获取对应的 html 页面，然后做字符串截取了。实现因为页面比较简单，页面也少。下面说说Promise处理异步的问题。二、微信小程序端不引入第三方 js 脚本的情况下处理异步问题。本人所知的处理 js 异步问题的方法：使用回调。缺点：代码逻辑变的复杂，回调层次根据你访问接口的次数越来越深。使用 async await,但是不引入第三方 js 脚本，就不能使用。Promise，下面会讲解怎样使用 Promise，不再需要回调，代码可读性提高。微信小程序发送请求。例：统计积分需要获取 Trello 的接口、掘金的文章，拿到数据后进行其他操作，使用回调let sort = () => {}; // sort函数做逻辑处理，排序操作\r\nconst get_data = () => {\r\n  const _this = this;\r\n  const get_board = (callback) => {\r\n    wx.request({\r\n      url: 'https://*****',\r\n      success: resp => {\r\n        // 拿到resp\r\n        // 使用回调\r\n        // 如果需要把resp传入过去，然后做逻辑处理\r\n        // 回调里面使用了回调，把sort 当成参数传入、也可以不传入,直接在callback,里面调用。如果都正常返回的话此处调用了一次sort函数\r\n        resp.data.forEach((item, index) => {\r\n          callback(item, index === resp.data.length - 1 && sort);\r\n        })\r\n      }\r\n    });\r\n  };\r\n  const get_cards = (data, callback) => {\r\n    wx.request({\r\n      url: data.url,\r\n      success: () => {\r\n        // 业务逻辑处理\r\n        // ................\r\n        callback && callback();\r\n      }\r\n    })\r\n  }\r\n  const get_blogs = (callback) => {\r\n    wx.request({\r\n      url: 'https//****',\r\n      success: resp => {\r\n        // 同上。。。。。\r\n      }\r\n    })\r\n  }\r\n  get_board(get_cards); // 获取board里面的cards \r\n  get_blogs(get_blog_detail) // 获取博客的内容\r\n  // 然后调用get_board 、get_blogs，这样的话虽然也能做最后的逻辑处理，但是sort函数被执行了2次，并且还容易因为数据请求出错，而发生统计错误。\r\n};\r\n复制代码使用Promise// 获取board下归档的card\r\nconst get_cards = (data) => {\r\n  const get_value = new Promise(resolve, reject) => {\r\n    wx.request({\r\n      url: data.url,\r\n      success: (resp) => resolve(resp),\r\n      fail: (err) => reject(err)\r\n    })\r\n  }\r\n  // 返回一个Promise，拥有card接口返回值。\r\n  return get_value;\r\n}\r\nconst get_board = () => {\r\n  // 获取所有的board\r\n  const get_value = new Promise(resolve, reject) => {\r\n    wx.request({\r\n      url,\r\n      success: (resp) => resolve(resp)\r\n    })\r\n  }\r\n  let promise_arr;\r\n  // 此时的get_value拥有board接口返回的值\r\n  return get_value.then(resp => {\r\n    // 遍历需要参与积分的board\r\n    resp.data.forEach(item => {\r\n      // 把每个card接口返回的Promise 存储到promise_arr数组里\r\n      promise_arr.push(get_cards(item));\r\n    })\r\n    // Promise.all函数接收一个Promise数组\r\n    // 使用Promise.all 等所有获取card的接口都执行完了会返回一个数组，数组的每一项对应board下面card的返回值\r\n    return Promise.all(promise_arr)\r\n  })\r\n  // 博客的获取方式与上面获取card的方式一样  \r\n}\r\n  // 在写一个Promise.all()等待获取掘金博客的数据与获取Trello的数据都获取到了就可以执行最后的数据汇总及排序。调用sor()\r\n  const get_data = () => {\r\n    return Promise.all([get_board(), get_card()]).then(resp => return sort(resp));\r\n  }\r\n复制代码微信小程序上线问题微信小程序只能获取https的API因为开发时选用的是不校验合法域名、web-view（业务域名）、TLS 版本以及 HTTPS 证书，所以当你上传了代码，使用体验版本时，会发现所有的接口都获取不到数据，这时你需要去微信小程序后台管理页面 开发 --> 开发设置 --> 服务器域名：把域名填配置在这里。如果提示你域名未备案，可以做域名转发，自己不会的话可以请教后台的大哥帮忙。欧克，总结完毕！！！作者信息：宁文飞，人和未来大数据前端工程师"}
{"title": "小程序封装路由文件和路由方法，5种路由方法全解析 ", "author": "2019-5-28 00:32", "pub_time": "2019-5-28 00:32", "content": "小程序5种路由方法使用场景，封装路由文件和路由方法，提升小程序体验和开发效率明确要解决的问题每次使用路由时，总是粘贴复制路径，这样在路径有修改时，需要修改所有用到该路径的地方，维护成本高路由跳转时拼接参数让人头大，业务复杂时要拼接十几个参数路由返回，只会返回一层，不能直接返回到目标页面，因为不知道目标页面是否在路由栈中，也不知道在第几层这些问题都可以通过封装路由文件和路由方法解决，提供开发效率，减少BUG，省下来的时间可以多陪陪女朋友封装路由文件，对路由进行统一管理在根目录创建router.js// 这是路由管理页面，在此统一配置路由\r\nexport default {\r\n  'index':'/index/index', // 首页\r\n  'list':'/list/list', // list页面\r\n  'top':'/top/top', // top页面\r\n}\r\n复制代码解决了第一个问题封装路由方法路由方法有五个，常用的有三个 switchTab 、 navigateTo 、 navigateBack简单介绍一下这五个方法及使用场景switchTab ,跳转tabBar页面专用，其他页面出栈，新页面入栈navigateTo 最常用的路由跳转，会加入到页面栈，允许返回，也就是新页面不断入栈navigateBack 返回，只能返回到页面栈中存在的页面，页面不断出栈，直到到达目标页redirectTo 关闭当前页面，跳转某个页面，当前页面不会加入到页面栈，也就是说当前页面不能通过返回到达，比如付款页面，付款完成后，最好不要再让用户返回到付款页，再比如一些无法修改的操作，比如删除商品，商品删除后再通过 navigateBack 返回再删除一次商品，体验肯定不好，表现为当前页面出栈，新页面入栈reLaunch 关闭所有页面，打开某个页面，可以打开任意页面包括tabBar，适合强制完成某个操作的页面，比如登录页，当已登录的用户点击退出后，进入登录页，那么就不能通过返回再回去了，就必须留下来登录或注册，适合用这个，表现为所有页面出栈，新页面入栈开始封装，在根目录创建utils.js// 封装路由方法\r\nexport default {\r\n\r\n  /** \r\n   * function\r\n   * @param {string} url 目标页面的路由\r\n   * @param {Object} param 传递给目标页面的参数\r\n   * @description  处理目标页面的参数，转成json字符串传递给param字段，在目标页面通过JSON.parse(options.param)接收\r\n   */  \r\n  navigateTo(url,param={}){\r\n    if(param){\r\n      url+=`?param=${JSON.stringify(param)}`\r\n    }\r\n    wx.navigateTo({\r\n      url:url,\r\n      fail(err) {\r\n        console.log('navigateTo跳转出错',err)  \r\n      },\r\n    })\r\n  },\r\n\r\n\r\n   /** \r\n   * function\r\n   * @param {string} url 目标页面的路由\r\n   * @param {Object} param 传递给目标页面的参数，只有页面栈无目标页面调用navigateTo时，参数才会生效，单单返回不能设置参数\r\n   * @description  先取出页面栈，页面栈最多十层，判断目标页面是否在页面栈中，如果在，则通过目标页的位置，返回到目标页面，否则调用navigateTo方法跳转到目标页\r\n   */   \r\n  navigateBack(url,param={}){\r\n    const pagesList = getCurrentPages()\r\n    let index =  pagesList.findIndex(e=>{\r\n      return url.indexOf(e.route)>=0\r\n    })\r\n    if(index == -1){  // 没有在页面栈中，可以调用navigateTo方法\r\n      this.navigateTo(url,param)\r\n    }else{\r\n      wx.navigateBack({\r\n        delta: pagesList.length-1-index,\r\n        fail(err){\r\n          console.log('navigateBack返回出错',err)\r\n        }\r\n      })\r\n    }\r\n  },\r\n\r\n\r\n  switchTab(url){ // 封装switchTab，switchTab不能有参数\r\n    wx.switchTab({\r\n      url:url\r\n    })\r\n  },\r\n  redirectTo(url,param={}){ // 封装redirectTo，和navigateTo没啥区别\r\n    if(param){\r\n      url+=`?param=${JSON.stringify(param)}`\r\n    }\r\n    wx.redirectTo({\r\n      url:url,\r\n      fail(err) {\r\n        console.log('redirectTo跳转出错',err)  \r\n      },\r\n    })\r\n  },\r\n  reLaunch(url,param={}){ // 封装reLaunch，和navigateTo没啥区别\r\n    if(param){\r\n      url+=`?param=${JSON.stringify(param)}`要根据具体业务来，该返回就返回，该跳转就用跳转，不能一直跳转！\r\n    }\r\n    wx.reLaunch({\r\n      url:url,\r\n      fail(err) {\r\n        console.log('reLaunch跳转出错',err)  \r\n      },\r\n    })\r\n  }\r\n}\r\n复制代码以上对参数的封装解决了第二个问题，对 navigateBack 的封装解决了第三个问题"}
{"title": "小程序 多图列表 性能优化 ", "author": "2019-5-29 00:32", "pub_time": "2019-5-29 00:32", "content": "小程序 多图列表 性能优化写这篇文章的缘由: 最近在公司的小程序项目中遇到了页面图片元素过多导致的性能问题. 从小程序提供的性能检测面板分析, 确定是图片元素占用了过多内存导致.因为本人之前主要是做桌面端应用开发和原生app开发, 没有太顾及过移动端图片的内存占用问题. 这次既然遇到了, 也就趁这个机会学习一下其优化的技巧.什么造成的性能问题简单的来说: DOM节点过多 && 图片节点过多DOM节点过多会造成更多的内存占用. 按照目前的微信小程序限制, 内存占用500M以上会出现卡顿, 甚至闪退. 如果列表中节点没有图片标签, 内存占用现象还不会太明显, 只是DOM节点过多会造成页面渲染耗时增加. 但当列表节点中含有图片时, 内存占用会迅速攀升.如何解决这两点呢?对于上面两点, 我们分别有对应的优化思路1. DOM节点过多.对于无限加载的页面, 列表中每一个元素都有大量的子节点. 当列表数目增加时, 页面的总节点数会暴增. 以小红书的小程序为例:上图中可以看到, 该页面为很多的卡片组成的列表页面. 假设一个卡片的DOM子节点数为 30, 那么当列表元素加载到1000时, 页面会有 30 * 1000 = 30,000 个DOM节点. 小程序显然是吃不消的 (注: 微信小程序推荐总节点数不超过: 1000 )那我们该如何处理来减少节点数呢?思路很简单: 我们可以只对用户当前屏幕和上下两屏进行真实内容的加载, 对于其他用户暂时不可见的地方, 用空白的节点进行占位. 这样处理后, 实际有内容的卡片数目不超过5个, 页面的总节点数为: 5 * 30 + 995 = 1145 . 相对于之前的节点数有了巨大的改进.让我们来看看代码的实现写代码前, 让我们整理一下需要的数据结构.首先这是一个列表页面, 我们需要一个 List来保存页面显示的数据: showCards . showCards 中只会保存5条真实数据, 其余数据展示以空对象填充.我们还需要一个保存所有真实数据的List, 这样当用户滑动页面时, 我们才能实时获取需要显示的卡片真实数据: totalCardsPage({\r\n  showCards: [],\r\n  totalCards: []\r\n})接下来我们来写页面布局部分:<view wx:for=\"{{showCards}}\"\r\n        wx:key=\"{{index}}\">\r\n\r\n    <self-define-component data-card-data=\"{{item}}\">\r\n    </self-define-component>\r\n    \r\n</view>简单的代码框架就是这样 (这里省略了很多不影响理解思路的代码细节)我们先实现没有优化DOM节点的代码逻辑. 在页面滑动到最底部时, 向 showCards push进新的卡片, 并通过 setData 更新页面. 这样就实现了一个简单的下拉无限加载的列表页面.async onReachBottom() {\r\n    const newCards = await fetchNewCards();\r\n  this.data.showCards.push(newCards);\r\n  this.setData({\r\n    showCards: this.data.showCards\r\n  })\r\n},接下来我们实现优化DOM节点的代码逻辑.我们会再用户滑动页面( onScroll 事件) 时, 对当前页面每个 card 的位置进行判断, 如果该 card在用户可见范围内的上下两屏内, 则展示真实数据, 否则将其替换为宽高与原卡片一致的空白占位节点.在 Page 的 onPageScroll 回调中, 我们进行回收函数的调用 (注意这里回调时要进行 节流 处理, 否则频繁调用会导致页面闪动) . 让我们看看这个回收页面节点函数的主要逻辑:回调中, 我们首先通过小程序提供的获取页面元素位置的api: createSelectorQuery().boundingClientRect 来拿到每个卡片的位置信息.接下来, 我们通过位置信息, 判断是否展示card的真实数据. 对于不展示真实数据的card, 我们需要保存其高度信息, 以便在渲染页面时使用高度信息填充页面. 同时我们给空card一个 type 属性, 方便我们在 wxml中渲染时判断卡片类型.async onScrollCallback() {\r\n  try {\r\n    const rectList = await this.calcCardsHeight();\r\n    this.recycleCard(rectList);\r\n  } catch (e) {\r\n    console.error(e);\r\n  }\r\n}\r\n  calcFeedHeight() {\r\n    return new Promise((resolve, reject) => {\r\n      this.createSelectorQuery()\r\n        .selectAll(`.card`)\r\n        .boundingClientRect(rectList => {\r\n          resolve(rectList);\r\n        })\r\n        .exec()\r\n    })\r\n  },\r\n\r\n  recycleCard(rectList) {\r\n    const newShowCards = [];\r\n    for (let i = 0; i < this.data.showCards.length; i++) {\r\n      const rect = rectList[i];\r\n      if (rect && Math.abs(rectList[i].top - 0) > pageHeight * 2) {\r\n        newShowCards.push({\r\n          type: 'empty-card',\r\n          height: rectList[i].bottom - rectList[i].top\r\n        });\r\n      } else {\r\n          const feed = totalCards[i];\r\n        newShowCards.push(feed);\r\n      }\r\n    }\r\n    this.setData({\r\n      showCards: newShowCards\r\n    });\r\n  }接下来, 我们要对wxml布局文件进行相应的修改:<view wx:for=\"{{showCards}}\"\r\n        wx:key=\"{{index}}\">\r\n\r\n    <view wx:if=\"{{item.type === 'empty-card'}}\"\r\n          class=\"card empty-card\"\r\n          style=\"height: {{item.height}}px\">\r\n    </view>\r\n\r\n    <self-define-component  wx:if=\"{{item.type !== 'empty-card'}}\"\r\n                data-card-data=\"{{item}}\"\r\n                class=\"card read-card\">\r\n    </self-define-component>\r\n    \r\n  </view>这样, 我们就解决了 DOM节点数目过多的问题. 并且最大限度的不影响用户的体验. (虽然用户快速上下滑动时还是会看到一些空白, 但大多数情况用户不会非常快速的上下滑, 而是阅读内容并慢速滑动)2. 图片节点过多通过上面一步的优化, 我们其实已经大幅减少了页面加载的图片数目. 但是有些情况, 我们的列表中的每一个卡片并不是只有一张图, 有时我们的图片组件是一个 swiper . 我们假设每个swiper平均展示10张图片, 那么我们展示5张card的话, <Image/> 节点就有 50 个. 对于一些低端的安卓机, 这样的开销依然会造成卡顿.那有什么好的优化方案呢? 前面一个问题, 我们的优化思路是在用户看不见的地方, 将节点简化展示.同样的, 对于swiper控件, 用户能看到的也就是 当前图片 以及 滑动可见的左右两张图片 . 其余位置的图片是可以简化展示的. 从下图可以看到, 其实需要立即加载的图片只有三张. (红色的框代表的是swiper组件的可视区域)我们使用一个变量记录当前swiper控件展示图片的坐标: curIndex , 然后我们改造一下 wxml布局文件. 代码逻辑很简单, 就是通过判断当前Image 节点的index和swiper展示节点的 index之间距离, 大于2就不显示.经过这样的处理后, 我们的每个swiper组件, 最多只会有三个占用实际内存的 <Image/> 节点.<swiper-item wx:for=\"{{images}}\"\r\n                   wx:key=\"{{index}}\">\r\n\r\n        <view >\r\n          <image class=\"img\"\r\n                 mode=\"widthFix\"\r\n                 src=\"{{index - curIndex < 2 && index - curIndex > -2 ? item.url : ''}}\">\r\n          </image>\r\n        </view>\r\n      </swiper-item>最后以上就是我在这次性能优化中用到的一些小技巧, 希望能为你带来一些帮助 :)如果你对我的文章感兴趣, 这里有我的一些 数据可视化 ， D3.js 方面的文章， 欢迎 fork && star：https://github.com/ssthouse/s..."}
{"title": "仿iPhone通讯录制作小程序自定义选择组件 ", "author": "2019-5-29 00:39", "pub_time": "2019-5-29 00:39", "content": "前言近期闲来无事，想着闲着也是闲着，不如给自己搞点事情做！敢想敢做，于是选择了给微信小程序做个仿iPhone通讯录效果的自定义组件。先来整理一下，瞧瞧需要实现的核心功能。按照第一个字的首字母排序;实现输入搜索功能；侧边栏字母导航；从易到难，先来看看页面的结构布局。基本上分为3块：顶部的搜索区域；内容的展示区域；侧边字母导航栏区域；// index.wxml\r\n<view class=\"main\">\r\n  <!-- 顶部搜索区域 -->\r\n  <view class=\"header\">\r\n  </view>\r\n  <!-- 内容区域 -->\r\n  <scroll-view class=\"scroll\">\r\n  </scroll-view>\r\n  <!-- 侧边导航 -->\r\n  <view class=\"sub_nav\">\r\n  </view>\r\n</view>\r\n复制代码【顶部的搜索区域】一目了然就直接贴代码了。<view class=\"header\">\r\n    // 这里或许有人要问，为啥不用小程序的label组件呢。?_?\r\n    // 原因就是...我就不用，你还能咬我？！^(oo)^\r\n    // 哈哈哈哈～开个玩笑，其实是小程序的label组件还没支持input!\r\n    <view class=\"label\"> \r\n      <icon></icon>\r\n      <input type=\"text\" placeholder=\"搜索\" />\r\n    </view>\r\n</view>\r\n复制代码【内容的展示区域】再说一目了然会不会被打呢？根据图片就可以看出来，存在2个区域。红框包围的外框，负责圈定展示的范围；绿框包围的范围，包含有字母标题和对应的子项。代码如下：<scroll-view class=\"scroll\">\r\n    <view class=\"dl\">\r\n      <view class=\"dt\">这里是字母标题。</view>\r\n      <view class=\"dd\">\r\n        <span>这里当然是展示的内容啦。</span>\r\n      </view>\r\n    </view>\r\n  </scroll-view>\r\n复制代码【侧边字母导航栏区域】为了节省一下文章的篇幅，这里就不贴图了，很简单，就是并排下来就好了。<view class=\"sub_nav\">\r\n    <view class=\"option\">这里是输出字母。</view>\r\n</view>\r\n复制代码接下来是wxss的样式了。考虑到wxss的样式较多，我就直接贴代码链接吧，有兴趣的童鞋可以瞧瞧。完成之后，是时候贴个效果图了。（不许吐槽丑，宝宝会不开心的！）结构样式弄完了，也贴一下自定组件的基础文件// index.json\r\n{\r\n  \"component\": true\r\n}\r\n复制代码// index.js\r\nComponent({\r\n  properties: {}, // 组件的对外属性\r\n  data: {},       // 组件的内部数据\r\n  lifetimes: {},  // 生命周期\r\n  methods: {}     // 事件\r\n});\r\n复制代码现在开始实现功能了！！！按照第一个字的首字母排序说实话，实现这块功能呢，我是没啥头绪的，所以这个时候就要求助伟大的“度娘/Google”了。经过楼主“遍寻网络”，查找到如下页面的源码参考：因楼主问题，遗忘了该网址，如有知道的童鞋，贴个链接告诉下楼主，楼主立马麻溜的加上。源码的原理大概描述下：收录20902个汉字和375个多音字的Unicode编码，然后用JS切割首字母并转换成Unicode进行对比，最后返回对应首字母的拼音。// 汉字对应的Unicode编码文件\r\n// oMultiDiff = 多音字 | firstLetterMap = 汉字\r\nimport firstStore from './firstChineseLetter'; \r\n\r\n// 获取首字母拼音\r\nfunction getFirstLetter (val) {\r\n  const firstVal = val.charAt(0);\r\n  if (/.*[\\u4e00-\\u9fa5]+.*/.test(firstVal)) {\r\n    // 处理中文字符\r\n    // 转换成Unicode编码，与firstStore里面的数据进行对比，然后返回对应的参数\r\n    const code = firstVal.charCodeAt(0); // 转换成Unicode编码\r\n    return code in firstStore.oMultiDiff ? firstStore.oMultiDiff[code] : firstStore.firstLetterMap.charAt(code - 19968);\r\n  } else {\r\n    // 这里处理非中文\r\n    // 检测是否字母，如果是就直接返回大写的字母\r\n    // 不是的话，返回“#”\r\n    return /^[a-zA-Z]+$/.test(firstVal) ? firstVal.toUpperCase() : '#';\r\n  }\r\n}\r\n\r\ngetFirstLetter('东城区');\r\n// 输出结果：D\r\n\r\n复制代码firstChineseLetter.js地址获取首字母的方法有了之后，就该对数据进行处理了。首先定义一下组件所需要的参数。Component({\r\n  // 组件的对外属性\r\n  properties: {\r\n    data: { type: Array, value: [],  }, // 组件外传递进来的数据\r\n    attr: { type: String, value: 'label' }, // 需要进行首字母处理的属性，默认是\"label\"\r\n  },\r\n  ...\r\n})\r\n复制代码然后，针对组件外传递进来的数据，做一次转换。// 静态数据的存储\r\nconst Static = {\r\n  list: []\r\n}\r\n\r\nComponent({\r\n  ...\r\n  methods: {\r\n    // 初始/重置数据\r\n    init () {\r\n      const { data, attr } = this.properties;\r\n\r\n      let changeData = [], // 转换后的数据\r\n          inChangeData = {}; // 存储转换后的数据对应字母的索引值\r\n          \r\n      data.map(v => {\r\n        // 获取首字母拼音\r\n        let firstLetter = this.getFirstLetter(v[attr]); \r\n        \r\n        // 循环对比检测\r\n        firstLetter.split('').map(str => {\r\n          if (str in inChangeData) {\r\n            // 有首字母相同的项，\r\n            // 则添加入已有的项里面\r\n            changeData[inChangeData[str]].list.push(v);\r\n          } else {\r\n            // 没有首字母相同的项，\r\n            // 则在尾部追加一条新的数据，\r\n            // 储存对应的字母值（firstLetter），\r\n            // 同时存储该字母对应的索引\r\n            changeData.push({ firstLetter: str, list: [v] });\r\n            inChangeData[str] = changeData.length - 1;\r\n          }\r\n        });\r\n      });\r\n      \r\n      // 此时转换后的数组属于乱序，\r\n      // 需要对乱序的数组进行排序\r\n      changeData.sort((pre, next) => pre.firstLetter < next.firstLetter ? -1 : 1);\r\n      \r\n      // 若存在“#”项，将位置位移至底部\r\n      if (changeData[0].firstLetter === '#') {\r\n        const firstArr = changeData.splice(0, 1);\r\n        changeData = [...changeData, ...firstArr];\r\n      }\r\n\r\n      // 存储转换后的数据，\r\n      // this.data.list的数据对应页面的展示数据，因为有搜索功能，数据可能会变更，\r\n      // 在静态的数据里面，也存储1份数据，方便后续的搜索等功能。\r\n      this.setData({ list: changeData });\r\n      Static.list = changeData;\r\n    },\r\n  }\r\n  ...\r\n});\r\n复制代码初始化函数有了之后呢，当然是调用它啦。Component({\r\n  lifetimes: {\r\n    // 在组件实例进入页面节点树时执行初始化数据\r\n    attached () {\r\n      this.init();\r\n    }\r\n  },\r\n  observers: {\r\n    // 考虑到组件传递的数据存在变更的可能，\r\n    // 在数据变更的时候，也要做一次初始化\r\n    'data, attr, icon' (data, attr) {\r\n      this.init();\r\n    }\r\n  },\r\n})\r\n复制代码接下来是搜索功能啦～先给页面搜索框加个监听事件（input）<view class=\"main\">\r\n  ...\r\n  <view class=\"header\">\r\n    <view class=\"label\">\r\n      <icon></icon>\r\n      <input type=\"text\" placeholder=\"搜索\" value=\"{{ search }}\" bindinput=\"searchData\" />\r\n    </view>\r\n  </view>\r\n  ...\r\n</view>\r\n复制代码接着是JS的事件const Static = {\r\n  list: []\r\n}\r\n\r\nComponent({\r\n  ...\r\n  methods: {\r\n    searchData (e) {\r\n      const { value } = e.detail; // 用户输入的值\r\n      const { list } = Static; // init存储的静态数据，用来做数据对比\r\n      const { attr } = this.properties; // 要对比的属性值\r\n      let result = [], tem = {};\r\n      \r\n      // 没有搜索内容，返回全部内容\r\n      if (value.length === 0) { this.setData({ list: Static.list }); return; }\r\n\r\n      // 检索搜索内容\r\n      list.map(v => {\r\n        // 获取所有跟value匹配上的数据\r\n        const searchList = v.list.filter(v => v[attr].indexOf(value) !== -1);\r\n        \r\n        if (searchList.length > 0) {\r\n          // 此处原理类似楼上init的对比，此处不细说，\r\n          // 反正我懒我有理（0.0）\r\n          if (v.firstLetter in tem) {\r\n            const _list = result[tem[v.firstLetter]].lish;\r\n            result[tem[v.firstLetter]].lish = [..._list, ...searchList];\r\n          } else {\r\n            result.push({ firstLetter: v.firstLetter, list: [...searchList] });\r\n            tem[v.firstLetter] = result.length - 1;\r\n          }\r\n        }\r\n      });\r\n      \r\n      // 存储数据\r\n      this.setData({ list: result, search: value });\r\n    }\r\n  },\r\n  ...\r\n});\r\n复制代码侧边栏字母导航（突然觉得，写文好累啊！！！）写这块的时候呢，楼主发现了iPhone通讯录侧边导航栏有个问题，手指在字母导航栏上滑动的时候，有时候很难确认自己滑到了哪个区域？！然鹅这个问题呢，楼主发现了微信的通讯录，针对这块添加了手指滑动的时候，添加了个结构来帮助用户确认目前所处的区域。楼主本着学习的精神，借(chao)鉴(xi)了这个效果，来个效果图。贴一下新的wxml结构<!-- 侧边导航 -->\r\n  <view class=\"sub_nav\" id=\"subNav\" catchtouchstart=\"subTouchStart\" catchtouchmove=\"subTouchMove\" catchtouchend=\"subTouchEnd\">\r\n    <view class=\"option\" wx:for=\"{{ list }}\" data-firstLetter=\"{{ item.firstLetter }}\" wx:key=\"firstLetter\">\r\n      {{ item.firstLetter }}\r\n      <!-- 以下这块就是新增的结构啦 S -->\r\n      <view \r\n        class=\"max {{ item.firstLetter ===  scrollIntoView && subNavHint ? 'show' : '' }}\" \r\n        data-desc=\"{{ item.firstLetter }}\"\r\n      ></view>\r\n      <!-- 以上这块就是新增的结构啦 E -->\r\n    </view>\r\n  </view>\r\n复制代码const Static = {\r\n  list: [],\r\n  timer: null\r\n}\r\n\r\nComponent({\r\n  ...\r\n  data: {\r\n    scrollIntoView: '', // 标记当前处于哪个字母\r\n    subNavHint: false, // 控制借(chao)鉴(xi)微信效果的元素\r\n  },\r\n  methods: {\r\n    subTouchStart () {\r\n      this.setData({ subNavHint: true, scrollIntoView: '' });\r\n    },\r\n    subTouchEnd () {\r\n      this.setData({ subNavHint: false });\r\n    },\r\n    subTouchMove (e) {\r\n      // 获取字母导航栏元素对应的值\r\n      const query = this.createSelectorQuery();\r\n      query.select('#subNav').boundingClientRect();\r\n      query.selectViewport().scrollOffset();\r\n      query.exec(res => {\r\n        const { clientY } = e.touches[0]; // Y轴的位置\r\n        const DomTop = res[0].top; // 导航元素距离顶部的位置\r\n        const { list } = this.data;\r\n        \r\n        // 计算索引，\r\n        // 或许看到这里有人会疑问，为什么是除以20？\r\n        // 因为样式里面，我写的高度是20px，所以每个字母的区域是20px。\r\n        let index = Math.round((clientY - DomTop) / 20); \r\n        index = index >= list.length ? list.length - 1 : index; // 限制索引大于0\r\n        index = index < 0 ? 0 : index; // 限制索引小于0\r\n        // 限制结果重复赋值\r\n        if (list[index].firstLetter !== this.data.scrollIntoView) {\r\n          this.setData({ scrollIntoView: list[index].firstLetter });\r\n          // 加个抖动效果\r\n          wx.vibrateShort(); \r\n        }\r\n      });\r\n      }\r\n    },\r\n  }\r\n  ...\r\n});\r\n复制代码结语文章写到这呢，基本上核心的功能都已经实现啦～（终于写完了...）通过自己封装组件，楼主还是有挺大收获的！当然，这个组件还有很多可以继续完善的地方，有兴趣的童鞋呢，可以提出你的优化建议，楼主有时(xing)间(qu)的话，会继续完善下去。最后，还是推一下这个组件啦，希望它能帮到有需要的童鞋。github地址手写不易，欢迎提issues，欢迎star，内附有使用方法哦。"}
{"title": "如何将老项目的小程序快速改为分包模式 ", "author": "2019-5-29 00:47", "pub_time": "2019-5-29 00:47", "content": "背景\r\n在最开始准备制作小程序的时候，为了求开发的快速，所使用了直接page的引入方式，每次小程序加载都是全包下载。3月份之前小程序页面稳定在35个，下载耗时在1800ms左右，4月份初上线了新业务页面膨胀到52个页面时，下载耗时基本稳定在2300ms左右，随着用户反馈越来越多，所以开始准备小程序采用分包加载，来解决这个问题。5月份在分包加载之后，页面依旧稳定在52个，但是下载耗时稳定800ms左右，缩短了将近1500ms。基本做到了0业务入侵、加入npm script 来实现新建页面，同时兼容分包加载，page加载。\r\n操作流程\r\n执行命令\r\nnpm run new\r\n复制代码给出信息提示，并且要求输入路径\r\n[Info] 帮助你快速创建page文件\r\n[Info] 只局限于新目录创建\r\n[Info] 请输入文件路径，已帮你省略pages/\r\n[Info] 例子：address/addressList\r\n? 请输入文件路径：\r\n复制代码输入路径之后创建文件的提示\r\n[Info] 已创建base64.js\r\n[Info] 已创建index.js\r\n[Info] 已创建index.json\r\n[Info] 已创建index.wxml\r\n[Info] 已创建index.wxss\r\n[Info] 创建完成！！！！\r\n复制代码选择包，是主包、还是分包，并且提示，给出提示，如果是tabBar中使用，只能选择主包，并且手动配置app.json的tabBar\r\n? 你想生成什么样的包： (Use arrow keys)\r\n❯ 主包，在pages中写入，如果是tabBar中使用，只能选择主包，并且手动配置app.json的tabBar\r\n  分包，在subpackages中写入\r\n复制代码单选完成之后提示新建成功\r\n[Info] 写入成功\r\n复制代码第一次分包\r\n首先我们对未分包和分包的app.json代码进行对比\r\n// 未分包\r\n\"pages\": [\r\n  \"pages/a/index\",\r\n  \"pages/b/index\",\r\n  \"pages/b/list\",\r\n]\r\n复制代码// 实现分包\r\n\"subpackages\": [\r\n  {\r\n    \"root\": \"pages/a\",\r\n    \"pages\": [\r\n      \"index\",\r\n    ]\r\n  },\r\n  {\r\n    \"root\": \"pages/b\",\r\n    \"pages\": [\r\n      \"index\",\r\n      \"list\"\r\n    ]\r\n  }\r\n]\r\n复制代码接下来看目录结构\r\npages\r\n  |---- a\r\n        |---- index.js\r\n  |---- b\r\n        |---- index.js\r\n        |---- list.js\r\napp.json\r\n复制代码简单分一下，第一次分包的核心业务是，将pages这个普通列表，变成名为subpackages的二叉树结构，左子节点是root，右子节点是pages，并且右子节点是string类型，左子节点是array类型。好吧，我可以定下规则，首先我可以将pages/a/index这个字符串变为数组以/为分界的['pages','a','index']数组，然后我将前两项作为root节点的参数，用slice操作截取出来，转为字符串类型，赋值给root。之后的所有参数，我都赋值或者push给pages参数，最后我就得到了这样一个符合要求的树，最后push进subpackages即可。至于数据源，我只需要读出app.json这个文件的pages参数，并且通过我的方法写入subpackages参数即可。\r\n要点\r\n\r\n去重，因为subpackages内，root节点是唯一的，但是在pages里面可能我会截取初重复的值\r\n\r\n解决\r\n\r\n使用Map结构，把截取出的root值作为key，剩下的作为value，Map数据这种数据结构的特点就是key值唯一。\r\n\r\nlet list = [\r\n  \"pages/a/index\",\r\n  \"pages/a/list\",\r\n  \"pages/a/detail/index\",\r\n  \"pages/c/list\",\r\n  \"pages/b/index\",\r\n];\r\n\r\nlet m = new Map();\r\nlet packages = [];\r\nlist.forEach(v=>{\r\n  let arr = v.split('/');\r\n  let root = arr.splice(0,2).join('/');\r\n  let pages = arr.join('/');\r\n\r\n  if(m.get(root)){\r\n    let s = m.get(root);\r\n    m.set(root,[...s, pages]);\r\n  }else{\r\n    m.set(root,[pages]);\r\n  };\r\n});\r\nfor(let [key,value] of m){\r\n  packages.push({\r\n    root: key,\r\n    pages: value,\r\n  })\r\n}\r\n\r\nconsole.log(packages);\r\n复制代码// log 出的结构\r\n[\r\n  { root: 'pages/a', pages: [ 'index', 'list', 'detail/index' ] },\r\n  { root: 'pages/c', pages: [ 'list' ] },\r\n  { root: 'pages/b', pages: [ 'index' ] }\r\n]\r\n复制代码我已经在不入侵业务的情况下实现了小程序的第一次分包，节约了我手动去改的劳动力，我个人认为，解决问题，上策用数据结构，中策写兼容代码，下策手动去改。至于，读出写入文件，我就不赘述了，google即可。\r\n创建新pages的指令编写\r\n好吧，我实现了第一次的分包。然后我要思考，如果我每次要加页面的话，是不是就要去查看subpackages，找到对应的root，并且添加pages。这么重复劳动力的操作，我为什么不用脚本替代呢，是吧。\r\n核心需求\r\n\r\n编写交互式的命令输入\r\n检测输入的page目录是否存在，存在就报错\r\n不存在创建page目录，复制template到新建的page中\r\n根据使用者的单选，选择写入pages，或者写入subpackages\r\n在page文件加中设置预留文件夹，用做初级业务拆分，不加入subpackages检测\r\n屏蔽app.json中pages的文件，不加入subpackages检测\r\n\r\n设计npm script\r\n{\r\n  \"subcontract\": \"node ./config/subcontract\",\r\n  \"new\": \"node ./config/new\"\r\n}  \r\n复制代码添加的package.json参数，ignore-files表示文件夹中不检测的文件，pages表式app.json中的文件\r\n{\r\n  \"ignore-files\": [\r\n    \"**/common/**\",\r\n    \"**/component/**\",\r\n    \"**/<name>/**\",\r\n    \"**/<name>/**\",\r\n    \"**/<name>/**\",\r\n  ],\r\n  \"pages\": [\r\n    \"pages/<name>/index\",\r\n    \"pages/<name>/index\",\r\n    \"pages/<name>/index\",\r\n  ]\r\n}\r\n复制代码需求已经明确，我就要去找我需要用到的npm包了\r\ncolors        命令行颜色\r\ninquirer      交互式命令行\r\nglob          全局搜索文件\r\nfs-extra      文件写入写出\r\npath          路径\r\nshelljs       执行shell命令\r\n复制代码分析new.js文件\r\nconst colors = require('colors');\r\nconst inquirer = require('inquirer');\r\nconst glob = require('glob');\r\nconst fs = require('fs-extra');\r\nconst path = require('path');\r\nconst shell = require('shelljs');\r\nconst PKG = require('../package.json');\r\nconst ROOT = path.resolve(__dirname, '../');\r\n\r\nlet appJson = require('../app.json');\r\nconst promps = [{\r\n  type: 'input',\r\n  name: 'pagePath',\r\n  message: '请输入文件路径：',\r\n},\r\n{\r\n  type: 'list',\r\n  name: 'type',\r\n  message: '你想生成什么样的包：',\r\n  choices: [\r\n    {\r\n      name: '主包，在pages中写入，如果是tabBar中使用，只能选择主包，并且手动配置app.json的tabBar',\r\n      value: '1',\r\n    },\r\n    {\r\n      name: '分包，在subpackages中写入',\r\n      value: '2',\r\n    },\r\n  ],\r\n}];\r\nconst logger = {\r\n  info(msg) {\r\n    console.log(`[Info] ${colors.green(msg)}`);\r\n  },\r\n  warn(msg) {\r\n    console.log(`[Warn] ${colors.yellow(msg)}`);\r\n  },\r\n  error(msg) {\r\n    console.log(`[Error] ${colors.red(msg)}(／‵Д′)／~ ╧╧`);\r\n  },\r\n};\r\n\r\nlogger.info('帮助你快速创建page文件');\r\nlogger.info('只局限于新目录创建');\r\nlogger.info('请输入文件路径，已帮你省略pages/');\r\nlogger.info('例子：xxxxx/xxxx');\r\n复制代码这是代码中的常量部分和默认提示部分，我写了logeer对象来作为提示输出的默认颜色，promps作为我交互命令行的基础配置。引入package.json我的主要目的是因为我屏蔽了一些文件ignore-files和pages，想这两个参数的文件夹我是不会被检测的，不会被加入到subpackages的。\r\nfunction checkFile(name) {\r\n  const options = {\r\n    ignore: [\r\n      '**/*.js',\r\n      '**/*.wxss',\r\n      '**/*.wxml',\r\n      '**/*.json',\r\n    ],\r\n    cwd: 'pages/',\r\n  };\r\n  const files = glob.sync('**', options);\r\n  if (files.some((v) => v === name)) {\r\n    logger.error('输入的目录已经存在，已终止！！！！');\r\n    return false;\r\n  };\r\n  return name;\r\n};\r\n复制代码在这是检测文件是否存在的方法，只需要传入路径，即可检测这个路径是否在pages/目录中存在。\r\nfunction buildFile(name) {\r\n  const options = {\r\n    cwd: 'template/page',\r\n  };\r\n  const files = glob.sync(`**`, options);\r\n\r\n  files.forEach((v)=>{\r\n    const file = v.split('.tp')[0];\r\n    fs.copy(`${ROOT}/template/page/${v}`, `${ROOT}/pages/${name}/${file}`, (err) => {\r\n      if (err) {\r\n        console.error(err);\r\n        return false;\r\n      }\r\n    });\r\n    logger.info(`已创建${file}`);\r\n  });\r\n  logger.info('创建完成！！！！');\r\n  return true;\r\n};\r\n复制代码这是复制文件夹并且复制模版文件的方法，我准备了tempalte这个文件夹，用来存储我写的模版文件，创建完成之后，我直接复制进去即可。为了和普通文件区别，我添加的.tp后缀。我的模版是可扩展的，我可以把request、app({...})在其中写好，并且添加我个人的一些方法。\r\nfunction subcontract(res) {\r\n  inquirer.prompt(promps[1]).then((answers)=>{\r\n    if (answers.type === '1') {\r\n      PKG['ignore-files'].push(`${res}/**`);\r\n      PKG['pages'].push(`${res}/index`);\r\n      appJson['pages'].push(`pages/${res}/index`);\r\n      fs.writeFileSync(`${ROOT}/app.json`, JSON.stringify(appJson, null, 2));\r\n      fs.writeFileSync(`${ROOT}/package.json`, JSON.stringify(PKG, null, 2));\r\n      logger.info('写入成功');\r\n    };\r\n    if (answers.type === '2') shell.exec('npm run subcontract');\r\n  });\r\n};\r\n复制代码这是选择pages还是subcontract的方法，选择了subcontract，我直接执行我上面写的小程序分包方法subcontract.js即可。如果选择pages，我会将它加入package.json中的pages对象，这个对象表式这些文件名不被subcontract脚本检测。\r\nasync function inquirers() {\r\n  const {pagePath} = await inquirer.prompt(promps[0]);\r\n  const path = pagePath.replace(/\\s+/g, '');\r\n\r\n  if (!path) {\r\n    logger.error('输入有失误，已终止！！！！');\r\n    return false;\r\n  };\r\n  if (/.*[\\u4e00-\\u9fa5]+.*$/.test(path)) {\r\n    logger.error('请不要输入中文符号，已终止！！！！');\r\n    return false;\r\n  };\r\n\r\n  return path;\r\n};\r\n复制代码检测输入值是否合法，是否有中文，并且去除空格\r\n( async function() {\r\n  const inquirerRes = await inquirers();\r\n  const checkFileRes = inquirerRes && checkFile(inquirerRes);\r\n  const buildFileRes = checkFileRes && buildFile(checkFileRes);\r\n  buildFileRes && subcontract(checkFileRes);\r\n})();\r\n复制代码最后组装，inquirerRes变量负责判断输入值是否正确。然后进入checkFile，来检测文件夹是否重复。调用buildFile方法，创建文件夹，复制模版文件。最后调用subcontract来判断是分包还是主包。\r\nsubcontract.js 分析\r\nconst glob = require('glob');\r\nconst fs = require('fs');\r\nconst path = require('path');\r\nconst colors = require('colors');\r\nconst ROOT = path.resolve(__dirname, '../');\r\nconst PAG = require('../package.json');\r\nlet appJson = require('../app.json');\r\n\r\nconst ignoreFiles = PAG['ignore-files'];\r\nconst pages = PAG['pages'];\r\nconst logger = {\r\n  info(msg) {\r\n    console.log(`[Info] ${colors.green(msg)}`);\r\n  },\r\n  warn(msg) {\r\n    console.log(`[Warn] ${colors.yellow(msg)}`);\r\n  },\r\n  error(msg) {\r\n    console.log(`[Error] ${colors.red(msg)}(／‵Д′)／~ ╧╧`);\r\n  },\r\n};\r\n\r\nconst subcontract = () => {\r\n  const options = {\r\n    ignore: ignoreFiles,\r\n    cwd: 'pages/',\r\n  };\r\n  const files = glob.sync('**/index.js', options);\r\n\r\n  let subcontractMap = new Map();\r\n  files.forEach((v)=>{\r\n    let arr = v.split('.')[0].split('/');\r\n    let root = arr.shift();\r\n    let page = arr.join('/');\r\n\r\n    if (subcontractMap.has(root)) {\r\n      let pages = subcontractMap.get(root);\r\n      pages.push(page);\r\n      subcontractMap.set(root, pages);\r\n    } else {\r\n      subcontractMap.set(root, [page]);\r\n    }\r\n  });\r\n\r\n  let subcontractList = [];\r\n  subcontractMap.forEach((v, k)=>{\r\n    subcontractList.push({\r\n      root: `pages/${k}`,\r\n      pages: v,\r\n    });\r\n  });\r\n\r\n  return subcontractList;\r\n};\r\n\r\nappJson.subpackages = subcontract();\r\nappJson.pages = pages;\r\nfs.writeFileSync(`${ROOT}/app.json`, JSON.stringify(appJson, null, 2));\r\nlogger.info('写入成功');\r\n复制代码这个方法其实和小程序第一次分包的方法大同小异。只不过我修改了数据源的获取，第一次我是读取app.json的pages，这里我是根据目录来的，以及加入了ignoreFiles来做文件屏蔽。以及一些友好提示。\r\n结尾\r\n项目优化的道路还有很长这只是最最初步的方案。为什么我开始不直接选择分包呢？因为项目开始的时候还没有分包，而且如果有，我感觉分包机制的这种书写方式，可能会带给开发者出错的可能性，我为了将项目工期缩短，出错可能性降低，我也不会选择一开始就分包。当业务增长到一定量，以及业务逐渐趋向于稳定时候，我就可以根据业务的特性，去做相对应的事情。这种方式我称之为技术迭代。在特定的时候，选择特定的解决方案，坚决不过度设计。"}
{"title": "Canvas 实现小程序动画 ", "author": "2019-5-29 00:55", "pub_time": "2019-5-29 00:55", "content": "这个 Demo 是去年刚接触小程序没多久写的，直接扔在文件夹角落里有点可惜，就拿出来分享给刚入门的同学参考。源代码没有写备注，函数名就是备注，看函数名应该能猜到我是写什么端的。\r\n文中动画都是 Canvas 绘制的，这里就不贴代码了，直接看效果图，有感兴趣的想看实现的点击这里看源码。\r\n1. 绘制贝塞尔曲线\r\n\r\n2. 自定义路径动画\r\n\r\n3. 自定义动画速度曲线\r\n3.1 淡入淡出\r\n\r\n3.2 淡出\r\n\r\n3.3 弹簧"}
{"title": "小程序canvas生成海报优化方案 ", "author": "2019-5-30 00:43", "pub_time": "2019-5-30 00:43", "content": "海报生成速度缓慢问题的优化微信头像在app.js中预先加载缓存多图片异步加载流程中断处理二次授权失败的处理请求或者下载图片失败处理保存图片可被压缩海报生成速度缓慢问题的优化原因分析：主要的时间消耗在于 getImageInfo 网络请求获取头像和 下载图片 获得临时地址的过程，可以看到海报中有3张图片（微信头像、主图、动态二维码（对应不同新闻的ID））需要下载，接下来主要就是对这3张图的优化微信头像在app.js中预先加载缓存//app.js\r\n//可以在app.js中使用小程序默认的全局变量，将头像在加载的时候预先缓存\r\nApp({\r\n    onLaunch: function () {\r\n        // 获取用户信息\r\n        wx.getSetting({\r\n            success: res => {\r\n                if (res.authSetting['scope.userInfo']) {\r\n                    // 已经授权，可以直接调用 getUserInfo 获取头像昵称，不会弹框\r\n                    wx.getUserInfo({\r\n                        success: res => {\r\n                            this.globalData.userInfo = res.userInfo;\r\n                            //从返回值中获取微信头像地址\r\n                            let WxHeader = res.userInfo.avatarUrl;  \r\n                            wx.getImageInfo({\r\n                                src: WxHeader,//下载微信头像获得临时地址\r\n                                success: res => {\r\n                                    //将头像缓存在全局变量里\r\n                                    this.globalData.avatarUrlTempPath = res.path;\r\n                                },\r\n                                fail: res => {\r\n                                    //失败回调\r\n                                }\r\n                            });\r\n                        }\r\n                    })\r\n                }\r\n            }\r\n        })\r\n    },\r\n    globalData: {\r\n        userInfo: null,\r\n        //如果用户没有授权，无法在加载小程序的时候获取头像，就使用默认头像\r\n        avatarUrlTempPath: \"./images/defaultHeader.jpg\"\r\n    }\r\n})\r\n复制代码大致思路是：加载App.js的时候 ==> getSetting(判断是否授权)==> getUserInfo（获取头像）==> getImageInfo（生成临时地址）将需要的网络请求在加载小程序的时候就异步完成，提前将临时地址缓存在全局变量globalData中，这样当用户进入新闻页面，点击生成海报的时候就不需要在请求微信头像，缩短了不少时间。注意：如果用户一开始没有微信授权，生成海报时又必须要用户头像不能使用默认的话，那就只能老老实实走之前的流程了。多图片异步加载let num = 0; //下载图片计数器，假设一共三张图片\r\n//下载图片1\r\nwx.getImageInfo({\r\n    src: image_1,\r\n    success: function (res) {\r\n        //判断是否是最后一张图\r\n        if (num >= 2) {\r\n            console.log(\"图片全部下载完毕，可以绘制海报\")\r\n        } else {\r\n            //如果不是最后一张图则+1，继续\r\n            num++;\r\n        }\r\n    },\r\n    fail: function (res) {\r\n        //失败回调\r\n    }\r\n});\r\n//下载图片2\r\nwx.getImageInfo({\r\n    src: image_2,\r\n    success: function (res) {\r\n        //判断是否是最后一张图\r\n        if (num >= 2) {\r\n            console.log(\"图片全部下载完毕，可以绘制海报\")\r\n        } else {\r\n            //如果不是最后一张图则+1，继续\r\n            num++;\r\n        }\r\n    }\r\n});\r\n......\r\n复制代码这里 智库君 一开始是使用promise的同步办法，但是发现3张图片 阻塞严重 ，如果一张图片 下载过慢 ，就会影响整个海报生成时间，所以可以改为添加 计数器 判断的异步方法。当海报生成需要多张图片的时候，完全可以异步的方式加载他们，通过计数器判断是否是最后一张。流程中断处理从图中可以看出，整个海报生成过程有二次授权： 用户信息授权获取头像 和 保存相册授权 ，非常可能因为用户的误点或者拒绝而导致流程中断。主要分为二种情况：需要的图片没有拿到，我们可以采取 使用默认图片 的方式替代。保存相册授权被拒绝，我们可以提示用户“截图保存”，由于当前版本6.7.2+的**wx.openSetting()**被限制（无法直接被调用），如果必须要相册权限，我们可以通过showModal触发。API/组件名称终端类型微信版本触发方法openSetting6.7.22.3.0showModal// 关于 openSetting 的调用方法\r\nwx.showModal({\r\n    title: '相册权限',\r\n    content: '需要你提供保存相册权限',\r\n    success: function (res) {\r\n        if (res.confirm) {\r\n            wx.openSetting({\r\n                success(settingdata) {\r\n                    console.log(settingdata)\r\n                    if (settingdata.authSetting['scope.writePhotosAlbum']) {\r\n                        console.log('获取 相册 权限成功，给出再次点击图片保存到相册的提示。');\r\n                    } else {\r\n                        console.log('获取 相册 权限失败，给出不给权限就无法正常使用的提示')\r\n                    }\r\n                }\r\n            })\r\n        }\r\n    }\r\n})\r\n\r\n//获取相册权限的流程处理\r\nwx.saveImageToPhotosAlbum({\r\n    filePath: res.tempFilePath,  //canvasToTempFilePath API生成的临时地址\r\n    success: function (data) {\r\n        console.log(\"提示图片保存成功\");\r\n    },\r\n    fail: function (err) {\r\n        console.log(err);\r\n        if (err.errMsg === \"saveImageToPhotosAlbum:fail auth deny\") {\r\n            console.log(\"当初用户拒绝，再次发起授权\")\r\n            //调用上面说到的方法  wx.openSetting\r\n        } else {\r\n            console.log(\"提示：请截屏保存分享\");\r\n        }\r\n    },\r\n    complete(res) {\r\n        console.log(res);\r\n    }\r\n})\r\n复制代码保存图片可被压缩小程序官方提供了一个API可以设置用户保存图片的质量， 仅针对JPG 。属性默认值说明最低版本quality1.0图片的质量，取值范围为 (0, 1]1.7.0wx.canvasToTempFilePath({\r\n    fileType: 'jpg',\r\n    canvasId: 'canvasId',\r\n    quality:0.8,  //设置JPG保存质量 80%\r\n    success: res => {\r\n    \r\n    },\r\n    fail:res => {\r\n    }\r\n}, this)\r\n复制代码官方说明： developers.weixin.qq.com/miniprogram…"}
{"title": "小程序中h5页面onShow实现及跨页面通信方案 ", "author": "2019-5-30 00:48", "pub_time": "2019-5-30 00:48", "content": "小程序webview的现状\r\nh5页面在小程序中的交互（跳转）场景\r\n\r\nh5跳转小程序native页面（如：调用小程序地址选择能力，然后返回对应的地址信息给h5页面）\r\nh5跳转己方业务线的h5页面（内部页面交互，方式比较多样）\r\nh5跳转其它业务线的h5页面（如：交易流程，相关页面可能有其他业务线提供）\r\n\r\n主要痛点\r\n\r\n在完成相关操作后，页面状态需要更新，目前常见的更新方式有如下两种：\r\n\r\n第一种：通过url传参（如：url中加入__isonshowrefresh=1，告诉webview再次onshow时候刷新），把需要传递的参数拼接到url中，重新打开url。\r\n第二种：需要跳转到新的页面进行数据更新（如：下单页 - 地址选择页 - 新的下单页）\r\n\r\n\r\n第一种方案，功能上没有问题，但会导致页面刷新，如果页面操作复杂，需要多次刷新\r\n第二种方案，正向操作时体验比方案一好，但导致了另外一个问题：操作跳转层级过深，尤其返回的时候简直让人崩溃。\r\n\r\n小程序中，h5页面打开新页面方式\r\n我们先来看下小程序中常见的h5跳h5的方式：\r\n\r\n方式1：直接用location.href跳转，返回时候各机型表现不一致，有的会刷页面，重新执行js，有的会直接展示之前的缓存\r\n方式2：通过路由hash跳转，返回触发hashchange，页面不刷新，js层面重现渲染\r\n方式3：跳转页面打开一个新的webview，相当于每个页面都是一个独立的webview\r\n\r\n我们采用的是方式3，理由如下：\r\n\r\n打开新页面时的效果更趋近于native间的跳转（当然新打开的页面也会重新加载静态资源，同时这也有另一个问题，一旦你打开10个层级后，再打开新的webview就没反应了，这个是小程序10层限制）\r\n返回的体验也更趋近于native，同时保证页面状态统一（不会出现有的直接展示，有的会重新执行js）\r\nwebview通过this.src拿到的链接即为当前页面链接，因为如果页面自行通过路由和location.href跳转，页面链接变更后，webview并不会知晓，这种方案，webview通过this.src拿到的链接始终是当前页面的链接。\r\n\r\n\r\n由于这种方案可能会达到小程序的10层限制。所以在一些重要页面建议加入“回到首页”的操作，通过这个操作来缩短小程序历史栈\r\n\r\n回到首页方案简述\r\n（如果不感兴趣这部分可以直接略过）\r\nwx.miniProgram.reLaunch({\r\n  url: '/pages/webview/bridge?url=项目首页地址'\r\n})\r\n复制代码先声明，我们webview的路径是/pages/webview/webview\r\n/pages/webview/bridge是个中转页，有如下特点：\r\n\r\n该页面并不是最终打开h5页面的webview页，而是一个中转页。\r\n主要用作返回处理\r\n页面逻辑：\r\n\r\n如果是第一次展示，则跳转/pages/webview/webview，同时把url传过去，正常打开h5\r\n如果不是第一次展示，说明是从webview返回过来的，直接重定向到小程序首页\r\n\r\n\r\n\r\n这个中转页：主要保证reLaunch到某h5页面后，用户仍然可以点击返回到小程序首页。\r\n该方案通常用于：小程序中内嵌了多个业务线的h5页面这种场景。\r\n一个内容发布场景\r\n我们从首页进入发布页，完成发布后，跳转至商品详情页\r\n那么对于一个新用户来讲，整个操作过程是这样的：\r\n\r\n首页（点击发布）\r\n进入发布页面（选择发布商品的分类）\r\n进入商品分类页（选择完成后）\r\n将分类id拼入url，进入新的发布页面（选取件地址）\r\n进入地址列表页（如果新用户是没有地址的，点击新增地址）\r\n进入新增地址页（添加完成后）\r\n将地址id拼如url，进入又一个新的发布页面（编辑完信息后点击发布）\r\n进入发布成功页（点击查看商品详情）\r\n进入商品详情页\r\n\r\n这个场景就是同一个页面，里面不同的内容项需要跳转不同的页面去操作，然后再回到原来页面更新状态的问题。\r\n假如商品详情页没有“回到首页”的入口，那么这个用户要想回到首页。。。需要按8次“返回” = =！\r\n经过这个体验后，我想一般的用户是没有勇气再发布内容的。\r\n\r\n当然也有另一种这种折中方案\r\n\r\n就是商品提到的，在连接中加入某个标志位，比如在url中加入__isonshowrefresh=1，webview在打开连接时候，会去读取这个参数，如果有，则每次在onShow时候，重新加载url，通过刷新页面进行页面状态更新。\r\n这个体验也不爽，就是在复杂的页面会多次刷新。\r\n声明\r\n我下面要讲的这个方案并不是停留在设想阶段，它已经在线上跑了\r\n想看效果的朋友，可以在微信小程序中搜：\r\n“转转二手交易网”-“0元免费领”-(底部)“送闲置赚星星”-进入到发布页后\r\n\r\n\r\n分类（跳转h5，选中内容后返回，将参数传给之前的h5）\r\n\r\n\r\n取件地址（跳转native原生地址选择，选中后返回，将参数传给之前的h5）\r\n\r\n\r\nOK，我们进入今天的主题\r\n小程序中h5页面onShow和跨页面通信的实现\r\n首先想到的就是onShow方法的实现，之前有人提议用visibilitychange来实现onShow方法。\r\n但调研过后，这种方式在ios中表现符合预期，但是在安卓手机里，是不能按预期触发的。所以该方案被我否了。\r\n于是就有了下面的方案\r\n原理介绍\r\n这个方案需要h5和小程序的webview都做处理。\r\n核心思想：利用webview的hash特性\r\n\r\n\r\n小程序通过hash传参，页面不会更新（这个和浏览器一样）\r\nh5可以通过hashchange捕获最新参数，进行自定义逻辑处理\r\n最后执行window.history.go(-1)\r\n\r\n\r\n为什么要执行window.history.go(-1)\r\n\r\n这一步是整个方案的精髓：\r\n\r\n因为hash变更会导致webview历史栈长度+1，用户需要多一次返回操作。但这一步明显是多余的。\r\n同时window.history.go(-1)后，会把webview在hash中添加的参数去掉，还能保证和之前的url一致。\r\n\r\n方案延伸（跨页面数据传递）\r\n小程序里另个一常见的场景就是调用第三业务（或者己方业务），在做完某些操作后需要把选中的数据带回之前的页面。\r\n\r\n如前面提到的例子：发布页，需要选择发布类型，然后返回，发布页发布类型局部更新\r\n\r\n当然有些同学会说：我可以用setInterval，监控localStorage。在新页面选中内容后，设置localStorage，然后在返回不就可以了。\r\n我这里说的是通用方案。如果页面都是由己方业务线维护的当然可以随便折腾。\r\n但是一旦涉及到第三方业务线，尤其不同域名页面的业务调用，这种通信方式就尴尬了。\r\n那我的方案怎么处理呢，我总结了一张图\r\n\r\n我们来解读一下这张图：\r\n\r\nwebview1打开发布页面，h5绑定hashchange事件（因为webview通过hash传值时会触发该事件）\r\n将自定义的onShow方法缓存。在hashchange触发时，寻找指定参数，如果存在则触发\r\n用户点击跳转到类型选择页\r\n这时会打开一个新的webview2页面实例，打开类型选择页\r\n用户操作完成，调用wx.miniProgram.postMessage把数据发送给webview，并返回\r\nwebview由于绑定了bindmessage事件，在返回时会接收到h5发送的数据\r\n同时将接收到的数据缓存在一个全局的store中，webview2销毁，小程序执行返回\r\n从webview2返回到webview1，这时webview1的onShow钩子会触发\r\nwebview1读取全局的store，将要发送的参数取出，拼接h5链接的hash部分，并重新打开该链接\r\n虽然重新打开链接，由于仅仅是hash部分的变化，所以页面不会刷新\r\n但会触发h5页面的hashchange，此时调用用户自定义的onShow方法，读取hash参数，进行页面更新\r\nh5页面在执行完onShow方法后，调用window.history.go(-1)，恢复历史栈\r\n\r\n整个过程就是这样\r\n代码示意：\r\n小程序\r\n小程序webview要先做几方面考虑：\r\n\r\n出于平滑接入的考虑，不能上来搞一刀切，要保证现有页面再不做任何修改的情况下继续访问。\r\n新能力要通过额外参数区分，如：检测url中的query部分，带有__isonshowpro=1再进行通过hash方式传参。\r\n改造原有逻辑，让__isonshowpro=1时，hash处理逻辑优先级最高\r\n参数定义，在前面加入了两个下划线，目的是为了分区url中正常的参数\r\n\r\n小程序端webview.wpy\r\n<web-view wx:if=\"{{url}}\" src=\"{{url}}\" binderror=\"onError\" bindload=\"onLoaded\" bindmessage=\"onPostMessage\"></web-view>\r\n\r\n// 链接处理工具方法\r\nimport util from '@/lib/util';\r\n// 全局数据存储操作类\r\nimport routeParams from '@/lib/routeParams';\r\nconst urlReg = /^(https?\\:\\/\\/[^?#]+)(\\?[^#]*)?(#[^\\?&]+)?(.+)?$/;\r\nlet messageData = {};\r\n\r\nexport default class extends wepy.page {\r\n  data = {\r\n    // 页面展示次数\r\n    pageShowCount: 0,\r\n    // 页面url中query部分的参数对象\r\n    mQuery: {},\r\n    ...\r\n  }\r\n  \r\n  onShow(){\r\n    ++this.pageShowCount;\r\n    // 获取其他页面经过操作后，需要传递给h5的参数\r\n    let data = routeParams.getBackFromData() || {};\r\n    // webview页面状态更新\r\n    if(this.pageShowCount > 1 && this.mQuery.__isonshowpro && this.mQuery.__isonshowpro === '1' || data.refresh){\r\n      // 获取需要传递给h5页面的参数\r\n      let refreshParam = data.refreshParam;\r\n      ...\r\n      // 如果连接中带有需要处理onShow逻辑的参数（通过url的hash和h5交互，而不是刷页面）\r\n      if (this.pageShowCount > 1 && this.mQuery.__isonshowpro === '1') {\r\n        let [whole, mainUrl, queryStr, hashStr, hashQueryStr] = urlReg.exec(this.url);\r\n        // 在url的hash中加入新的参数\r\n        hashStr = (hashStr || '#').substring(1);\r\n        if (refreshParam) {\r\n          delete refreshParam.refresh;\r\n        }\r\n        const messageData = this.getNavigateMessageData();\r\n        // 将需要更新的参数传给页面hash\r\n        hashStr = util.addQuery(hashStr, Object.assign({\r\n          // onshow标志位\r\n          __isonshow: 1,\r\n          // wa主动触发hashchange标志位\r\n          // 其实目前通过__isonshow就可以判断是wa主动触发hashchange\r\n          // 设置该字段是为了明确功能，且以后扩展用\r\n          __wachangehash: 1,\r\n          // 时间戳刷新\r\n          __hashtimestamp: Date.now()\r\n        }, messageData, refreshParam));\r\n        this.url = mainUrl + queryStr + '#' + hashStr;\r\n        console.log('【webview-hashchange-url】', this.url);\r\n        // 这里要加个延迟，否则在webview返回到webview时，无法触发hashchange，应该是小程序bug\r\n        setTimeout(()=> {\r\n          this.$apply();\r\n        }, 50);\r\n      // 通过修改query参数，刷新webview\r\n      } else {\r\n        ...\r\n      }\r\n      ...\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 获取需要发送的消息数据\r\n   */\r\n  getNavigateMessageData(){\r\n    let rst = {};\r\n    for(let i in messageData){\r\n      /* message结构:\r\n        message: {\r\n          key: 'xx',        // 消息名称\r\n          content: 'xx',    // 消息内容\r\n          trigger: {        // 触发条件\r\n            type: '',       // 触发类型 \r\n                               - immediately 在下一次onshow或者打开页面中立刻触发，\r\n                               - url 在找到指定h5链接时触发\r\n            content: ''     // 条件内容\r\n                               - type=immediately 时为空\r\n                               - type=url 时候为h5链接地址\r\n          }\r\n        }\r\n      */\r\n      const message = messageData[i];\r\n      const trigger = message.trigger || {};\r\n      // 立刻发送、路径触发\r\n      if(trigger.type === 'immediately' || trigger.type === 'url' && this.url.indexOf(trigger.content) > -1){\r\n        // 将key和content集合到一个对象中，便于hash直接设置\r\n        rst[message.key] = message.content;\r\n        // 消息通知后，从缓存中删除\r\n        delete messageData[message.key];\r\n      }\r\n    }\r\n    console.log('【webview-get-message】', rst);\r\n    console.log('【webview-message-cache】', messageData);\r\n    return rst;\r\n  }\r\n  \r\n  /**\r\n   * 存储消息数据\r\n   */\r\n  storeNavigateMessageData(message){\r\n    if(message && message.key){\r\n      console.log('【webview-store-message】', message)\r\n      // 通过key设置每一条消息名称\r\n      messageData[message.key] = message;\r\n      console.log('【webview-message-cache】', messageData);\r\n    }\r\n  }\r\n  \r\n  methods = {\r\n    // 接收发送过来的消息\r\n    onPostMessage(e){\r\n      if(!e.detail.data)return;\r\n      const detailData = e.detail.data;\r\n      // 获取消息数据\r\n      let messageData = getValueFromMixedArray(detailData, 'messageData', true);\r\n      if (messageData) {\r\n        // 存储\r\n        this.storeNavigateMessageData(messageData);\r\n      }\r\n      ...\r\n    }\r\n  }\r\n  \r\n  ...\r\n}\r\n复制代码上面东西看着挺多，总结下来就是几点：\r\n\r\n 绑定bindmessage事件\r\n接收到页面传来的消息之后，需要按照一定规则存起来（我是按照key存储的）\r\nwebview在触发onShow钩子时候，按照之前传过来的触发条件（condition），取出需要发送的消息数据\r\n将数据拼接到url的hash部分，并加入特有的标志位，重新加载url\r\n\r\nh5端\r\nh5端在做修改时也要考虑几点：\r\n\r\n\r\n最好能把这些交互逻辑封装起来\r\n\r\n\r\n让业务方比较简单方便的调用\r\n\r\n\r\n这里我新定义了2个方法\r\n\r\nonShow(callback)\r\n\r\n描述：这个和小程序onShow钩子一样，只不过是给h5调用的\r\n参数：callback 回调方法\r\n\r\n\r\n\r\n例子：发布页面，需要选择分类，返回时需要更新分类信息\r\nimport { isZZWA, onShow } from '@/lib/sdk'\r\nimport URL from '@/lib/url'\r\n\r\n...\r\ncreated () {\r\nif (isZZWA()) {\r\n  onShow(() => {\r\n  // 地址信息\r\n    const addressInfo = URL.getHashParam('zzwaAddress')\r\n      console.log('addressInfo:', decodeURIComponent(addressInfo))\r\n      ...\r\n      // 分类信息\r\n      const selecteCateInfo = URL.getHashParam('selecteCateInfo')\r\n      console.log('selecteCateInfo:', selecteCateInfo)\r\n      ...\r\n  } else {\r\n    ...\r\n  }\r\n}\r\n...\r\n复制代码\r\nserviceDone(data, condition)\r\n\r\n描述：业务结束，需要将数据传递给指定页面\r\n参数：\r\n\r\ndata Object 需要传递的数据 {key: 'xx', content: 'xx'}\r\ncondition String|Number 触发条件\r\n\r\nString 指定url的路径，当webview打开指定的url触发onshow时，会发送该消息\r\nNumber 返回到指定的测试，类似history.go(-1)，如： -1，-2\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n例子：类型选择页\r\nimport { isZZWA, serviceDone } from '@/lib/sdk'\r\n// 类型选择点击\r\ntypeChooseClick (param, type) {\r\n  ...\r\n  if (isZZWA()) {\r\n    // 需要返回的数据\r\n    const data = {\r\n      key: 'selecteCateInfo',\r\n      content: JSON.stringify({...})\r\n    }\r\n    // 通过postMessage发送给小程序，-1表示返回上一页面\r\n    serviceDone(data, -1)\r\n  } else {\r\n    ...\r\n  }  \r\n}\r\n复制代码\r\n\r\nok，我们来看看h5端的sdk是怎么实现的\r\nimport util from './util';\r\n\r\nclass WASDK {\r\n  /**\r\n   * Create a instance.\r\n   * @ignore\r\n   */\r\n  constructor(){\r\n    // hashchang事件处理\r\n    if('onhashchange' in window && window.addEventListener && !WASDK.hashInfo.isInit){\r\n      // 更新标志位\r\n      WASDK.hashInfo.isInit = true;\r\n      // 绑定hashchange\r\n      window.addEventListener('hashchange', ()=>{\r\n        // 如果小程序webview修改的hash，才进行处理\r\n        if (util.getHash(window.location.href, '__wachangehash') === '1') {\r\n          // 这块有个坑：\r\n          // ios小程序webview在修改完url的hash之后，页面hashchange和更新都可以正常触发\r\n          // 但是：h5调用部分小程序能力会失败(如：ios在设置完hash后，调用wx.uploadImg会失败，需要重新设置wx.config)\r\n          // 因为ios小程序的逻辑是，url只要发生变化，wx.config中的appId就找不到了\r\n          // 所以需要重新进行wx.config配置\r\n          // 这一步是获取之前设置wx.config的参数（需要从服务端拿，因为之前已经获取过了，这里从缓存直接取）\r\n          const jsticket = window.native && window.native.adapter && window.native.adapter.jsticket || null;\r\n          const ua = navigator.userAgent;\r\n          // 非安卓系统要重新设置wx.config\r\n          if (jsticket && !(ua.indexOf('Android') > -1 || ua.indexOf('Adr') > -1)) {\r\n            window.wx.config({\r\n              debug: false,\r\n              appId: jsticket.appId,\r\n              timestamp: jsticket.timestamp,\r\n              nonceStr: jsticket.noncestr,\r\n              signature: jsticket.signature,\r\n              jsApiList: ['onMenuShareTimeline', 'onMenuShareAppMessage', 'onMenuShareQQ',\r\n                'onMenuShareQZone', 'onMenuShareWeibo', 'scanQRCode', 'chooseImage', 'uploadImage', 'previewImage', 'getLocation', 'openLocation']\r\n            })\r\n          }\r\n          // 触发缓存数组的回调\r\n          WASDK.hashInfo.callbackArr.forEach(callback=>{\r\n            callback();\r\n          })\r\n          // 执行返回操作（这一步是重点！！）\r\n          // 因为webview设置完hash参数后，会使webview历史栈+1\r\n          // 而实际并不需要这次多余的历史记录，所以需要执行返回操作把它去掉\r\n          // 即便是返回操作，也仅仅是hash层面的变更，所以不会触发页面刷新\r\n          // 用setTimeout表示在下一次事件循环进行返回操作。如果后面有对dom操作可以在当前次事件循环完成\r\n          setTimeout(()=>{\r\n            window.history.go(-1);\r\n          }, 0);\r\n        }\r\n      }, false)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * hash相关信息\r\n   */\r\n  static hashInfo = {\r\n    // 是否已经初始化\r\n    isInit: false,\r\n    // hash回调香瓜数组\r\n    callbackArr: []\r\n  }\r\n  \r\n  /**\r\n   * 页面再次展示时钩子方法\r\n   * @param {Function} callback - 必填, callback回调方法, 回传参数为hash部分问号后面的参数解析对象\r\n   */\r\n  @execLog\r\n  onShow(callback){\r\n    if (typeof callback === 'function') {\r\n      // 对回调方法进行onshow逻辑包装，并推入缓存数组\r\n      WASDK.hashInfo.callbackArr.push(function(){\r\n        // 检查是否是指定参数发生变化\r\n        if(util.getHash(window.location.href, '__isonshow') === '1'){\r\n          // 触发onShow回调\r\n          callback();\r\n        }\r\n      })\r\n    } else {\r\n      util.console.error(`参数错误，调用onShow请传入正确callback回调`);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 业务处理完成并发送消息\r\n   * @param {Object}           obj - 必填项，消息对象\r\n   * @param {String}           obj.key - 必填项，消息名称\r\n   * @param {String}           obj.content - 可选项，消息内容，默认空串，如果是内容对象，请转换成字符串\r\n   * @param {String|Number}    condition - 可选项，默认仅进行postMessage\r\n   *                              String - 可以传指定url的路径，当小程序webview打开指定的url或者onshow时，会触发该消息\r\n   *                                       也可传小程序path，这个为以后预留\r\n   *                              Number - 返回到指定的测试，类似history.go(-1)，如： -1，-2\r\n   */\r\n  @execLog\r\n  serviceDone(obj, condition){\r\n    if(obj && obj.key){\r\n      // 消息体\r\n      const message = {\r\n        // 消息名称\r\n        key: obj.key,\r\n        // 消息体\r\n        content: obj.content || '',\r\n        // 触发条件\r\n        trigger: {\r\n          // 类型 'immediately'在下一次onshow中立刻触发， 'url'，在找到指定h5链接时触发，'path'在打开指定小程序路径时触发\r\n          type: 'immediately',\r\n          // 条件内容，immediately是为空，url是为h5链接地址，path是为小程序路径\r\n          content: ''\r\n        }\r\n      };\r\n      // 解析触发条件\r\n      condition = condition || 0;\r\n      // 如果是路径\r\n      if(typeof condition === 'string' && (condition.indexOf('http') > -1 || condition.indexOf('pages/') > -1)){\r\n        // 设置消息触发条件\r\n        message.trigger = {\r\n          type: condition.indexOf('http') > -1 ? 'url' : 'path',\r\n          content: condition\r\n        }\r\n      }\r\n      // 发送消息\r\n      wx.miniProgram.postMessage({\r\n        data: {\r\n          messageData: message\r\n        }\r\n      });\r\n      // 如果不是url或者path触发，则对conditon是否需要返回进行判断\r\n      if(message.trigger.type === 'immediately'){\r\n        // 查看是否需要返回指定的层级，兼容传入'-1'字符串这种类型的场景\r\n        try{\r\n          condition = parseInt(condition, 10);\r\n        }catch(e){}\r\n        // 保证返回级数的正确性\r\n        if(condition && typeof condition === 'number' && !isNaN(condition)){\r\n          this.handler.navigateBack({delta: Math.abs(condition)});\r\n        }\r\n      }\r\n    }else{\r\n      util.console.error(`参数错误，调用serviceDone方法，传入的对象中不包含key值`);\r\n    }\r\n  }\r\n  \r\n  ...\r\n}\r\n\r\nwindow.native = new Native();\r\n\r\nexport default native;\r\n\r\n复制代码这个看着也挺多，总结下来是两点：\r\n\r\nonShow方法的实现\r\n\r\n绑定一个hashchange事件（这里做了防止重复绑定事件的处理）\r\n将传入的onShow自定义事件缓存在一个数组中，hashchange触发时，根据特有的标志位__isonshow和__wachangehash确定是否触发\r\n\r\n\r\nserviceDone方法的实现\r\n\r\n处理传过来的数据\r\n处理该数据的触发条件：immediately表示最近的一次onShow触发，或者自己指定url\r\n通过wx.miniProgram.postMessage发送数据\r\n\r\n\r\n\r\nok，整个方案就介绍完了\r\n结语\r\n最早的方案并不完全是这样的，但原理是一样的。在我实现的过程中发现原始方案有很多问题\r\n于是我又做了大量的改造和细节优化，于是形成了上面的最终方案。\r\n这个方案属于侵入式改造方案，需要各业务方改造自己的代码。虽然有一定改造成本，但用户体验的收益非常明显。\r\nps：我们的QA在测试时都说“这用起来就爽多了”\r\n注意：\r\n采用这个方案需要注意几点：\r\n\r\n如果采用这种方式通信，需要在当前页面url的query部分加入__isonshowpro=1，否则是不会通过hash通信的\r\n同时要保证页面确实调用了onShow方法，否则页面也是不会刷新的\r\n如果第三方业务需要传值，需要统一采用serviceDone方法通信\r\n\r\n好了，今天就介绍这么多，大家一起学习"}
{"title": "小程序命名规范大调整，现在不能这样取名了 ", "author": "2019-5-30 00:56", "pub_time": "2019-5-30 00:56", "content": "上周，微信开放社区公布了小程序名称规则调整的公告，主要是针对之前一些投机的取名做法罗列了调整和优化建议，调整后的命名规范比之前更加严格。小程序的价值在于提供服务，平台也是希望小程序名称等的信息能够具有准确性和独特性，减少误导、混淆用户理解的可能性。这些调整规范也可以总结为“五不一建议”：01 不得使用违反广告法等禁止的用语Eg. 国家级、世界级、最高级、最佳、第一、唯一、首个、最好、精确、顶级、最低、最底、最便宜、最大程度、最新技术、最先进科学、国家级产品、填补国内空白、绝对、独家、首家、最新、最先进、第一品牌、金牌、名牌、最赚、超赚、最先、巨星、奢侈、至尊、顶级享受02 不得使用营销味重的商业化用语Eg. 免费、促销、清仓、打折、免单广告法禁用语和商业化用语往往自带夸大的表达效果，会对用户产生误导。03 不得混用热门公众号、小程序或第三方品牌名称蹭热门应用、小程序或第三方知名品牌名称一直是某些小程序增加曝光的途径，这也会导致用户用错小程序，带来时间和精力上的浪费。在新的规则规范下，这类做法将被禁止，除非已获授权。04 不建议使用广义归纳类的词汇直接使用这类词汇，缺乏显著性，也会给用户带来无法识别、区分小程序的困扰。05 不建议使用关键词堆砌过于冗长的关键词堆砌名称是为了能够在搜索结果上获得更多的曝光，但这并不利于品牌记忆的建立以及用户的理解。应对方法：可将小程序有关的关键词放入功能介绍，达到关键词搜索优化的目的。06 建议在名称信息上包含品牌信息这种名称具有辨识度，也便于用户识别。小程序正确的名称公式：品牌+产品类别名/产品名这些调整从表面看是为了提升用户体验，那对开发者而言，这么严格的规范究竟是好还是坏呢？命名审核虽然在短期会给开发者造成一定的麻烦，但从长期看来，这是保障开发者权益的举措。以小游戏为例，开发者辛苦打造了一个爆款出来，结果被抄袭又名称相似的小游戏瓜分了流量。但现在在这个命名规范的限制下，以下情况将会大大减少。同时，开发者通过现有的小程序与用户建立了品牌偏好，在新的小程序推出时能够形成小程序矩阵，也可以降低宣传成本。微信平台这次调整，其实是在强调“品牌”，目的是让用户通过使用小程序，接受并建立对开发者产品品牌的认知，这样也有利于开发者产品的长远发展。特别注意对于调整规范发布前已经通过审核的小程序，开发者也不要掉以轻心，近期平台可能将对名称重新审核，所以请提前自查，做好准备。"}
{"title": "微信严控学习类产品“打卡” ", "author": "2019-5-14 00:00", "pub_time": "2019-5-14 00:00", "content": "题图来源：视觉中国钛媒体快讯 | 5月13日消息：今天，微信安全中心公众号发布《关于利诱分享朋友圈打卡的处理公告》，整顿朋友圈诱导分享行为，认为其是非正常营销，严重影响朋友圈阅读体验。这些分享行为主要集中在某些公众号、APP软件等主体，他们通过以返学费、送实物等方式，利诱微信用户分享其链接（包括二维码图片等）到朋友圈打卡。微信方面表示，一经发现，微信团队将进行如下处理：包括但不限于停止链接内容在朋友圈继续传播、停止对相关域名或IP地址进行访问，封禁相关开放平台帐号或应用的分享接口；对重复多次违规及对抗行为的违规主体，将采取阶梯式处理机制，包括但不限于下调每日分享限额、限制使用微信登录功能接口、永久封禁帐号、域名、IP地址或分享接口；对涉嫌使用微信外挂并通过微信群实施诱导用户分享的个人帐号，将根据违规严重程度对该微信帐号进行阶梯式处罚。值得注意的是，钛媒体发现，在部分违规公式案例公式中，微信选择了四款产品均属于教育类产品，分别是流利阅读（流利说旗下产品）、火箭单词、轻课和薄荷阅读。微信官方这则公告一发布，立马引起教育圈内的躁动和讨论。一位从事在线教育的高管告诉钛媒体，其所加入大部分微信群都在转发这则公告，并且表示会对当前大部分在线教育公司的营销模式造成影响。对于被微信方面公开点名批评，钛媒体向流利说方面求证。对方表示，已经知悉公告，并且尊重并理解微信方面的治理。与此同时，流利说也对“流利阅读”打卡返款条件作出一定的修改。但是，流利说也不认可“打卡”是一种利诱分享的行为。该公司表示，“流利阅读”从未以任何形式要求用户通过朋友圈帮助获客。“发朋友圈”只是流利阅读作为教育产品，希望用户坚持使用“打卡”动作的重要一环，并非“利诱”，而是希望用户可以在大家的监督下养成坚持学习的习惯。实际上，利用微信流量池鼓励学员朋友圈打卡，一直是在线教育类产品的营销利器。比如说，流利说就推出了“199元100天打卡80天返费”的项目。这不仅可以从微信上获得更多流量，还是提升用户活跃度一大法宝。而对于部分用户而言，通过朋友圈打开“打卡”，尤其是学习类产品的打卡，在从平台获取薄利、监督学习进度的同时，还可以营造出一种积极向上的社交形象。但是，显然日活已过10亿的微信，已经不希望再被各方薅走流量的“羊毛”。微信早已出台《微信外部链接内容管理规范》禁止通过利益诱惑，诱导用户分享、传播外链内容或者微信公众帐号文章，这一次微信针对教育行业加大关注明确处罚力度。可以预见的是，这无疑对于依靠线上渠道裂变招生的教培公司是一记重拳。或许，微信朋友圈“整顿”可能只是个开始，今后他们不得不调整营销策略，以应对各大平台的“流量管控”。（本文首发钛媒体，作者/李程程）以下是流利说回应原文：尊敬的媒体老师，亲爱的产品用户：感谢各位对于流利说旗下产品“流利阅读”的关心。针对5月13日微信官方账号“微信安全中心”发出的《关于利诱分享朋友圈打卡的处理公告》，我们做如下说明：1、微信官方的公告已收悉，内部调整已经启动。我们尊重并理解微信官方在平台治理上做出的努力；2、“流利阅读”从未以任何形式要求用户通过朋友圈帮助获客。“发朋友圈”只是流利阅读作为教育产品，希望用户坚持使用“打卡”动作的重要一环，并非“利诱”，而是希望用户可以在大家的监督下养成坚持学习的习惯；3、“流利阅读”一直以来希望为用户提供优质的学习内容，因此，我们的分享内容也不以销售为目的；4、有鉴于以上三点，为了体现我们对于“用户第一”的坚持，我们决定从即日起，对于“流利阅读”打卡返费条款做如下调整：A、即日起，仍在参与原“199元100天打卡80天返费”课程的用户，无需朋友圈打卡，只需要每天完成当日课程，100天内坚持80天，即可获得全额奖学金；B、用户仍可自愿在朋友圈打卡，但不打卡不会对奖学金有任何影响；C、未来购买此课程的用户，朋友圈打卡不会对返费产生任何影响；最后，对于“流利阅读”的各位用户，我们作为服务提供方向因此受到困扰的用户表示抱歉。本次微信平台的处理针对产品运营方。请各位用户放心，我们已和微信官方进行过确认，已经使用“流利阅读”在微信朋友圈的打卡不会对个人用户造成任何不良影响。流利阅读团队2019年5月13日"}
{"title": "从 VantComponent 谈 小程序维护 ", "author": "2019-5-14 00:45", "pub_time": "2019-5-14 00:45", "content": "在开发小程序的时候，我们总是期望用以往的技术规范和语法特点来书写当前的小程序，所以才会有各色的小程序框架，例如 mpvue、taro 等这些编译型框架。当然这些框架本身对于新开发的项目是有所帮助。而对于老项目，我们又想要利用 vue 的语法特性进行维护，又该如何呢？\r\n在此我研究了一下youzan的 vant-weapp。而发现该项目中的组件是如此编写的。\r\nimport { VantComponent } from '../common/component';\r\n\r\nVantComponent({\r\n  mixins: [],\r\n  props: {\r\n    name: String,\r\n    size: String\r\n  },\r\n  // 可以使用 watch 来监控 props 变化\r\n  // 其实就是把properties中的observer提取出来\r\n  watch: {\r\n    name(newVal) {\r\n       ...\r\n    },\r\n    // 可以直接使用字符串 代替函数调用\r\n    size: 'changeSize'\r\n  },\r\n  // 使用计算属性 来 获取数据，可以在 wxml直接使用\r\n  computed: {\r\n    bigSize() {\r\n      return this.data.size + 100\r\n    }\r\n  }，\r\n  data: {\r\n    size: 0\r\n  },\r\n  methods: {\r\n    onClick() {\r\n      this.$emit('click');\r\n    },\r\n    changeSize(size) {\r\n       // 使用set\r\n       this.set(size)\r\n    }\r\n  },\r\n\r\n  // 对应小程序组件 created 周期\r\n  beforeCreate() {},\r\n\r\n  // 对应小程序组件 attached 周期\r\n  created() {},\r\n\r\n  // 对应小程序组件 ready 周期\r\n  mounted() {},\r\n\r\n  // 对应小程序组件  detached 周期\r\n  destroyed: {}\r\n});\r\n复制代码居然发现该组件写法整体上类似于 Vue 语法。而本身却没有任何编译。看来问题是出在了导入的 VantComponet 这个方法上。下面我们开始详细介绍一下如何利用 VantComponet 来对老项目进行维护。\r\nTLDR (不多废话，先说结论)\r\n小程序组件写法这里就不再介绍。这里我们给出利用 VantComponent 写 Page 的代码风格。\r\nimport { VantComponent } from '../common/component'; \r\n\r\nVantComponent({\r\n  mixins: [],\r\n  props: {\r\n    a: String,\r\n    b: Number\r\n  },\r\n  // 在页面这里 watch 基本上是没有作用了，因为只做了props 变化的watch，page不会出现 props 变化\r\n  // 后面会详细说明为何\r\n  watch： {},\r\n  // 计算属性仍旧可用\r\n  computed: {\r\n    d() {\r\n      return c++\r\n    }\r\n  },\r\n  methods: {\r\n    onLoad() {}\r\n  },\r\n  created() {},\r\n  // 其他组件生命周期\r\n})\r\n复制代码这里你可能感到疑惑，VantComponet 不是对组件 Component 生效的吗？怎么会对页面 Page 生效呢。事实上，我们是可以使用组件来构造小程序页面的。\r\n在官方文档中，我们可以看到 使用 Component 构造器构造页面\r\n事实上，小程序的页面也可以视为自定义组件。因而，页面也可以使用 Component 构造器构造，拥有与普通组件一样的定义段与实例方法。代码编写如下:\r\nComponent({\r\n    // 可以使用组件的 behaviors 机制,虽然 React 觉得 mixins 并不是一个很好的方案\r\n    // 但是在某种程度该方案的确可以复用相同的逻辑代码\r\n    behaviors: [myBehavior],\r\n   \r\n    // 对应于page的options，与此本身是有类型的，而从options 取得数据均为 string类型\r\n    // 访问 页面 /pages/index/index?paramA=123&paramB=xyz \r\n    // 如果声明有属性 paramA 或 paramB ，则它们会被赋值为 123 或 xyz，而不是 string类型\r\n    properties: {\r\n        paramA: Number,\r\n        paramB: String,\r\n    },\r\n    methods: {\r\n        // onLoad 不需要 option\r\n        // 但是页面级别的生命周期却只能写道 methods中来\r\n        onLoad() {\r\n            this.data.paramA // 页面参数 paramA 的值 123\r\n            this.data.paramB // 页面参数 paramB 的值 ’xyz’\r\n        }\r\n    }\r\n\r\n})\r\n复制代码那么组件的生命周期和页面的生命周期又是怎么对应的呢。经过一番测试，得出结果为： (为了简便。只会列出 重要的的生命周期)\r\n// 组件实例被创建 到 组件实例进入页面节点树\r\ncomponent created -> component attched -> \r\n// 页面页面加载 到  组件在视图层布局完成\r\npage onLoad -> component ready -> \r\n// 页面卸载 到 组件实例被从页面节点树移除\r\npage OnUnload -> component detached\r\n复制代码当然 我们重点不是在 onload 和 onunload 中间的状态，因为中间状态的时候，我们可以在页面中使用页面生命周期来操作更好。\r\n某些时候我们的一些初始化代码不应该放在 onload 里面，我们可以考虑放在 component create 进行操作，甚至可以利用 behaviors 来复用初始化代码。\r\n某种方面来说，如果不需要 Vue 风格，我们在老项目中直接利用 Component 代替 Page 也不失为一个不错的维护方案。毕竟官方标准，不用担心其他一系列后续问题。\r\nVantComponent 源码解析\r\nVantComponent\r\n此时，我们对 VantComponent 开始进行解析\r\n// 赋值，根据 map 的 key 和 value 来进行操作\r\nfunction mapKeys(source: object, target: object, map: object) {\r\n  Object.keys(map).forEach(key => {\r\n    if (source[key]) {\r\n      // 目标对象 的 map[key] 对应 源数据对象的 key\r\n      target[map[key]] = source[key];\r\n    }\r\n  });\r\n}\r\n\r\n// ts代码，也就是 泛型\r\nfunction VantComponent<Data, Props, Watch, Methods, Computed>(\r\n  vantOptions: VantComponentOptions<\r\n    Data,\r\n    Props,\r\n    Watch,\r\n    Methods,\r\n    Computed,\r\n    CombinedComponentInstance<Data, Props, Watch, Methods, Computed>\r\n  > = {}\r\n): void {\r\n  const options: any = {};\r\n  // 用function 来拷贝 新的数据，也就是我们可以用的 Vue 风格\r\n  mapKeys(vantOptions, options, {\r\n    data: 'data',\r\n    props: 'properties',\r\n    mixins: 'behaviors',\r\n    methods: 'methods',\r\n    beforeCreate: 'created',\r\n    created: 'attached',\r\n    mounted: 'ready',\r\n    relations: 'relations',\r\n    destroyed: 'detached',\r\n    classes: 'externalClasses'\r\n  });\r\n\r\n  // 对组件间关系进行编辑，但是page不需要，可以删除\r\n  const { relation } = vantOptions;\r\n  if (relation) {\r\n    options.relations = Object.assign(options.relations || {}, {\r\n      [`../${relation.name}/index`]: relation\r\n    });\r\n  }\r\n\r\n  // 对组件默认添加 externalClasses，但是page不需要，可以删除\r\n  // add default externalClasses\r\n  options.externalClasses = options.externalClasses || [];\r\n  options.externalClasses.push('custom-class');\r\n\r\n  // 对组件默认添加 basic，封装了 $emit 和小程序节点查询方法，可以删除\r\n  // add default behaviors\r\n  options.behaviors = options.behaviors || [];\r\n  options.behaviors.push(basic);\r\n\r\n  // map field to form-field behavior\r\n  // 默认添加 内置 behavior  wx://form-field\r\n  // 它使得这个自定义组件有类似于表单控件的行为。\r\n  // 可以研究下文给出的 内置behaviors\r\n  if (vantOptions.field) {\r\n    options.behaviors.push('wx://form-field');\r\n  }\r\n\r\n  // add default options\r\n  // 添加组件默认配置，多slot\r\n  options.options = {\r\n    multipleSlots: true,// 在组件定义时的选项中启用多slot支持\r\n    // 如果这个 Component 构造器用于构造页面 ，则默认值为 shared\r\n    // 组件的apply-shared，可以研究下文给出的 组件样式隔离\r\n    addGlobalClass: true \r\n  };\r\n\r\n  // 监控 vantOptions\r\n  observe(vantOptions, options);\r\n\r\n  // 把当前重新配置的options 放入Component\r\n  Component(options);\r\n}\r\n复制代码内置behaviors\r\n组件样式隔离\r\nbasic behaviors\r\n刚刚我们谈到 basic behaviors，代码如下所示\r\nexport const basic = Behavior({\r\n  methods: {\r\n    // 调用 $emit组件 实际上是使用了 triggerEvent\r\n    $emit() {\r\n      this.triggerEvent.apply(this, arguments);\r\n    },\r\n\r\n    // 封装 程序节点查询\r\n    getRect(selector: string, all: boolean) {\r\n      return new Promise(resolve => {\r\n        wx.createSelectorQuery()\r\n          .in(this)[all ? 'selectAll' : 'select'](selector)\r\n          .boundingClientRect(rect => {\r\n            if (all && Array.isArray(rect) && rect.length) {\r\n              resolve(rect);\r\n            }\r\n\r\n            if (!all && rect) {\r\n              resolve(rect);\r\n            }\r\n          })\r\n          .exec();\r\n      });\r\n    }\r\n  }\r\n});\r\n复制代码observe\r\n小程序 watch 和 computed的 代码解析\r\nexport function observe(vantOptions, options) {\r\n  // 从传入的 option中得到 watch computed  \r\n  const { watch, computed } = vantOptions;\r\n\r\n  // 添加  behavior\r\n  options.behaviors.push(behavior);\r\n\r\n  /// 如果有 watch 对象\r\n  if (watch) {\r\n    const props = options.properties || {};\r\n    // 例如: \r\n    // props: {\r\n    //   a: String\r\n    // },\r\n    // watch: {\r\n    //   a(val) {\r\n    //     // 每次val变化时候打印\r\n    //     consol.log(val)\r\n    //   }\r\n    } \r\n    Object.keys(watch).forEach(key => {\r\n      \r\n      // watch只会对prop中的数据进行 监视\r\n      if (key in props) {\r\n        let prop = props[key];\r\n        if (prop === null || !('type' in prop)) {\r\n          prop = { type: prop };\r\n        }\r\n        // prop的observer被watch赋值，也就是小程序组件本身的功能。\r\n        prop.observer = watch[key];\r\n        // 把当前的key 放入prop\r\n        props[key] = prop;\r\n      }\r\n    });\r\n    // 经过此方法\r\n    // props: {\r\n    //  a: {\r\n    //    type: String,\r\n    //    observer: (val) {\r\n    //      console.log(val)\r\n    //    }\r\n    //  }\r\n    // }\r\n    options.properties = props;\r\n  }\r\n\r\n  // 对计算属性进行封装\r\n  if (computed) {\r\n    options.methods = options.methods || {};\r\n    options.methods.$options = () => vantOptions;\r\n\r\n    if (options.properties) {\r\n      \r\n      // 监视props，如果props发生改变，计算属性本身也要变\r\n      observeProps(options.properties);\r\n    }\r\n  }\r\n}\r\n复制代码observeProps\r\n现在剩下的也就是 observeProps 以及 behavior 两个文件了，这两个都是为了计算属性而生成的，这里我们先解释 observeProps 代码\r\nexport function observeProps(props) {\r\n  if (!props) {\r\n    return;\r\n  }\r\n\r\n  Object.keys(props).forEach(key => {\r\n    let prop = props[key];\r\n    if (prop === null || !('type' in prop)) {\r\n      prop = { type: prop };\r\n    }\r\n\r\n    // 保存之前的 observer，也就是上一个代码生成的prop\r\n    let { observer } = prop;\r\n    prop.observer = function() {\r\n      if (observer) {\r\n        if (typeof observer === 'string') {\r\n          observer = this[observer];\r\n        }\r\n\r\n        // 调用之前保存的 observer\r\n        observer.apply(this, arguments);\r\n      }\r\n\r\n      // 在发生改变的时候调用一次 set 来重置计算属性\r\n      this.set();\r\n    };\r\n    // 把修改的props 赋值回去\r\n    props[key] = prop;\r\n  });\r\n}\r\n复制代码behavior\r\n最终 behavior，也就算 computed 实现机制\r\n\r\n// 异步调用 setData\r\nfunction setAsync(context: Weapp.Component, data: object) {\r\n  return new Promise(resolve => {\r\n    context.setData(data, resolve);\r\n  });\r\n};\r\n\r\nexport const behavior = Behavior({\r\n  created() {\r\n    if (!this.$options) {\r\n      return;\r\n    }\r\n\r\n    // 缓存\r\n    const cache = {};\r\n    const { computed } = this.$options();\r\n    const keys = Object.keys(computed);\r\n\r\n    this.calcComputed = () => {\r\n      // 需要更新的数据\r\n      const needUpdate = {};\r\n      keys.forEach(key => {\r\n        const value = computed[key].call(this);\r\n        // 缓存数据不等当前计算数值\r\n        if (cache[key] !== value) {\r\n          cache[key] = needUpdate[key] = value;\r\n        }\r\n      });\r\n      // 返回需要的更新的 computed\r\n      return needUpdate;\r\n    };\r\n  },\r\n\r\n  attached() {\r\n    // 在 attached 周期 调用一次，算出当前的computed数值\r\n    this.set();\r\n  },\r\n\r\n  methods: {\r\n    // set data and set computed data\r\n    // set可以使用callback 和 then\r\n    set(data: object, callback: Function) {\r\n      const stack = [];\r\n      // set时候放入数据\r\n      if (data) {\r\n        stack.push(setAsync(this, data));\r\n      }\r\n\r\n      if (this.calcComputed) {\r\n        // 有计算属性，同样也放入 stack中，但是每次set都会调用一次，props改变也会调用\r\n        stack.push(setAsync(this, this.calcComputed()));\r\n      }\r\n\r\n      return Promise.all(stack).then(res => {\r\n        // 所有 data以及计算属性都完成后调用callback\r\n        if (callback && typeof callback === 'function') {\r\n          callback.call(this);\r\n        }\r\n        return res;\r\n      });\r\n    }\r\n  }\r\n});\r\n复制代码写在后面\r\n\r\n\r\njs 是一门灵活的语言(手动滑稽)\r\n\r\n\r\n本身 小程序 Component 在 小程序 Page 之后，就要比Page 更加成熟好用，有时候新的方案往往藏在文档之中，每次多看几遍文档绝不是没有意义的。\r\n\r\n\r\n小程序版本 版本2.6.1 Component  目前已经实现了 observers，可以监听 props data 数据监听器,目前 VantComponent没有实现，当然本身而言，Page 不需要对 prop 进行监听，因为进入页面压根不会变，而data变化本身就无需监听，直接调用函数即可，所以对page而言，observers 可有可无。\r\n\r\n\r\n该方案也只是对 js 代码上有vue的风格，并没在 template 以及 style 做其他文章。\r\n\r\n\r\n该方案性能一定是有所缺失的，因为computed是每次set都会进行计算，而并非根据set 的 data 来进行操作，在删减之后我认为本身是可以接受。如果本身对于vue的语法特性需求不高，可以直接利用 Component 来编写 Page，选择不同的解决方案实质上是需要权衡各种利弊。如果本身是有其他要求或者新的项目，仍旧推荐使用新技术，如果本身是已有项目并且需要维护的，同时又想拥有 Vue 特性。可以使用该方案，因为代码本身较少，而且本身也可以基于自身需求修改。\r\n\r\n\r\n同时，vant-weapp是一个非常不错的项目，推荐各位可以去查看以及star。"}
{"title": "小程序开发前的准备工作之【深入封装Component】 ", "author": "2019-5-14 00:50", "pub_time": "2019-5-14 00:50", "content": "在上一篇内容中主要总结了如何扩展小程序中的Page与Component函数，在开发过程中减少包的引入，这一篇则深入总结小程序自定义组件Component函数还有哪些可以进一步扩展的地方【demo地址】。优化点：优化组件定义默认值时声明的写法自定义watch函数监听全部参数变化编写小程序自定义组件时 你是否是这样？Component({\r\n  properties: {\r\n    num: {\r\n        type: Number,\r\n        value: 2\r\n    },\r\n    name: {\r\n        type: String,\r\n        value: \"abcdef...\"\r\n    },\r\n    test: Object // 即使没有默认值也要写上数据类型\r\n  },\r\n  methods: {\r\n    //...\r\n  }\r\n})\r\n复制代码我还是比较喜欢像【data】对象初始化时的写法:arrow_heading_down:Component({\r\n  props: {\r\n    num: 2,\r\n    name: 'abcdef...',\r\n    test: {}\r\n  },\r\n  methods: {\r\n    //...\r\n  }\r\n})\r\n复制代码开始改造properties：既然我们已经可以重写Component函数了，那就有办法把这个数据【转换】成我们要的那种结构格式，打开Init.js Component函数部分实现的步骤大概是：取到参数内名为props的对象 -> 获取每一个数据类型 -> 还原成小程序原来的数据格式 -> 重新赋值给properties// 优化 properties 传入方式\r\nlet originComponent = Component;\r\nComponent = (opt) => {\r\n  let { props = {} } = opt;\r\n  let properties = {};\r\n  // 获取自定义关键字【props】中的每一项\r\n  Object.keys(props).forEach(item => {\r\n    // 重新还原成原有数据格式\r\n    properties[item] = {\r\n      type: getValueType(props[item]), // 获取数据格式\r\n      value: props[item]\r\n    }\r\n  });\r\n  opt.properties = properties; // 还给properties...\r\n  //...\r\n  return originComponent(opt)\r\n}\r\n\r\n\r\n/**\r\n * 获取数据类型\r\n * @param value\r\n * @returns {*}\r\n */\r\nfunction getValueType(value) {\r\n  if (typeof value === 'number') return Number;\r\n  if (typeof value === 'string') return String;\r\n  if (typeof value === 'boolean') return Boolean;\r\n\r\n  if (value instanceof Object && !value instanceof Array) return Object;\r\n  if (value instanceof Array) return Array;\r\n\r\n  return null;\r\n}\r\n复制代码组件声明默认数据格式的修改就弄好了，其实这个东西并没有对开发上起到多么明显的优化，无非就是少写几个字而已，但是以此demo 还可以扩展出更多功能。监听组件传入参数变化小程序自定义组件的传入数据上可以声明observer监听器属性，用来监听数据变化:arrow_heading_down:Component({\r\n  properties: {\r\n    num: {\r\n        type: Number,\r\n        value: 2,\r\n        observer (newVal, oldVal, changedPath) {\r\n            //...\r\n        }\r\n    },\r\n  },\r\n  methods: {\r\n    //...\r\n  }\r\n})\r\n复制代码其中observer接收的参数分别是newVal[改变的参数]、oldVal[改变之前的参数]、changedPath[具体改变的参数的key]默认要监听某个参数的时候，都是需要写在具体参数的对象内的，并且每个要监听的数据都要声明observer函数，通过改造后 可以统一监听数据变动:arrow_heading_down:Component({\r\n  props: {\r\n    num: 2,\r\n    name: 'abcdefg....',\r\n  },\r\n  methods: {\r\n    // 自定义添加的监听方法\r\n    $watch(newVal, oldVal, changedPath) {\r\n        if (changedPath == 'num' && newVal == 5) {\r\n            this.data.name = 'five';\r\n            return this.triggerEvent(\"isFive\")\r\n        }\r\n        //...\r\n    }\r\n  }\r\n})\r\n复制代码相比每个参数都要监听 这种写法可以减少代码。实现$watch：实现步骤：获取自定义props对象 -> 还原成properties格式 -> 每一个数据内都添加observer函数 -> 函数在触发时 调用自身$watch函数// 优化 properties 传入方式\r\nlet originComponent = Component;\r\nComponent = (opt) => {\r\n  let { props = {} } = opt;\r\n  let properties = {};\r\n  // 获取自定义关键字【props】中的每一项\r\n  Object.keys(props).forEach(item => {\r\n    // 重新还原成原有数据格式\r\n    properties[item] = {\r\n      type: _util.getValueType(props[item]),\r\n      value: props[item],\r\n      // 每一个数据都添加observer方法监听\r\n      observer: function (newVal, oldVal, changedPath) {\r\n        const changeEvent = {\r\n          event: item,\r\n          newVal, oldVal, changedPath\r\n        };\r\n        // 传入属性可通过组件内定义的$watch方法统一监听变化\r\n        this.$watch && this.$watch(changeEvent);\r\n      }\r\n    }\r\n  });\r\n  opt.properties = properties; // 还给properties...\r\n  //...\r\n  return originComponent(opt)\r\n}\r\n\r\n\r\n/**\r\n * 获取数据类型\r\n * @param value\r\n * @returns {*}\r\n */\r\nfunction getValueType(value) {\r\n  if (typeof value === 'number') return Number;\r\n  if (typeof value === 'string') return String;\r\n  if (typeof value === 'boolean') return Boolean;\r\n\r\n  if (value instanceof Object && !value instanceof Array) return Object;\r\n  if (value instanceof Array) return Array;\r\n\r\n  return null;\r\n}\r\n复制代码这样就可以实现$watch方法啦！【demo地址】"}
{"title": "小程序绑定用户方案 优化 ", "author": "2019-5-15 00:16", "pub_time": "2019-5-15 00:16", "content": "在做过一系列小程序之后，对小程序的登陆鉴权的流程也有一定的理解，类似于 B 端小程序自不必说，要用户信息手机号地址可以一把梭，做一个引导页面进行判断然后要求用户给与绑定，用户自然不会多说什么，毕竟这是企业级别应用。但是当涉及到 C 端小程序时候。想让用户进行绑定，就势必要给与用户便利。这里我列出一些我觉得较为不错的小程序应用方案以供参考。预先绑定类该类小程序在使用之前就需要绑定用户信息。常见于线下门店类功能性小程序。线下操作时有大量的优惠活动来支持小程序的流量。功能介绍例如 便利蜂。之前在上海经常使用，价格和优惠都非常不错，这类小程序属于线下功能类小程序，内部有抽奖，付款等一系列功能。该小程序第一次打开就先用户直接要求用户绑定信息和地址，考虑到线下门店都会有一定的店员辅助。所以该小程序的绑定操作实际上用户都是可以接受的。图片如下所示。技术要点技术1： 使用自定义导航栏让头部可以配置全局配置\"window\": {\r\n  \"navigationStyle\": \"custom\"\r\n}如果微信 app 的版本在 7.0.0之上，我们就可以使用页面级别的配置了。{\r\n  \"usingComponents\": {},\r\n  \"navigationStyle\": \"custom\"\r\n}该配置默认时default，当使用custom时候可以自定义导航，可以在头部配置 loading。第二种这个需要 app 版本，所以如果是想简化，反而在全局下定义，再使用微信官方的组件 avigation-bar 即可。技术2：使用小程序骨架屏骨架屏方案在后端不能很快给与前端数据时候采用这种方案，亦或者前端可以使用 Service Worker 把上次缓存数据返回到前端，等到从后端获取数据之后刷新页面也是一种方案，但是因为这是第一次打开小程序，所以采用骨架屏是一个很好的方法。采用 小程序骨架屏 组件，如果不需要骨架屏动画效果，可以试试直接加载图片作为骨架屏。惰性绑定类该类小程序在展示时无需绑定用户信息，但是当用户进行操作时在询问绑定。常用于线上商城等一系列无需专人引导的用户项目。功能介绍基本上线上大部分 c 端小程序都采用此做法，功能上倒是没什么可以介绍的，但是实践上却有不同做法。实践方式方式 1: 页面跳转 (京东购物)在每个需要绑定的按钮上添加跳转逻辑，如果当前小程序没有绑定，可以跳转到另外一个页面上确认授权。方式2: 按钮控制 (华为商城+)在每个需要绑定按钮上添加 open-type='getuserinfo'，后续可以根据状态变化，切换掉按钮(也可以不切换，因为第二次绑定数据不会跳出组件)。方式3: 遮罩层拦截 (抽奖助手)在需要绑定的页面添加一个 透明模态框，增加以整个页面大小的button。用fixed布局，还可以向下滚动。无论在当前页面点击任何地方都会出现需要绑定选项。组件代码：// wxml\r\n<view style=\"z-index: {{zIndex}}\" class=\"mask\">\r\n  <button open-type=\"{{ openType }}\"\r\n          bindtap=\"onClick\"\r\n          bindgetuserinfo=\"bindGetUserInfo\"\r\n          bindgetphonenumber=\"bindGetPhoneNumber\"\r\n          bindopensetting=\"bindOpenSetting\"\r\n          binderror=\"bindError\"\r\n          class=\"mask\"/>\r\n</view>\r\n\r\n// wxss\r\n.mask{\r\n  position: fixed;\r\n  top: 0;\r\n  bottom:0;\r\n  left:0;\r\n  right:0;\r\n  background-color: inherit;\r\n  opacity: 0;\r\n}然后在绑定后令 mask 消失。该方案初看起来不是那么的合适，但是仔细想想却也没什么问题，因为用户99%可能点击所需求的按钮，就算点击到按钮之间的空隙之处跳出要求绑定也没有什么问题。上面方式实际上都没有太大的问题，需要在不同场景下做最合适的选择。结语人机交互功能是决定计算机系统“友善性”的一个重要因素。读书学习时候要先把书读厚，再把书读薄，做程序也是一样，如何把系统做的复杂而更加复杂，如何让用户的体验简单而更为简单都不是那么容易的一件事。"}
{"title": "微信小程序事件对象中e.target和e.currentTarget的区别 ", "author": "2019-5-15 00:31", "pub_time": "2019-5-15 00:31", "content": "在小程序的事件回调触发时，会接收一个事件对象，事件对象的参数中包含一个target和currentTarget属性，接下来说说这二者的区别。首先上代码：wxml部分：\r\n\r\n<view id='tar-father' bindtap='click'>\r\n    父组件\r\n    <view id='tar-children'>子组件</view>\r\n  </view>\r\n  \r\nwxss部分：\r\n\r\n#tar-father{\r\n  width: 300rpx;\r\n  height: 300rpx;\r\n  background-color: skyblue;\r\n}\r\n#tar-children{\r\n  background-color: pink;\r\n}效果图js部分：\r\n  click: function (event) {\r\n    console.log(event.target)\r\n    console.log(event.currentTarget)\r\n  }\r\n当点击图中粉色子组件区域时的输出结果：event.target 为其子组件，也就是触发该事件的源头组件\r\nevent.currentTarget 为事件所绑定的组件\r\n当点击图中蓝色父组件区域时的输出结果：\r\nevent.target 为父组件，因为触发的源头也就是父组件本身\r\nevent.currentTarget 始终为事件所绑定的组件\r\n总结：target对应的是触发事件的源头组件，这个组件有可能是子组件，有可能是父组件，主要是看执行动作的区域。而currentTarget始终对应事件所绑定的组件。"}
{"title": "mpvue小程序循环动画开启暂停 ", "author": "2019-5-15 00:35", "pub_time": "2019-5-15 00:35", "content": "用小程序的animation属性实现循环动画的开启与暂停，并封装到组件。\r\n\r\n实现一个字体图标组件的循环旋转动画开启/暂停\r\n\r\n\r\n用于点击图标，字体颜色变换，开始循环旋转动画，并刷新内容\r\n\r\n\r\n刷新结束，停止动画，并设置字体颜色为原来的\r\n\r\n\r\n主要利用setInterval定时器循环执行动画\r\n\r\n\r\n\r\n\r\n首先，组件写出来\r\n添加点击事件，动画属性，style属性（用来动态修改样式）\r\n\r\nsrc/components/refresh.vue\r\n\r\n<template>\r\n  <div>\r\n    <div\r\n      class=\"iconfont icon-shuaxin\"\r\n      :animation='refreshA'\r\n      @click=\"refresh\"\r\n      :style='style'></div>\r\n  </div>\r\n</template>\r\n复制代码设置初始数据\r\n使用一个 布尔 数据refreshing判断动画的状态为开启true/暂停false\r\n<script>\r\nexport default {\r\n  data () {\r\n    return {\r\n      refreshA: null,\r\n      style: 'color: #eee;',\r\n      // 用来设置存储旋转的度数\r\n      rotate: 0,\r\n      // 存储定时器id\r\n      refreshI: null\r\n    }\r\n  },\r\n  props: ['refreshing']\r\n}\r\n</script>\r\n复制代码添加点击事件函数\r\n<script>\r\nexport default {\r\n  methods: {\r\n    // 刷新按钮点击\r\n    refresh () {\r\n      // 正在刷新 则跳出，避免在循环动画执行时，再次出发点击刷新事件\r\n      if (this.refreshing) return\r\n      // 否则提交刷新事件\r\n      this.$emit('refresh')\r\n    },\r\n    // 刷新动画结束\r\n    refreshend () {\r\n    \t// 当动画结束，字体颜色恢复原来\r\n      this.style = 'color: #eee;'\r\n    }\r\n  }\r\n}\r\n</script>\r\n复制代码监听refreshing状态\r\n<script>\r\nexport default {\r\n  watch: {\r\n    refreshing (newV, oldV) {\r\n      // 没有正在刷新 > 正在刷新 设置循环动画\r\n      if (newV && !oldV) {\r\n        this.style = 'color: #fff;'\r\n        this.refreshI = setInterval(() => {\r\n        // 每次 +360 实现每 300 毫秒旋转 360 度  \r\n          this.rotate += 360\r\n          let animation = wx.createAnimation()\r\n          animation.rotateZ(this.rotate).step()\r\n          this.refreshA = animation.export()\r\n        }, 300)\r\n        return\r\n      }\r\n      // 从正在刷新 > 刷新完成  清空循环定时器动画\r\n      if (!newV && oldV) {\r\n        // 防止网速过快，动画队列还没生成就刷新完成，这里判断动画队列是否为空\r\n        // 为空，就重置一下样式\r\n        this.style = 'color: #eee;'\r\n        \r\n        clearInterval(this.refreshI)\r\n        this.refreshA = null\r\n      }\r\n    }\r\n  }\r\n}\r\n</script>\r\n复制代码\r\n需要注意的是定时器时间必须和动画的过渡时间设置为相同\r\n\r\n组件调用\r\n\r\nsrc/pages/index/index.vue\r\n\r\n<template>\r\n  <div>\r\n    <Refresh @refresh='refresh' :refreshing='refreshing'/>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport Refresh from '@/components/refresh'\r\n\r\nexport default {\r\n  data: {\r\n    // 初始状态肯定为 false ,点击刷新组件后，在事件函数中再设置为 true\r\n    refreshing: false\r\n  },\r\n  components: {\r\n    Refresh\r\n  },\r\n  methods: {\r\n    async refresh () {\r\n    this.refreshing = true\r\n    // 这里为一个异步请求api\r\n    let data = await api.getData()\r\n    // 请求完成，执行想要操作的代码后，设置动画为 false\r\n    // this.data = data\r\n    this.refreshing = false\r\n    }\r\n  }\r\n}\r\n</script>\r\n\r\n<style lang=\"stylus\" scoped>\r\n</style>\r\n复制代码refresh组件完整代码\r\n<template>\r\n  <div>\r\n    <div\r\n      class=\"iconfont icon-shuaxin\"\r\n      :animation='refreshA'\r\n      @click=\"refresh\"\r\n      :style='style'></div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  data () {\r\n    return {\r\n      refreshA: null,\r\n      style: 'color: #eee;',\r\n      rotate: 0,\r\n      refreshI: null\r\n    }\r\n  },\r\n  props: ['refreshing'],\r\n  watch: {\r\n    refreshing (newV, oldV) {\r\n      if (newV && !oldV) {\r\n        this.style = 'color: #fff;'\r\n        this.refreshI = setInterval(() => {\r\n          this.rotate += 360\r\n          let animation = wx.createAnimation()\r\n          animation.rotateZ(this.rotate).step()\r\n          this.refreshA = animation.export()\r\n        }, 300)\r\n        return\r\n      }\r\n      if (!newV && oldV) {\r\n        this.style = 'color: #eee;'\r\n        clearInterval(this.refreshI)\r\n        this.refreshA = null\r\n      }\r\n    }\r\n  },\r\n  methods: {\r\n    refresh () {\r\n      if (this.refreshing) return\r\n      this.$emit('refresh')\r\n    },\r\n    refreshend () {\r\n      this.style = 'color: #eee;'\r\n    }\r\n  }\r\n}\r\n</script>\r\n\r\n<style lang=\"stylus\" scoped>\r\n</style>\r\n\r\n复制代码效果\r\n\r\n正常效果，看图中右上角\r\n\r\n\r\n\r\n网速太快"}
{"title": "解决微信小程序云开发中获取数据库的内容为空 ", "author": "2019-5-15 00:49", "pub_time": "2019-5-15 00:49", "content": "问题描述：在前端想获取数据库某集合中的数据时，返回的参数data始终为空数组，如下：相关代码如下：const db = wx.cloud.database();\r\nconst activityInfo = db.collection('activityInfo');\r\n\r\nPage({\r\n    ...省略不相干代码...\r\n        \r\n        onLoad(){\r\n            activityInfo.get().then((res)=>{\r\n                console.log(res)\r\n            })\r\n        }\r\n            \r\n    \r\n    ...省略不相干代码...\r\n})解决方案:数据库新建的collectioin需要设置权限，没有问题就可以读取和更新了;小程序云开发控制台->你的集合名称->权限设置->所有用户可读，仅创建者可读写结果:成功获取到数据！"}
{"title": "微信小程序之SelectorQuery ", "author": "2019-5-16 00:12", "pub_time": "2019-5-16 00:12", "content": "在开发小程序展开全文组件时需要用到节点查询API - wx.createSelectorQuery() 来查询全文内容的高度。wx.createSelectorQuery() 返回一个 SelectorQuery 对象实例。SelectorQuery 有五个方法（in，select，selectAll，selectViewport，exec），第一个返回 SelectorQuery，后四个返回 NodesRef。NodesRef 有四个方法（fields，boundingClientRect，scrollOffset，context），第一个返回 NodesRef，后三个返回 SelectorQuery。对照官方提供的示例代码来看const query = wx.createSelectorQuery() // query 是 SelectorQuery 对象\r\nquery.select('#the-id').boundingClientRect() // select 后是 NodesRef 对象，然后 boundingClientRect 返回 SelectorQuery 对象\r\nquery.selectViewport().scrollOffset() // selectViewport 后是 NodesRef 对象，然后 scrollOffset 返回 SelectorQuery 对象\r\nquery.exec(function (res) { // exec 返回 NodesRef 对象\r\n  res[0].top // #the-id节点的上边界坐标\r\n  res[1].scrollTop // 显示区域的竖直滚动位置\r\n})问题：每行执行返回的 SelectorQuery 对象是相同的吗？答案：是的，都是同一个对象。问题：直接执行 query.select('#the-id').boundingClientRect().exec 也可以吗？答案：可以，boundingClientRect() 返回就是 query。问题：这样连写 query.select('#the-id').boundingClientRect().selectViewport().scrollOffset() 算两条查询请求吗？答案：是两条请求。问题：query.exec 执行后会清空前面的查询请求吗？再次执行还能拿到结果吗？答案：可以，query不会清空请求。问题：boundingClientRect 和 scrollOffset 可以接受 callback 参数，它与 query.exec 执行顺序是怎样，修改 res 结果会影响到后面的 callback 吗？答案：先执行 boundingClientRect 和 scrollOffset 的 callback，再执行 query.exec 的 callback；修改 res 结果会影响到后面 exec 的结果。上面的问题通过 WAService.js 源码简单美化后可以了解 SelectorQuery 的代码逻辑class NodesRef {\r\n  constructor(selectorQuery, component, selector, single) {\r\n    this._selectorQuery = selectorQuery;\r\n    this._component = component;\r\n    this._selector = selector;\r\n    this._single = single;\r\n  }\r\n  fields(e, t) {\r\n    this._selectorQuery._push(this._selector, this._component, this._single,\r\n      e,\r\n      t,\r\n    );\r\n    return this._selectorQuery\r\n  }\r\n  boundingClientRect(callback) {\r\n    this._selectorQuery._push( this._selector, this._component, this._single,\r\n      {\r\n        id: true,\r\n        dataset: true,\r\n        rect: true,\r\n        size: true,\r\n      },\r\n      callback,\r\n    );\r\n    return this._selectorQuery;\r\n  }\r\n  scrollOffset(callback) {\r\n    this._selectorQuery._push( this._selector, this._component, this._single,\r\n      {\r\n        id: true,\r\n        dataset: true,\r\n        scrollOffset: true,\r\n      },\r\n      callback,\r\n    );\r\n    return this._selectorQuery;\r\n  }\r\n}\r\n\r\nlet pluginId = '';\r\nclass SelectorQuery {\r\n  constructor(e) {\r\n    if (e && e.page) {\r\n      this._component = this._defaultComponent = e.page;\r\n      this._webviewId = this._defaultComponent.__wxWebviewId__;\r\n    } else {\r\n      var pages = __internalGlobal__.getCurrentPagesByDomain('');\r\n      this._defaultComponent = pages[pages.length - 1],\r\n      this._component = null;\r\n      this._webviewId = null;\r\n    }\r\n    this._queue = [];\r\n    this._queueCb = [];\r\n  }\r\n  in(component) {\r\n    if (!this._webviewId) {\r\n      this._webviewId = component.__wxWebviewId__;\r\n      this._component = component;\r\n    } else if (this._webviewId !== component.__wxWebviewId__) {\r\n      console.error('A single SelectorQuery could not work in components in different pages. A SelectorQuery#in call has been ignored.');\r\n    } else {\r\n      this._component = component;\r\n    }\r\n    return this;\r\n  }\r\n  select(selector) {\r\n    return new NodesRef(this, this._component, selector, true);\r\n  }\r\n  selectAll(selector) {\r\n    return new NodesRef(this, this._component, selector, false);\r\n  }\r\n  selectViewport() {\r\n    return new NodesRef(this, 0, '', true);\r\n  }\r\n  _push(selector, component, single, fields, callback) {\r\n    if (!this._webviewId) {\r\n      this._webviewId = this._defaultComponent ? this._defaultComponent.__wxWebviewId__ : undefined;\r\n    }\r\n    const rootNodeId = pluginId ? '' : r.getRootNodeId(this._webviewId);\r\n    this._queue.push({\r\n      component: null != component ? (0 === component ? 0 : component.__wxExparserNodeId__) : rootNodeId,\r\n      selector,\r\n      single,\r\n      fields,\r\n    });\r\n    this._queueCb.push(callback || null);\r\n  }\r\n  exec(callback) {\r\n    hd(this._webviewId, {\r\n      pluginId,\r\n      queue: this._queue,\r\n    }, (results) => {\r\n      const queueCb = this._queueCb;\r\n      results.forEach((res, index) => {\r\n        if ('function' == typeof queueCb[index]) {\r\n          queueCb[index].call(this, res);\r\n        }\r\n      });\r\n      if ('function' == typeof callback) {\r\n        callback.call(this, results);\r\n      }\r\n    })\r\n  }\r\n}"}
{"title": "在微信小程序中下载图片到本地解决方案 ", "author": "2019-5-16 00:37", "pub_time": "2019-5-16 00:37", "content": "说明最近有些空余时间开始着手优化我那个 吉他自学小助手 的微信小程序，其中有一个功能是下载吉他谱到本地，开始以为只是很简单的拿到图片url然后down下来就好了，其实不然…最终通过google解决了这个问题，现在记录一下，以便后续翻阅。少废话先看东西流程梳理获取图片远程地址数组–>遍历拿到图片缓存（临时地址）(wx.getImageInfo)–>保存缓存图片到本地（wx.saveImageToPhotosAlbum）完整代码子组件代码逻辑//子组件download-file.vue\r\n<template>\r\n  <div></div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  props: {\r\n    urls: {\r\n      default: \"\"//通过父组件传递远程图片路径数组\r\n    }\r\n  },\r\n  watch: {\r\n    urls() {\r\n      if (this.urls.length > 0) {\r\n        this.downLoadImage(this.urls);//监听变化\r\n      }\r\n    }\r\n  },\r\n  methods: {\r\n  \t//拿到图片的临时路径\r\n    getImageInfo(url) {\r\n      var cache = {};\r\n      return new Promise((resolve, reject) => {\r\n        /* 获得要在画布上绘制的图片 */\r\n        if (cache[url]) {\r\n          resolve(cache[url]);\r\n        } else {\r\n          const objExp = new RegExp(\r\n            /^http(s)?:\\/\\/([\\w-]+\\.)+[\\w-]+(\\/[\\w- .\\/?%&=]*)?/\r\n          );\r\n          if (objExp.test(url)) {\r\n            wx.getImageInfo({\r\n              src: url,\r\n              complete: res => {\r\n                if (res.errMsg === \"getImageInfo:ok\") {\r\n                  cache[url] = res.path;\r\n                  resolve(res.path);\r\n                } else {\r\n                  reject(new Error(\"getImageInfo fail\"));\r\n                }\r\n              }\r\n            });\r\n          } else {\r\n            this.cache[url] = url;\r\n            resolve(url);\r\n          }\r\n        }\r\n      });\r\n    },\r\n    downLoadImage(urls) {\r\n      const vm = this;\r\n      let temp = [];\r\n      if (urls.length > 0) {\r\n        urls.map((item, index) => {\r\n          vm.getImageInfo(item).then(res => {\r\n            temp.push(res);\r\n            vm.saveImageToLocal(res);\r\n          });\r\n        });\r\n      }\r\n    },\r\n    saveImageToLocal(path) {\r\n      //保存临时图片到本地\r\n      wx.saveImageToPhotosAlbum({\r\n        filePath: path,\r\n        success(res) {\r\n          console.log(\"success\");\r\n        },\r\n        fail: function(res) {\r\n          console.log(res);\r\n        }\r\n      });\r\n    }\r\n  }\r\n};\r\n</script>\r\n\r\n<style>\r\n</style>在父组件中引用//news/detail.vue\r\n//省略代码...\r\n<button @click=\"download\">下载</button>\r\n//省略代码...\r\n<download-file :urls=\"downLoadUrls\" ref=\"myDownload\"></download-file>\r\n//省略代码...\r\nasync download() {\r\n    let vm = this;\r\n    const temp = [];\r\n    let data = await vm.$net.get(vm.$apis.articleDetails, {\r\n        id: vm.item.id\r\n    });\r\n    if (data.article.body.length > 0) {\r\n      data.article.body.map((item, index) => {\r\n        if (item.type == \"img\") {\r\n          temp.push(item.data);\r\n        }\r\n    });\r\n  }\r\n  vm.downLoadUrls = temp;\r\n},Previous用weexplus从0到1写一个app(2)-页面跳转和文章列表及文章详情的编写"}
{"title": "微信小程序中页面间跳转传参方式 ", "author": "2019-5-16 09:55", "pub_time": "2019-5-16 09:55", "content": "在做微信小程序的时候，经常会遇到需要页面间传递参数的情况，根据目前项目经验，总结了以下几种方式：URL传参、缓存和方法调用。\r\nURL传参\r\n这种方式是最简单也是最常用的，这里就不做过多介绍了。\r\n缓存\r\n虽然URL传参比较简单易用，但也有局限性，就是只能传递简单参数，对于复杂的参数就显得无能为力了，但很多时候我们需要传递的是结构比较复杂的数据，这时候很多开发者都会想到用缓存。\r\n使用缓存我们有两种方式：小程序自带Storage和vuex。因为我们的项目是基于mpvue的，顺带也用了vuex了\r\n\r\nStorage：通过小程序提供的API可以方便的进行缓存操作，如：wx.setStorage、wx.getStorage等。\r\nVuex：这就跟我们平时在做vue项目时一样了，在store中声明一个变量存放传递的参数。\r\n\r\n不管是用上面哪种方式，想法都是一样的：在跳转页面之前先把参数保存到缓存，进入页面之后先获取缓存的参数，然后清除缓存中的参数，进行业务操作。大致伪代码如下：\r\n// pageA.vue \r\ngoToPageB() {\r\n  let arg = {\r\n    name: 'Jack',\r\n    age: 9\r\n  }\r\n  // 先把参数保存到缓存 比如这里用的是小程序的Storage，这里采用同步的方式\r\n  wx.setStorageSync({\r\n    key: 'pageArg',\r\n    data: arg\r\n  })\r\n  wx.navigateTo({\r\n    url: 'pageB'\r\n  })\r\n}\r\n\r\n\r\n// pageB.vue \r\nmounted() {\r\n  // 从缓存中取出参数\r\n  let arg = wx.getStorageSync('pageArg')\r\n  // 清除缓存中的页面参数\r\n  wx.removeStorageSync('pageArg')\r\n  // 进行业务处理\r\n  // ...\r\n}\r\n复制代码大致就是这么个逻辑，可能具体项目中会对存取缓存进行封装，或者在vuex中的做法又不一样，但思想是一样的。\r\n这样做是可以实现功能，但总感觉不太好，每次都要进行存取操作，感觉很麻烦，而且显得不高端。。。\r\n于是乎，我们想了个方式传递，就是今天的主角：方法调用。\r\n方法调用\r\n这种方式肯定不是最好最优雅的解决方式，因为我们也觉得有欠缺的地方，但目前用起来还是比较方便的，今天放出来也是希望让大家看下怎么进行修改，也以便于我们优化。\r\n主要是用了小程序提供的getCurrentPages方法，具体内容可查看文档，我这里直接就贴图了，因为文档说的很简单\r\n\r\n小程序对页面的管理感觉跟浏览器中的history差不多，也是有一个页面栈，每次跳转页面都是往这个栈里push一个页面对象，返回的时候就pop一个，当然具体实现要复杂很多。\r\n这里官方重点提示了：不要尝试修改页面栈，这也就是为什么我说我们的这种传参方式不是很好的原因，我们就是通过方法修改了这个页面栈的数据。\r\n带参数返回上一页\r\n具体实现方式\r\n// 往前获取页面对象，类似history.go(-n)\r\nfunction getPageByPreCount(n) {\r\n  let currentPages = getCurrentPages()\r\n  return currentPages[Math.max(0, currentPages.length - (n + 1))]\r\n}\r\n\r\n/* 返回上一页并带回参数\r\n * parameter functionName 上一个页面中用来接收带回参数的方法名称，注意：方法要在data中\r\n * parameter args  带回去的参数\r\n*/\r\nfunction returnPrevPage(functionName, ...args) {\r\n  if (functionName) {\r\n    let prevPage = getPageByPreCount(1)\r\n    wx.navigateBack()\r\n    // 方法里手动调用了页面的方法，并把页面参数在这里作为方法参数传递\r\n    prevPage.data.$root[0] && typeof prevPage.data.$root[0][functionName] == 'function' \r\n    && prevPage.data.$root[0][functionName](...args)\r\n  } else {\r\n    wx.navigateBack()\r\n  }\r\n}\r\n复制代码项目中使用，如在搜索页(search.vue)面中有一个过滤条件是用户，但可以选择多个用户，而且选择用户是在另外一个页面(user-pick.vue)里进行的，这就是要从user-picker.vue跳回search.vue，并带回选中的用户列表信息\r\n// user-pick.vue\r\nmethods: {\r\n  onSelectConfirm(users) {\r\n    returnPrevPaeg('onSelectUser', users)\r\n  }\r\n}\r\n\r\n// user-pick.vue\r\ndata() {\r\n  return {\r\n    // 把具体处理还是放到了methods中，如果处理逻辑比较简单也可以直接放这里\r\n    onSelectUser: this.onUserOk\r\n  }\r\n},\r\nmethods: {\r\n  onUserOk(users) {\r\n    // 拿到用户信息 进行搜索操作\r\n    // this.search(user)\r\n  }\r\n}\r\n复制代码带参数跳转页面\r\n返回上一页还是比较好理解的，因为页面已经在页面栈里存在了，可以取到并调用方法，但对于跳转的就不太好实现了，因为每次跳转页面都是往页面栈里追加一个新的对象，在跳转前无法获取到该对象。\r\n这里就是我说的做的不太好的地方，因为我们采用的是setTimeout方式。。。\r\n// 前进页面回调方法\r\nfunction navigateTo (url,functionName,...args) {\r\n  triggerNextPageFn('onHide', functionName, ...args)\r\n  // 跳转后处理数据\r\n  wx.navigateTo({url})\r\n}\r\nfunction redirectTo (url,functionName,...args) {\r\n  triggerNextPageFn('onUnload', functionName, ...args)\r\n  // 跳转后处理数据\r\n  wx.redirectTo({url})\r\n}\r\n\r\n// 通用触发后一个页面的方法\r\nfunction triggerNextPageFn(type, functionName, ...args) {\r\n  let prePage = getCurPage()\r\n  if (functionName) {\r\n    // 保存当前变量\r\n    ((..._args) => {\r\n      let oldEventFn = prePage[type]\r\n      prePage[type] = () => {\r\n        // 前进页面改变onReady方法，这里使用了setTimeout\r\n        setTimeout(() => {\r\n          let newPage = getCurPage()\r\n          let oldOnReady = newPage.onReady\r\n          newPage.onReady = function () {\r\n            newPage.data.$root[0] && typeof newPage.data.$root[0][functionName] == 'function' \r\n            && newPage.data.$root[0][functionName](..._args)\r\n            oldOnReady.apply(newPage)\r\n            newPage.onReady = oldOnReady\r\n          }\r\n        })\r\n        prePage[type] = oldEventFn\r\n      }\r\n    })(...args)\r\n  }\r\n}\r\n复制代码小结\r\n传递方式那么多，选择适合自己的才是最重要的。虽然我们写的这个传参方法不是微信官方支持的，因为文档里面明确说了不要修改页面栈，但就目前使用情况来看还是没遇到什么问题的，也许还没遇到吧。\r\n就本篇文章中介绍的传参方式，如果有不妥的地方或者更好的修改建议，希望大家能帮我们提出来，大家共同进步。"}
{"title": "微信小程序map 地图引入配置+腾讯地图地址坐标解析 ", "author": "2019-5-17 00:49", "pub_time": "2019-5-17 00:49", "content": "最终效果\r\n\r\n一、要实现的功能\r\n\r\n\r\n展示地图。\r\n\r\n参考map组件\r\n\r\n\r\n\r\n在地图上展示多个店铺。\r\n\r\nmarker标记点用于在地图上显示标记的位置。\r\n\r\n\r\n\r\n点击店铺放大图标，展示选择的店铺信息。\r\n\r\n更改选择店铺的标记尺寸大小。\r\n\r\n\r\n\r\n在地图中心点放一个可视化标记。\r\n\r\ncover-view标签防止一个标记图片，订到在地图大小的中心，自行调试。\r\n\r\n\r\n\r\n移动后获取地图中心点位置，选择最近一个店铺。\r\n\r\nmap的bindregionchange事件，视野发生变化时触发，重新请求，把最近一家店铺修改标记尺寸大小（有注意事项）。\r\n\r\n\r\n\r\n移动后根据屏幕中心点坐标逆地址解析成中文地址（详细看第四）。\r\n\r\n\r\n增加选择其他城市页面（封装成组件了，点击这里查看）。\r\n\r\n\r\n点击其他城市，根据城市名称地址解析成坐标，更新视图（详细看第四）。\r\n\r\n\r\n二、注意事项\r\n\r\n每次更新视图都会触发bindregionchange事件，如果在里面获取到地图视图中心点坐标重新赋值给地图坐标的话，会造成这个事件不断的触发。\r\n每次拖动视图中心点位置都需要重新请求坐标附件的店铺。注意封装方法\r\n展示在地图上的标签必须用cover-view或者cover-image\r\n\r\n三、涉及到的技术及链接\r\n\r\n小程序的map组件\r\n腾讯地图的微信小程序javaScript SDK，地址的解析(中文地址转坐标)和逆地址解析(坐标转中文地址)\r\n\r\n\r\n四、腾讯地图的微信小程序javaScript SDK 使用\r\n使用方式直接去看官方文档，引入也非常详细了。直接把下载js文件，然后引入。不改成了es6的expost default/import来导出引入\r\nexport default QQMapWX\r\n复制代码然后在使用页面import，在onLoad里实例化api核心类。\r\n//index.vue\r\nimport QQMapWX from \"@/utils/qqmap-wx-jssdk\"; //腾讯地图，reverseGeocoder逆地址转码\r\nexport default {\r\n    data(){\r\n        return {\r\n          qqmapsdk: null, //实例化地图sdk\r\n        }\r\n    },\r\n    onLoad(){\r\n        // 实例化API核心类\r\n        this.qqmapsdk = new QQMapWX({\r\n          key: \"3P2BZ-6G***-C***3-***5G-3VDYH-N5BGH\" // 必填\r\n        });\r\n    }\r\n}\r\n复制代码根据坐标逆解析详细地址\r\n//根据坐标逆解析详细地址\r\ngetCityinfo() {\r\n      return new Promise((resolved, rejected) => {\r\n        const that = this;\r\n        this.qqmapsdk.reverseGeocoder({\r\n          location: {\r\n            latitude: this.latitude,\r\n            longitude: this.longitude\r\n          },\r\n          success(res) {\r\n            console.log(\"地址转码成功\", res);\r\n            const _res = res.result;\r\n            that.cityName = _res.address_component.city;\r\n            that.update({\r\n              cityName: _res.address_component.city,\r\n              nowPlace:\r\n                _res.formatted_addresses.recommend + \" - \" + _res.address\r\n            });\r\n            that.getShopData();\r\n          },\r\n          fail: function(res) {\r\n            console.log(res);\r\n          }\r\n        });\r\n      });\r\n    },\r\n复制代码根据城市/地址解析成坐标\r\n//根据城市/地址解析成坐标\r\ncityNameGetPosition() {\r\n      return new Promise((resolved, rejected) => {\r\n        const that = this;\r\n        this.qqmapsdk.geocoder({\r\n          address: this.cityName,\r\n          success(res) {\r\n            console.log(\"根据地址转换坐标\", res);\r\n            const _res = res.result.location;\r\n            that.latitude = _res.lat;\r\n            that.longitude = _res.lng;\r\n            that.update({\r\n              latitude: _res.lat,\r\n              longitude: _res.lng\r\n            });\r\n            that.getCityinfo();\r\n          },\r\n          fail(err) {\r\n            console.log(\"根据地址转换坐标err\", err);\r\n          }\r\n        });\r\n      });\r\n    },\r\n复制代码五、实现的部分代码\r\n使用的请求和功能逻辑应该是这样的，做了个思维导图。 (注意：代码跟思维导图可能有出入，图是完成代码后的总结，是比较完善的)\r\n\r\n这个项目开发使用的是mpvue开发的小程序，mpvue里bindregionchange事件变成了\r\n    //不是mpvue开发请无视\r\n    @regionchange=\"getCenterMap1\"\r\n    @end=\"getCenterMap\"\r\n复制代码map组件\r\n    <div>\r\n        <!-- 地图组件 -->\r\n        <map\r\n          id=\"map\"\r\n          :longitude=\"longitude\"\r\n          :latitude=\"latitude\"\r\n          scale=\"13\"\r\n          :markers=\"markers\"\r\n          @markertap=\"markertap\"\r\n          @regionchange=\"getCenterMap1\"\r\n          @end=\"getCenterMap\"\r\n          show-location\r\n          style=\"width:750rpx; height:99vh;\"\r\n        >\r\n        </map>\r\n        <!-- 中心点 -->\r\n        <cover-image  class=\"centerImg\"\r\n        src=\"/static/images/person.png\"\r\n        ></cover-image>\r\n        <!-- 回到我的定位 -->\r\n        <cover-image\r\n          @click=\"getMyPosition\"\r\n          class=\"backMyPosition\"\r\n          src=\"/static/images/location.png\"\r\n        ></cover-image>\r\n    </div>\r\n复制代码获取自身定位wx.getLocation\r\n// 获取定位\r\n    getMyPosition() {\r\n      return new Promise((resolved, rejected) => {\r\n        wx.getLocation({\r\n          type: \"wgs84\",\r\n          success: data => {\r\n            // console.log(data,\"微信地图\")\r\n            this.latitude = data.latitude;\r\n            this.longitude = data.longitude;\r\n            this.$store.commit(\"update\", {\r\n              latitude: data.latitude,\r\n              longitude: data.longitude\r\n            });\r\n            // 根据坐标获取城市信息\r\n            this.getCityinfo().then(() => {\r\n              resolved();\r\n            });\r\n          },\r\n          fail() {\r\n            //失败回调\r\n            //如果用户拒绝授权,默认为北京\r\n            this.cityName = \"北京市\";\r\n            this.update({ cityName: \"北京市\" });\r\n          }\r\n        });\r\n      });\r\n    },\r\n复制代码地图视野更新时触发\r\n    // 地图视野更新时触发\r\n    getCenterMap() {\r\n      if (this.active === \"上门\") {\r\n        const that = this;\r\n        console.log(\"自身位置坐标\", this.longitude, this.latitude);\r\n        const map = wx.createMapContext(\"map\");\r\n        map.getCenterLocation({\r\n          success(res) {\r\n            // 判断坐标一致，不用重复请求数据\r\n            if (\r\n              that.longitude === res.longitude &&\r\n              that.latitude === res.latitude\r\n            ) {\r\n              return false;\r\n            }\r\n            //  const ress =  transformFromGCJToWGS(res.latitude,res.longitude)\r\n            that.latitude = res.latitude;\r\n            that.longitude = res.longitude;\r\n\r\n            that.$store.commit(\"update\", {\r\n              latitude: res.latitude,\r\n              longitude: res.longitude\r\n            });\r\n            console.log(\"中心位置坐标\", that.longitude, that.latitude);\r\n            // console.log('转换后的中心位置坐标',ress)\r\n            that.getCityinfo();\r\n          }\r\n        });\r\n      }\r\n    }"}
{"title": "微信小程序_自定义导航 ", "author": "2019-5-20 00:31", "pub_time": "2019-5-20 00:31", "content": "需求需求需求（重要的事情说三遍）什么时候开始支持微信客户端7.0.0 - 新增 框架 支持页面级自定义导航配置 navigationStyle: custom。基础版本库 v1.9.5 (2018.01.24)， 新增 配置 window.navigationStyle 支持全屏显示小程序 详情目前支持全局的配置和单个页面的配置两种：\"navigationStyle\": \"custom\"\r\n复制代码2、如何实现与官方一样效果导航条，以及如何扩展？手机顶部信息栏的高度微信小程序胶囊位置信息微信小程序提供的APIwx.getSystemInfo() 异步获取系统信息wx.getSystemInfoSync() 同步获取用户信息wx.getMenuButtonBoundingClientRect() 小程序胶囊的位置新信息注意我们能够拿到的数值单位是 px 不是 rpx 。【之后我也写一篇专门探究小程序单位】wx.getSystemInfo({\r\n    success: (res) => {\r\n     // iphone6.statusBarHeight = 20\r\n     this.globalData.statusBarHeight = res.statusBarHeight; \r\n     let custom = wx.getMenuButtonBoundingClientRect();\r\n     this.globalData.custom = wx.getMenuButtonBoundingClientRect();\r\n     this.globalData.Custom = custom;\r\n     this.globalData.CustomBar = custom.bottom + custom.top - res.statusBarHeight;\r\n     // 另一种计算方式\r\n     this.globalData.CustomBar =custom.height + ( custom.top - res.statusBarHeight) * 2;\r\n    }\r\n})\r\n复制代码let custom = wx.getMenuButtonBoundingClientRect();\r\n复制代码代码演示我们用iphoneX的模拟器为例子，因为iphoneX的信息导航栏比较高与别的不同，我们从特殊的更加明显。<view class=\"bg\" style=\"height:{{statusBarHeight}}px\"></view>\r\n<view class='jiaonang' \r\n      style='margin-top:{{custom.top - statusBarHeight}}px; height:{{custom.height}}px'>\r\n</view>\r\n复制代码let app = getApp();\r\nPage({\r\n    data: {\r\n        statusBarHeight: app.globalData.statusBarHeight,\r\n        StatusBar: app.globalData.StatusBar,\r\n        CustomBar: app.globalData.CustomBar,\r\n        custom: app.globalData.custom\r\n    }\r\n})\r\n复制代码.bg {\r\n  width: 100%;\r\n  height: 50rpx;\r\n  background: teal;\r\n}\r\n\r\n.jiaonang {\r\n  width: 100%;\r\n  background: red;\r\n}\r\n复制代码以下是微信小程序模拟器的不同的结果iphoneX 的效果iphone6 的效果安卓Nexus5x 的效果平板iPad Air 2 的效果ipad Pro 12.9-inch 的效果3、如何适配不同的机型？？不同机型的适配一直是前端的最严重的问题，小程序对适配问题提出了rpx的方案。 但是对于自定义导航栏，我们似乎用不到的自定义导航栏！3、注意客户端 6.7.2 版本开始， navigationStyle: custom 对 <web-view> 组件无效。后记其实小程序是特别的适合，没有开发经验入门或者转行前端的同志~学会断点调试，学会排除错误，才是正道啊~我想学的细一点，路才走的广一点~"}
{"title": "在小程序中用一张 PNG 实现两个动效 ", "author": "2019-5-20 00:41", "pub_time": "2019-5-20 00:41", "content": "需求：在小程序中展示一个常规动效，点击后执行一个按压动效，执行完成恢复常规动效。\r\n\r\n可选方案：\r\n1. 使用 gif 图\r\n无法控制 gif 图的执行过程，需要通过切换图片源来实现两个动效的切换。\r\n图片放在代码包中：动效的 gif 图尺寸一般比较大，放在代码包中会超出代码包 2M 大小的限制。\r\n使用网络图片：切换的时候需要加载图片，会出现动效不连贯的问题\r\n缓存在本地：使用 wx.downloadFile 缓存在本地，但本地缓存有 10M 的限制，一不小心也会超哦～\r\n2. 使用 APNG\r\n问题同 gif，兼容性也有一定的问题。\r\n3. 使用 PNG 序列（雪碧图）\r\n单个动效的实现方案可以参考 张鑫旭大佬的文章：小tips: CSS或JS实现gif动态图片的停止与播放。\r\n为了避免切换动效时出现短暂的空白的状态，可使用 PNG 序列的方式实现：将两个动效的序列图连接在一起。\r\n那用一张 PNG 来做两个动效怎么实现呢？以一张 80 帧的 PNG 序列为例，前 40 帧为第一个动效，后 40 帧为第二个动效。执行时间均为2s。\r\n@keyframes animate-default {\r\n  0% {\r\n    background-position: 0;\r\n  }\r\n\r\n  100% {\r\n    background-position: 50%;\r\n  }\r\n}\r\n\r\n.animate-default {\r\n    animation: animate-default steps(39) 2s infinite forwards;\r\n}\r\n\r\n@keyframes animate-click {\r\n  0% {\r\n    background-position: 50%;\r\n  }\r\n\r\n  100% {\r\n    background-position: 100%;\r\n  }\r\n}\r\n\r\n.animate-click {\r\n    animation: animate-click steps(39) 2s 1 forwards;\r\n}\r\n复制代码but，现实总是很残酷，并不是我们想要的效果。\r\n\r\n那问题出在哪里呢？\r\n单帧图片的宽度为 384px，图片执行到第 40 张的时候其实位置为 384 * 39 = 14976，我们将 animate-default 动效的 100% 位置改为 -14976px，同理将 animate-click 动效的 0% 位置改为 384 * 40 即 -15360px 即可。\r\n但为了更好的适配不同的设备，我们选用了 rpx 为单位，虽然在 750 设备上动画正常，但切换设备，动画又坏掉了...摩擦，摩擦，在光滑的地板上...\r\n请忽略后面的背景～\r\n\r\n不能用 px 为单位，不能用 rpx 为单位，那以百分比的形式设置 background-position，我们该如何实现呢？\r\n敲黑板，重点来了！！\r\n敲黑板，重点来了！！\r\n敲黑板，重点来了！！\r\nbackground-position 的计算公式（from《CSS 世界》）是：\r\npercentX = positionX /（容器宽度 - 图片宽度）;\r\npercentY = positionY /（容器宽度 - 图片宽度）;\r\n所以本例中，\r\n-14976 / （384 - 384 * 80 ），约 0.49367089；\r\n-15360 / （384 - 384 * 80），约 0.50632911。\r\n@keyframes animate-default {\r\n  0% {\r\n    background-position: 0;\r\n  }\r\n\r\n  100% {\r\n    background-position: 49.367%;\r\n  }\r\n}\r\n\r\n.animate-default {\r\n    animation: animate-default steps(39) 2s infinite forwards;\r\n}\r\n\r\n@keyframes animate-click {\r\n  0% {\r\n    background-position: 50.633%;\r\n  }\r\n\r\n  100% {\r\n    background-position: 100%;\r\n  }\r\n}\r\n\r\n.animate-click {\r\n    animation: animate-click steps(39) 2s infinite forwards;\r\n}\r\n复制代码\r\n在点击后切换 class，再切换回来～OK啦，完美。"}
{"title": "小程序server请求微信服务器超时 ", "author": "2019-5-21 00:13", "pub_time": "2019-5-21 00:13", "content": "今天有同学在测试小程序的过程中，发现一个问题，调用 微信官方的服务端接口超时 ，比如这个接口，https://api.weixin.qq.com/sns/jscode2session ，因为我们小程序登录的时候，会在自己server端调用微信的API，这个接口超时，导致我们的登录流程也就挂掉了。本来以为是偶尔的网络问题，但是，同学发现在测试服务器上，很稳定的复现超时！但是在我们本地测试过程中，请求微信服务器又很快响应。嗯，理论上微信服务器不会出问题的……\r\n试着在服务器上去 curl 微信的接口，确实挺慢的，我们代码里配置了超时是3秒，目测确实超过了3秒才返回！抱着侥幸的想法，让同学把超时改成5秒，依然超时……嗯，略微有点尴尬。\r\n试着 ping api.weixin.qq.com ，发现收到第一个包，隔着挺长时间，后面的包平均几十毫秒，网络应该也没问题吧。\r\n没办法了，因为是服务端，只能用 curl，想看看这个工具能不能提供一下，整个请求的各个阶段，时间是怎么分布的。搜了一下，还真有这个功能，具体操作如下：\r\n\r\n在某个目录下，新建一个文件，比如 curl-format.txt ，内容如下：\r\n\r\n time_namelookup:  %{time_namelookup}\\n\r\n       time_connect:  %{time_connect}\\n\r\n    time_appconnect:  %{time_appconnect}\\n\r\n   time_pretransfer:  %{time_pretransfer}\\n\r\n      time_redirect:  %{time_redirect}\\n\r\n time_starttransfer:  %{time_starttransfer}\\n\r\n                    ----------\\n\r\n         time_total:  %{time_total}\\n\r\n复制代码\r\n在同一个目录下，执行 curl 操作：\r\n\r\ncurl -w \"@curl-format.txt\" -o /dev/null -s \"https://api.weixin.qq.com/sns/jscode2session?xxx=xxx&xx=aa\"\r\n复制代码拿到的结果如下：\r\n \r\n在网上查阅了下，各个字段含义如下(单位都是 秒 )：\r\n\r\ntime_namelookup: DNS 域名解析的时候，就是把 https://zhihu.com 转换成 ip 地址的过程\r\ntime_connect: TCP 连接建立的时间，就是三次握手的时间\r\ntime_appconnect: SSL/SSH 等上层协议建立连接的时间，比如 connect/handshake 的时间\r\ntime_pretransfer: 从开始到最后一个请求事务的时间\r\ntime_redirect: 从请求开始到响应开始传输的时间\r\ntime_starttransfer: 从请求开始到第一个字节将要传输的时间\r\ntime_total: 这次请求花费的全部时间\r\n\r\n从上面截图中可以看出，我们服务器上，在DNS域名解析阶段，就花了 5秒 ，难怪会超时了……\r\n找到了问题，那就先在机器上修改 /etc/hosts 文件，写死一个微信域名的IP解析，暂时 把这个问题修复了。\r\n相关资料\r\n\r\n使用curl测试网络请求耗时\r\n使用 curl 命令分析请求的耗时情况"}
{"title": "手把手教你写一个微信小程序日历组件 ", "author": "2019-5-6 00:24", "pub_time": "2019-5-6 00:24", "content": "今天我们一起写一个微信小程序日历组件\r\n\r\n微信小程序日历组件\r\ngithub.com/749264345/w…\r\n\r\n好，我们先看一下要实现的模样，如下图\r\n\r\n\r\n由以上截图我们可以看到\r\n\r\n1.日历可以通过按钮【切换展示效果】改变日历的呈现效果，上图是平铺模式，下图是收起滚动模式。\r\n2.通过点击具体的日期可以在页面上显示当前选中的具体日期。\r\n3.点击【今天】快速回到当日视图。\r\n4.点击【◀】和【▶】切换月份。\r\n上面的四点也是基本的交互需求，我们马上开始。\r\n首先，我们先结构后样式，做出最基本的界面结构\r\n这边我们把整体结构分成上中下，操作显示区，星期显示区，日期显示区。\r\n\r\n<view class='calendar'>\r\n    <!--显示当前年月日-->\r\n    <view class='calendar-title'>\r\n        <view class='item ctrl' bindtap='lastMonth'>{{lastMonth}}</view>\r\n        <view class='item title'>{{title}}</view>\r\n        <view class='item ctrl' bindtap='nextMonth'>{{nextMonth}}</view>\r\n        <view class='item ctrl today' bindtap='today'>今天</view>\r\n    </view>\r\n\r\n    <!--星期-->\r\n    <view class='calendar-week'>\r\n        <view class='item'>{{item}}</view>\r\n    </view>\r\n\r\n    <!--日期-->\r\n    <view class='calendar-container'>\r\n        <!--上个月占位格子-->\r\n        <view class='grid gray'>{{item}}</view>\r\n\r\n        <!--当月格子-->\r\n        <view class='grid'>\r\n            <view class=\"wrap\">{{item.date}}</view>\r\n        </view>\r\n\r\n        <!--下个月占位格子-->\r\n        <view class='grid gray'>{{item}}</view>\r\n    </view>\r\n</view>\r\n复制代码这是我们基本的日历结构，机智的小伙伴已经从布局中知道我们实现的大致逻辑了，是的，我们先获取当月有多少天，上月和下月有多少天，这样我们的日历就出来了。好，慢慢来，下面我们详细说，我们先写上基本的样式。\r\n.calendar {\r\n    width: 100%;\r\n    text-align: center;\r\n    font-size: 30rpx;\r\n    box-sizing: border-box;\r\n}\r\n\r\n/* 标题 */\r\n.calendar-title {\r\n    line-height: 70rpx;\r\n    font-size: 30rpx;\r\n    text-align: left;\r\n    padding: 0 20rpx;\r\n    box-sizing: border-box;\r\n}\r\n\r\n.calendar-title .ctrl {\r\n    display: inline-block;\r\n    padding: 0 20rpx;\r\n    background: #f5f5f5;\r\n    border-radius: 10rpx;\r\n}\r\n\r\n.calendar-title .item {\r\n    display: inline-block;\r\n    vertical-align: middle;\r\n    line-height: 50rpx;\r\n}\r\n\r\n.calendar-title .title {\r\n    min-width: 300rpx;\r\n    text-align: center;\r\n}\r\n\r\n.calendar-title .today {\r\n    float: right;\r\n    margin-top: 10rpx;\r\n}\r\n\r\n/* 星期 */\r\n.calendar-week {\r\n    display: flex;\r\n    text-align: center;\r\n    padding: 20rpx 10rpx;\r\n    box-sizing: border-box;\r\n    border-top: 1rpx solid #e0e0e0;\r\n    border-bottom: 1rpx solid #e0e0e0;\r\n    background: #f5f5f5;\r\n}\r\n\r\n.calendar-week .item {\r\n    flex: 1;\r\n}\r\n\r\n/* 日期 */\r\n.calendar-container {\r\n    display: flex;\r\n    flex-wrap: wrap;\r\n    padding: 20rpx 10rpx;\r\n    box-sizing: border-box;\r\n}\r\n\r\n.calendar-container .grid {\r\n    display: inline-block;\r\n    width: 14.28571428571429%;\r\n    line-height: 70rpx;\r\n    position: relative;\r\n    z-index: 1;\r\n}\r\n\r\n.calendar-container .grid.gray {\r\n    color: #ccc;\r\n}\r\n\r\n.calendar-container .grid .wrap.select {\r\n    background: rgb(49, 120, 228);\r\n    border-radius: 10rpx;\r\n    color: #fff;\r\n    width: 80%;\r\n    margin: 0 auto;\r\n}\r\n复制代码以上我们基本试下了日历的界面，下面我们来实现星期和日期的展示。\r\n好，我们先显示星期，我们先在组件中定义一个数组，用来遍历显示星期的标题；\r\nComponent({\r\n    properties: {\r\n        //星期数组\r\n        weekText: {\r\n            type: Array,\r\n            value: ['周日', '周一', '周二', '周三', '周四', '周五', '周六']\r\n        }\r\n    },\r\n    ...\r\n})\r\n复制代码我们将星期的标题定义为可配置的模式，默认显示如上的文字，之后我们可以在组件外自定义，个性化显示。于是我们调整下wxml的代码。\r\n    <!--遍历星期-->\r\n    <view class='calendar-week'>\r\n        <view wx:for='{{weekText}}' class='item' wx:key='{{item}}'>{{item}}</view>\r\n    </view>\r\n复制代码这样我们就能看到我们想要的效果。\r\n\r\n下面我们开始日期的显示，我们先获取当月有几天，这里的核心代码是\r\n\r\nnew Date(year, month, date).getDate();\r\n\r\n\r\n由此我们做如下尝试\r\n\r\n我们如期获得了返回值，而当我们传入日期为0时返回了31为当月的全部天数。\r\n\r\n由于JavaScript中day的范围为1~31中的值，所以当设为0时，会向前 一天，也即表示上个月的最后一天，通过这种方式可以得到每个月份的天数。\r\n\r\n知道了获取当月天数的原理，我们还需要知道当月1号是星期几。\r\n我们使用如下的方法：\r\n\r\nnew Date(Date.UTC(year, month-1, date)).getDay();\r\n\r\n\r\n我们同样在控制台做出调试；\r\n\r\n需要注意的是，上面的month是实际的月份，而下面这个方法需要在实际的月份上减去1。\r\n于是我们获取0-6之间的值，分别对应周日~周六。\r\n值为6是周六，值为0是周日。\r\n由于日历的第一天是周日，周日对应的是0，于是传入每月1日，返回值为多少，就是星期几，也就说明当月1日前面空几格。\r\n知道了当月就几天，当月前面有几天，我们做一下算法就可以得出，当月后面有几天，于是我们建立如下函数：\r\n    // 组件的初始数据\r\n    data: {\r\n        //当月格子\r\n        thisMonthDays: [],\r\n        //上月格子\r\n        empytGridsBefore: [],\r\n        //下月格子\r\n        empytGridsAfter: [],\r\n},\r\n\r\nmethods: {\r\n        //获取当月天数\r\n        getThisMonthDays: function (year, month) {\r\n            return new Date(year, month, 0).getDate();\r\n        },\r\n        // 绘制当月天数占的格子\r\n        createDays: function (year, month) {\r\n            let thisMonthDays = [],\r\n                days = this.getThisMonthDays(year, month);\r\n            for (let i = 1; i <= days; i++) {\r\n                thisMonthDays.push({\r\n                    date: i,\r\n                    dateFormat: this.zero(i),\r\n                    monthFormat: this.zero(month),\r\n                    week: this.data.weekText[new Date(Date.UTC(year, month - 1, i)).getDay()]\r\n                });\r\n            }\r\n            this.setData({\r\n                thisMonthDays\r\n            })\r\n        },\r\n        //获取当月空出的天数\r\n        createEmptyGrids: function (year, month) {\r\n            let week = new Date(Date.UTC(year, month - 1, 1)).getDay(),\r\n                empytGridsBefore = [],\r\n                empytGridsAfter = [],\r\n                emptyDays = (week == 0 ? 7 : week);\r\n            //当月天数\r\n            var thisMonthDays = this.getThisMonthDays(year, month);\r\n            //上月天数\r\n            var preMonthDays = month - 1 < 0 \r\n                ? this.getThisMonthDays(year - 1, 12) \r\n                : this.getThisMonthDays(year, month - 1);\r\n\r\n            //空出日期\r\n            for (let i = 1; i <= emptyDays; i++) {\r\n                empytGridsBefore.push(preMonthDays - (emptyDays - i));\r\n            }\r\n\r\n            var after = (42 - thisMonthDays - emptyDays) - 7 >= 0 \r\n                        ? (42 - thisMonthDays - emptyDays) - 7 \r\n                        : (42 - thisMonthDays - emptyDays);\r\n            for (let i = 1; i <= after; i++) {\r\n                empytGridsAfter.push(i);\r\n            }\r\n            this.setData({\r\n                empytGridsAfter,\r\n                empytGridsBefore\r\n            })\r\n        },\r\n\r\n        //补全0\r\n        zero: function (i) {\r\n            return i >= 10 ? i : '0' + i;\r\n        },\r\n}\r\n复制代码我们同样修改下wxml代码，同时我们为上月，下月，今天，三个按钮添加相关事件监听。\r\n    <!--显示当前年月日-->\r\n    <view class='calendar-title'>\r\n        <view class='item ctrl' bindtap='lastMonth'>{{lastMonth}}</view>\r\n        <view class='item title'>{{title}}</view>\r\n        <view class='item ctrl' bindtap='nextMonth'>{{nextMonth}}</view>\r\n        <view class='item ctrl today' bindtap='today'>今天</view>\r\n    </view>\r\n复制代码<!--上个月占位格子-->\r\n<view class='grid gray' wx:for='{{empytGridsBefore}}' wx:key='{{item}}'>{{item}}</view>\r\n\r\n<!--当月格子-->\r\n<view class='grid' wx:for='{{thisMonthDays}}' wx:key='{{indx}}'>\r\n   <view class='self' wx:if=\"{{ format === year+'-'+item.monthFormat+'-'+item.dateFormat }}\"></view>\r\n   <view class=\"wrap {{ select === year+'-'+item.monthFormat+'-'+item.dateFormat ? 'select' :''}}\" bindtap='select' data-date='{{item.date}}'>{{item.date}}</view>\r\n</view>\r\n\r\n<!--下个月占位格子-->\r\n<view class='grid gray' wx:for='{{empytGridsAfter}}' wx:key='{{item}}'>{{item}}</view>\r\n复制代码相关的事件监听：\r\n//默认选中当天 并初始化组件\r\ntoday: function () {\r\n    let DATE = this.data.defaultValue ? new Date(this.data.defaultValue) : new Date(),\r\n        year = DATE.getFullYear(),\r\n        month = DATE.getMonth() + 1,\r\n        date = DATE.getDate(),\r\n        select = year + '-' + this.zero(month) + '-' + this.zero(date);\r\n\r\n    this.setData({\r\n        format: select,\r\n        select: select,\r\n        year: year,\r\n        month: month,\r\n        date: date,\r\n        YEAR: year,\r\n        MONTH: month,\r\n        DATE: date,\r\n    })\r\n\r\n    //初始化日历组件UI\r\n    this.display(year, month, date);\r\n\r\n    //发送事件监听\r\n    this.triggerEvent('select', select);\r\n},\r\n//上个月\r\nlastMonth: function () {\r\n    let month = this.data.month == 1 ? 12 : this.data.month - 1;\r\n    let year = this.data.month == 1 ? this.data.year - 1 : this.data.year;\r\n    //初始化日历组件UI\r\n    this.display(year, month, 0);\r\n},\r\n//下个月\r\nnextMonth: function () {\r\n    let month = this.data.month == 12 ? 1 : this.data.month + 1;\r\n    let year = this.data.month == 12 ? this.data.year + 1 : this.data.year;\r\n    //初始化日历组件UI\r\n    this.display(year, month, 0);\r\n},\r\n复制代码代码中我们使用this.display(year, month, 0)为组件统一初始化；\r\n同时在today函数中我们添加事件监听函数，将选中的日期发送到页面，我们通过事件订阅来获取的相关值。\r\n<Calendar id=\"Calendar\" bind:select=\"select\"></Calendar>\r\n复制代码//组件监听事件\r\nselect(e) {\r\n    this.setData({\r\n        selectVal:e.detail\r\n    })\r\n},\r\n复制代码最后我们为切换显示效果的按钮添加事件：\r\n    toggleType(){\r\n        this.selectComponent('#Calendar').toggleType();\r\n    }\r\n复制代码组件中对应的方法，每当切换展示效果，组件都需要初始化\r\n        //切换展示\r\n        toggleType(){\r\n            this.setData({\r\n                toggleType: this.data.toggleType == 'mini' ? 'large' :'mini'\r\n            })\r\n            //初始化日历组件UI\r\n            this.display(this.data.year, this.data.month, this.data.date);\r\n        },\r\n复制代码以上基本上是小程序日历组件实现的基本逻辑，介于篇幅太长还有很多实现上的细节不在此一一细说，大家可以移步我的github\r\n\r\n微信小程序日历组件\r\ngithub.com/749264345/w…\r\n\r\n上文中有不足之处，请给出建议或更优的实现方案，谢谢~\r\n最后祝大家五一快乐~~"}
{"title": "微信小程序---支付密码的输入框 ", "author": "2019-5-6 00:51", "pub_time": "2019-5-6 00:51", "content": "效果如下：干货：<view class=\"pay\"><view class=\"title\">支付方式</view><view catchtap=\"wx_pay\" class=\"wx_pay\"><i class=\"icon {{payment_mode==1?'active':''}}\" type=\"String\"></i><text>微信支付</text></view><view catchtap=\"offline_pay\" class=\"offline_pay\"><i class=\"icon {{payment_mode==0?'active':''}}\" type=\"String\"></i><text>对公打款</text></view><block wx:if=\"{{balance!=0}}\"><view catchtap=\"wallet_pay\" class=\"wallet_pay\"><i class=\"icon {{payment_mode==2?'active':''}}\" type=\"String\"></i><text>钱包支付(余额:{{balance/100}}元)</text></view></block><block wx:if=\"{{balance==0}}\"><view class=\"wallet_pay\"><i class=\"icon\" type=\"String\" style=\"background:#e8e8e8;border:none;\"></i><text style=\"color:#999\">钱包支付(余额不足)</text></view></block></view><view catchtap=\"pay\" class=\"save\">确定</view><!--输入钱包密码--><view wx:if=\"{{wallets_password_flag}}\" class=\"wallets-password\"><view class=\"input-content-wrap\"><view class=\"top\"><view catchtap=\"close_wallets_password\" class=\"close\">×</view><view class=\"txt\">请输入支付密码</view><view catchtap=\"modify_password\" class=\"forget\">忘记密码</view></view><view class=\"actual_fee\"><span>￥</span><text>{{actual_fee/100}}</text></view><view catchtap=\"set_Focus\" class=\"input-password-wrap\"><view class=\"password_dot\"><i wx:if=\"{{wallets_password.length>=1}}\"></i></view><view class=\"password_dot\"><i wx:if=\"{{wallets_password.length>=2}}\"></i></view><view class=\"password_dot\"><i wx:if=\"{{wallets_password.length>=3}}\"></i></view><view class=\"password_dot\"><i wx:if=\"{{wallets_password.length>=4}}\"></i></view><view class=\"password_dot\"><i wx:if=\"{{wallets_password.length>=5}}\"></i></view><view class=\"password_dot\"><i wx:if=\"{{wallets_password.length>=6}}\"></i></view></view></view><input bindinput=\"set_wallets_password\" class=\"input-content\" password type=\"number\" focus=\"{{isFocus}}\" maxlength=\"6\" /></view>//index.jsPage({  data: {    payment_mode: 1,//默认支付方式 微信支付    isFocus: false,//控制input 聚焦    balance:100,//余额    actual_fee:20,//待支付    wallets_password_flag:false//密码输入遮罩  },  //事件处理函数  onLoad: function () {  },  wx_pay() {//转换为微信支付    this.setData({      payment_mode: 1    })  },  offline_pay() {//转换为转账支付    this.setData({      payment_mode: 0    })  },  wallet_pay() {    this.setData({//转换为钱包支付      payment_mode: 2    })  },  set_wallets_password(e) {//获取钱包密码    this.setData({      wallets_password: e.detail.value    });    if (this.data.wallets_password.length == 6) {//密码长度6位时，自动验证钱包支付结果      wallet_pay(this)    }  },  set_Focus() {//聚焦input    console.log('isFocus', this.data.isFocus)    this.setData({      isFocus: true    })  },  set_notFocus() {//失去焦点    this.setData({      isFocus: false    })  },  close_wallets_password () {//关闭钱包输入密码遮罩    this.setData({      isFocus: false,//失去焦点      wallets_password_flag: false,    })  },  pay() {//去支付    pay(this)  }})/*-----------------------------------------------*//*支付*/function pay(_this) {  let apikey = _this.data.apikey;  let id = _this.data.id;  let payment_mode = _this.data.payment_mode  if (payment_mode == 1) {  //  微信支付  // 微信自带密码输入框    console.log('微信支付')  } else if (payment_mode == 0) {  //  转账支付 后续跳转至传转账单照片    console.log('转账支付')  } else if (payment_mode == 2) {    // 钱包支付 输入密码    console.log('钱包支付')    _this.setData({      wallets_password_flag: true,      isFocus: true    })  }}// 钱包支付function wallet_pay(_this) {  console.log('钱包支付请求函数')  /*  1.支付成功  2.支付失败：提示；清空密码；自动聚焦isFocus:true，拉起键盘再次输入  */}index.wxsspage {  height: 100%;  width: 100%;  background: #e8e8e8;}page .pay {  display: flex;  flex-direction: column;  background: #fff;}page .pay .title {  height: 90rpx;  line-height: 90rpx;  font-size: 28rpx;  color: #353535;  padding: 0 23rpx;  border-bottom: 1rpx solid #ddd;  box-sizing: border-box;}page .pay .wx_pay, page .pay .offline_pay, page .pay .wallet_pay {  margin: 0 26rpx;  height: 90rpx;  line-height: 90rpx;  border-bottom: 2rpx solid #ddd;  box-sizing: border-box;  display: flex;  align-items: center;  justify-content: flex-start;}page .pay .wx_pay .icon, page .pay .offline_pay .icon,page .pay .wallet_pay .icon {  width: 34rpx;  height: 34rpx;  border: 2rpx solid #ddd;  box-sizing: border-box;  border-radius: 50%;}page .pay .wx_pay .icon.active, page .pay .offline_pay .icon.active,page .pay .wallet_pay .icon.active {  border: 10rpx solid #00a2ff;}page .pay .wx_pay text, page .pay .offline_pay text, page .pay .wallet_pay text {  margin-left: 20rpx;  color: #353535;  font-size: 26rpx;}page .pay .wallet_pay {  border: 0;  border-top: 2rpx solid #ddd;}page .pay .offline_pay {  border: 0 none;}page .save {  margin: 80rpx 23rpx;  color: #fff;  background: #00a2ff;  height: 88rpx;  line-height: 88rpx;  text-align: center;  font-size: 30rpx;  border-radius: 10rpx;}page .wallets-password {  position: absolute;  left: 0;  top: 0;  width: 100%;  height: 100%;  background: rgba(0, 0, 0, 0.6);}page .wallets-password .input-content-wrap {  position: absolute;  top: 200rpx;  left: 50%;  display: flex;  flex-direction: column;  width: 600rpx;  margin-left: -300rpx;  background: #fff;  border-radius: 20rpx;}page .wallets-password .input-content-wrap .top {  display: flex;  align-items: center;  height: 90rpx;  border-bottom: 2rpx solid #ddd;  justify-content: space-around;}page .wallets-password .input-content-wrap .top .close {  font-size: 44rpx;  color: #999;  font-weight: 100;}page .wallets-password .input-content-wrap .top .forget {  color: #00a2ff;  font-size: 22rpx;}page .wallets-password .input-content-wrap .actual_fee {  display: flex;  align-items: center;  justify-content: center;  color: #000;  height: 100rpx;  margin: 0 23rpx;  border-bottom: 2rpx solid #ddd;}page .wallets-password .input-content-wrap .actual_fee span {  font-size: 24rpx;}page .wallets-password .input-content-wrap .actual_fee text {  font-size: 36rpx;}page .wallets-password .input-content-wrap .input-password-wrap {  display: flex;  align-items: center;  justify-content: center;  height: 150rpx;}page .wallets-password .input-content-wrap .input-password-wrap .password_dot {  display: flex;  align-items: center;  justify-content: center;  text-align: center;  color: #000;  box-sizing: border-box;  width: 90rpx;  height: 90rpx;  border: 2rpx solid #ddd;  border-left: none 0;}page .wallets-password .input-content-wrap .input-password-wrap .password_dot:nth-child(1) {  border-left: 2rpx solid #ddd;}page .wallets-password .input-content-wrap .input-password-wrap .password_dot i {  background: #000;  border-radius: 50%;  width: 20rpx;  height: 20rpx;}page .wallets-password .input-content {  position: absolute;  opacity: 0;  left: -100%;  top: 600rpx;  background: #f56;  z-index: -999;}page .wallets-password .input-content.active {  z-index: -99;}github地址：-\">https://github.com/fiveTree/--"}
{"title": "微信小程序全屏模式（自定义导航栏） ", "author": "2019-5-6 00:53", "pub_time": "2019-5-6 00:53", "content": "导航栏背景图要自定义导航栏，首先需要在app.json里设置：{\"window\": {        \"navigationStyle\": \"custom\"    }}设置之后进入小程序就只剩下右上角的胶囊了。 在设置导航栏样式时需要知道它的高度，在app.json的onLaunch里获取状态栏高度：App({    onLaunch: function(options) {        wx.getSystemInfo({            success: (res) => {                this.globalData.statusBarHeight = res.statusBarHeight                this.globalData.navBarHeight = 44 + res.statusBarHeight            }        })    },    globalData: {        statusBarHeight: 0,        screenHeight: 0    }})44是导航栏除去状态栏的高度，单位px。 因为导航栏每个页面都会用到，所以我们用组件会方便使用一些，这里创建一个叫nav的组件： 首先在组件js里设置statusBarHeight和一个可以通过外部设置状态栏颜色的backgroundColor的属性，默认透明。 nav.js:const app = getApp()Component({    options: {        multipleSlots: true    },    properties: {        backgroundColor:{            type: String,            value: 'rgba(0,0,0,0)'        }    },    data: {},    ready() {        let {            statusBarHeight,            navBarHeight        } = app.globalData;        this.setData({            statusBarHeight,            navBarHeight        })    },    methods: {        back() {            wx.navigateBack({                delta:1            })        }    }})content里放置内容，返回按钮固定在左边。 nav.wxml:<view class='nav-wrap' style=\"background-color:{{bgColor}};\">    <view style=\"height:{{statusBarHeight}}px;\"></view>    <view class='content'>        <slot name=\"content\"></slot>        <view class='back' bindtap='back'></view>    </view></view>nav.wxss:.nav-wrap {    position: fixed;    top: 0;    left: 0;    width: 750rpx;    z-index: 1;}.content {    position: relative;    width: 100%;    height: 44px;}.back {    position: absolute;    left: 0;    top: 0;    width: 88px;    height: 44px;    background: pink;}在页面中使用：<nav bgColor=\"black\">    <view slot=\"content\">        <view class='txt'>Nav title</view>    </view></nav><view>page content</view>效果图：效果图这里txt里的样式、内容都是可以自定义的，如果想要使用通用样式，可以写在组件里。 比如把导航栏title放在组件里，通过外部传值设置： nav.js:Component({    // ...    properties: {        title:{            type: String,            value: ''        }    },    // ...})nav.wxml:<view class='nav-wrap' style=\"background-color:{{bgColor}};\">    <view style=\"height:{{statusBarHeight}}px;\"></view>    <view class='content'>        <view class=\"title\">{{title}}</view>        <view class='back' bindtap='back'></view>    </view></view>nav.wxss:/* ... */.title {    color: white;    text-align: center;    line-height: 44px;    font-weight: 500;}/* ... */调用就可以了。 在第一次使用nav组件的页面代码中，page content是看不见的，因为是直接从状态栏开始显示的，被nav挡住了。 这里可以加一个高度为导航栏高度的view当做顶部padding： nav.wxml<view class='nav-wrap' style=\"background-color:{{bgColor}};\">    <view style=\"height:{{statusBarHeight}}px;\"></view>    <view class='content'>        <view class=\"title\">{{title}}</view>        <view class='back' bindtap='back'></view>    </view></view><view wx:if=\"{{hastop}}\" class='padding' style=\"width:100;height:{{navBarHeight}}px;\"></view>这里在properties里设置了一个hastop，用来控制是否有顶部padding。 页面中：<nav bgColor=\"black\" title=\"Nav title\" hastop></nav><view>page content</view>这样就可以显示出来了：导航栏背景图 还可以做导航栏背景图，添加一个image，绝对定位放置在nav-wrap底部： nav.wxml<view class='nav-wrap' style=\"background-color:{{bgColor}};\">    <image class='bgimg' wx:if=\"{{bgsrc}}\" src='{{bgsrc}}' mode='aspectFill'></image>    <view style=\"height:{{statusBarHeight}}px;\"></view>    <view class='content'>        <view class='title'>{{title}}</view>        <view class='back' bindtap='back'></view>    </view></view><view wx:if=\"{{hastop}}\" class='padding' style=\"width:100;height:{{navBarHeight}}px;\"></view>nav.wxss.bgimg {    position: absolute;    left: 0;    top: 0;    width: 100%;    height: 100%;}页面：<nav bgColor=\"black\" title=\"Nav title\" hastop bgsrc=\"/images/bg.jpeg\"></nav><view>page content</view>导航栏背景图全屏背景 将bgColor、hastop、bgsrc都去掉，在页面中放置一个position: fixed;，并且铺满全屏的图片。<nav title=\"Nav title\"></nav><image class='pagebg' src='/images/bg.jpeg' mode='aspectFill'></image>全屏背景back的内容自定义就行了，我这里只是简单放置了一个色框。注意事项 官方文档中的注意事项：注1：HexColor（十六进制颜色值），如\"#ff00ff\" 注2：关于navigationStyle客户端 7.0.0 以下版本，navigationStyle 只在 app.json 中生效。 客户端 6.7.2 版本开始，navigationStyle: custom 对 组件无效 开启 custom 后，低版本客户端需要做好兼容。开发者工具基础库版本切到 1.7.0（不代表最低版本，只供调试用）可方便切到旧视觉"}
{"title": "[UI组件] 来做一个可配置的滑块进度条吧 ", "author": "2019-5-7 00:32", "pub_time": "2019-5-7 00:32", "content": "在一些需要用户填写资料的业务场景中，有时会让用户选择某个业务的范围，这时就需要用到滑块进度条。然后你们最爱的产品经理会说，给我整一个颜色可控，滑块按钮可大可小，滑块边框也要可大可小的滑动条来..emmm，一看这样的设计需求就意味着小程序原生的slider组件就不能用了。因为这玩意在样式上就不能自由的配置，只好来手动实现一个。结构设计行吧，那说干就干。首先滑动条可以从俯视图角度来看，分为三层。分别是底部滑轨区域，进度条区域以及供用户操作的滑块本身。在结构设计中，可以将底部滑轨区域，进度条区域分为一块，这样进度条区域可以根据随着滑动条的高度变化而变化, 宽度则由js控制。除此之外还需要暴露一些参数给外部，让它自己定义长粗宽。Component({\r\n    /**\r\n     * 组件的属性列表\r\n     */\r\n    properties: {\r\n        // 滑块大小\r\n        blockSize: {\r\n            type: Number,\r\n            value: 32,\r\n        },\r\n\r\n        // 滑块宽度\r\n        blockBorderWidth: {\r\n            type: Number,\r\n            value: 3\r\n        },\r\n\r\n        // 滑轨高度\r\n        height: {\r\n            type: Number,\r\n            value: 2\r\n        },\r\n\r\n        // 滑轨进度\r\n        step: {\r\n            type: Number,\r\n            value: 0,\r\n        },\r\n\r\n        // 进度值小数位\r\n        digits: {\r\n            type: Number,\r\n            value: 0,\r\n        },\r\n    },\r\n});<view id=\"slider-wrap\" class=\"slider-wrap\">\r\n    <view class=\"silder-bg\" style=\"height: {{height}}rpx;\">\r\n        <view  class=\"silder-bg-inner\"></view>\r\n    </view>\r\n    <view\r\n        class=\"silder-block\"\r\n        style=\"height: {{blockSize}}rpx; border-width: {{blockBorderWidth}}rpx;\"\r\n    ></view>\r\n</view>.slider-wrap {\r\n    position: relative;\r\n    display: flex;\r\n    align-items: center;\r\n    width: 100%;\r\n}\r\n\r\n.silder-bg,\r\n.silder-bg-inner,\r\n.silder-block {\r\n    position: absolute;\r\n    left: 0;\r\n}\r\n\r\n.silder-bg,\r\n.silder-bg-inner {\r\n    width: 100%;\r\n    height: 2rpx;\r\n    flex: 1;\r\n}\r\n\r\n.silder-bg {\r\n    overflow: hidden;\r\n    background-color: #eeeeee;\r\n    border-radius: 8rpx;\r\n    z-index: 0;\r\n}\r\n\r\n.silder-bg-inner {\r\n    height: 100%;\r\n    background-color: #66a6ff;\r\n    /* border-radius: 8rpx; */\r\n    z-index: 1;\r\n    border-bottom-left-radius: 8rpx;\r\n    border-top-left-radius: 8rpx;\r\n}\r\n\r\n.silder-block {\r\n    width: 32rpx;\r\n    height: 32rpx;\r\n    background-color: #ffffff;\r\n    border: solid 3rpx #66a6ff;\r\n    z-index: 2;\r\n    border-radius: 50%;\r\n    box-sizing: border-box;\r\n}\r\n点击行为事件滑块进度条的滑块是一个听话的小朋友，就是说我们叫它去哪它就听话的过去。所以就不要抓它去煲汤了~在组件外部容器中绑定一个点击事件，我们必须得要知道用户点击位置，在bind:tap事件中取到clientX属性。除此之外还需要取到进度条的位置信息。得到两个关键数据后，将用户点击的位置ClintX与进度条组件的偏移量offset相减，得出相对于组件内的进度progress.再用组件的宽度width减去progress乘于100得到目前进度的百分比percentage。同时为了防止进度条超出进度条如下图所示：((191 - 36) / 301) * 100 ≈ 52<view class=\"slider-wrap\" bindtap=\"tappingSlider\">\r\n    <!-- ...other -->\r\n</view>Component({\r\n    // ...\r\n\r\n    /**\r\n     * 组件的初始数据\r\n     */\r\n    data: {\r\n        containerInfo: null,\r\n        percentage: 0,\r\n    },\r\n\r\n    ready() {\r\n        // 取到滑块进度条的位置信息\r\n        wx.createSelectorQuery().in(this)\r\n            .select('.slider-wrap')\r\n            .boundingClientRect((rect) => {\r\n                if (!rect) return;\r\n\r\n                this.data.container = rect;\r\n                this._initBloackPos();\r\n            }).exec()\r\n    },\r\n\r\n    // 点击进度条\r\n    tappingSlider(evt) {\r\n        const { containerInfo } = this.data;\r\n        if (!containerInfo) return;\r\n\r\n        const { clientX } = evt.changedTouches[0];\r\n        const { digits, _maxDistance } = this.data;\r\n\r\n        // 需要做边界处理\r\n        const perc = this._computeOffset(clientX, containerInfo.left, 100);\r\n        const percentage = this._boundaryHandler(perc);\r\n\r\n        this.setData({ percentage });\r\n        this.triggerEvent('change', {\r\n              value: percentage.toFixed(digits) * 1\r\n          });\r\n    },\r\n\r\n    /**\r\n     * 计算相对容器的偏移距离\r\n     *\r\n     * @param { Number } x - X 坐标\r\n     * @param { Number } offset - 偏移量\r\n     * @param { Number } maxVal - 在 maxVal 范围内求百分比\r\n     */\r\n    _computeOffset(x, offset, maxVal) {\r\n        const { width } = this.data.containerInfo;\r\n\r\n        // 底层保证一定精度\r\n        return (((x - offset) / width) * maxVal).toFixed(4) * 1;\r\n    },\r\n\r\n    /**\r\n     * 边界处理\r\n     * @param { Number } num - 待处理的最值\r\n     * @param { Number } maxNum - num 最大值\r\n     * @param { Number } minNum - num 最小值\r\n     */\r\n    _boundaryHandler(num, maxNum = 100, minNum = 0) {\r\n        return num > maxNum ? maxNum : (num < minNum ? minNum : num);\r\n    },\r\n});<view class=\"slider-wrap\" bindtap=\"tappingSlider\" bindtouchmove=\"onTouchMove\">\r\n    <view class=\"silder-bg\" style=\"height: {{height}}rpx;\">\r\n        <view\r\n            class=\"silder-bg-inner\"\r\n            style=\"width: {{percentage}}%; height: {{height}}rpx;\"\r\n        ></view>\r\n    </view>\r\n    <view\r\n        class=\"silder-block\"\r\n        style=\"left: {{percentage}}%;width: {{blockSize}}rpx;height: {{blockSize}}rpx; border-width: {{blockBorderWidth}}rpx;\"\r\n    ></view>\r\n</view>虽然实现了点击滑动到指定位置的功能，但仔细一看还是有一些瑕疵的~ 当我们点击到百分百时，滑块超出原先设定的容器宽度。超出的原因是因为在布局上，我们使用绝对定位absolute，通过设置滑块left属性来控制滑块位置的。偏移量中还包含了滑块自身的宽度，因此还需要对滑块的偏移量做一定的处理，去掉自身宽度再获取百分比。在文章开头我们已经暴露了一个blockSize的属性，利用该属性可以计算滑块的最大偏移量：Component({\r\n    // ...\r\n    data: {\r\n        // other data...\r\n\r\n        _blockOffset: 0,\r\n        _maxDistance: 100,\r\n    },\r\n\r\n    methods: {\r\n        // 点击进度条\r\n        tappingSlider(evt) {\r\n            const { containerInfo } = this.data;\r\n            if (!containerInfo) return;\r\n\r\n            const { clientX } = evt.changedTouches[0];\r\n            const { digits, _maxDistance } = this.data;\r\n            const computeOffset = (maxVal) => {\r\n                return this._computeOffset(clientX, containerInfo.left, maxVal);\r\n            }\r\n\r\n            // 滑块偏移度\r\n            const _blockOffset = this._boundaryHandler(\r\n                computeOffset(_maxDistance), _maxDistance\r\n            );\r\n\r\n            // 实际百分比\r\n            const percentage = this._boundaryHandler(computeOffset(100));\r\n\r\n            this.setData({ _blockOffset, percentage });\r\n            this.triggerEvent('change', { value: percentage.toFixed(digits) * 1 });\r\n        },\r\n    }\r\n\r\n})<!-- other code -->\r\n<view\r\n    class=\"silder-block\"\r\n    style=\"left: {{_blockOffset}}%;width: {{blockSize}}rpx;height: {{blockSize}}rpx; border-width: {{blockBorderWidth}}rpx;\"\r\n></view>如此，该事件就完成啦~滑动事件完成点击事件后，我们还得让它能进行自由的滑动。进度条组件的拖动的流程大致是：点击滑块 -> 拖动滑块 -> 释放滑块这三个步骤。因此跟H5的思路一样，我们只需监听touchmove、touchstatr、touchend三个事件。首先先监听touchmove，用户点击滑块后，记录当前的clientX属性, 随后还需要记录当前进度和滑块的偏移量；touchmove事件则由外层容器相关联，并更新滑动的距离。由于touchmove里针对拖动事件逻辑不能被随便触发，因此需要加一个标识的锁；在touchend事件触发后释放锁即可：Component({\r\n    methods: {\r\n        onTouchStart(evt) {\r\n            this.data.moving = true;\r\n\r\n            // 记录原始坐标\r\n            this.data.originPos = this.data._blockOffset;\r\n            this.data.originPercentage = this.data.percentage;\r\n\r\n            this.data._startTouchX = evt.changedTouches[0].clientX;\r\n        },\r\n\r\n        // 滑块移动\r\n        onTouchMove(evt) {\r\n            const { moving, containerInfo } = this.data;\r\n            if (!moving || !containerInfo) return;\r\n\r\n            const { clientX } = evt.changedTouches[0];\r\n            const {\r\n                digits,\r\n                originPos,\r\n                originPercentage,\r\n                _startTouchX,\r\n                _maxDistance\r\n            } = this.data;\r\n\r\n            // 计算偏移量\r\n            const computeOffset = (maxVal) => {\r\n                return this._computeOffset(clientX, _startTouchX, maxVal);\r\n            }\r\n\r\n            // 实际百分比\r\n            const perc = originPercentage + computeOffset(100);\r\n            const percentage = this._boundaryHandler(perc);\r\n\r\n            // 滑块偏移度\r\n            const offset = originPos + computeOffset(_maxDistance);\r\n            const _blockOffset = this._boundaryHandler(offset, _maxDistance);\r\n\r\n            this.setData({ percentage, _blockOffset });\r\n            this.triggerEvent('change', {\r\n                value: percentage.toFixed(digits) * 1\r\n            });\r\n        },\r\n\r\n        onTouchEnd(evt) {\r\n            this.data.moving = false;\r\n        },\r\n    }\r\n})<view class=\"slider-wrap\" bindtap=\"tappingSlider\" bindtouchmove=\"onTouchMove\">\r\n    <view class=\"silder-bg\" style=\"height: {{height}}rpx;\">\r\n        <view\r\n            class=\"silder-bg-inner\"\r\n            style=\"width: {{percentage}}%; height: {{height}}rpx;\"\r\n        ></view>\r\n    </view>\r\n    <view\r\n        class=\"silder-block\"\r\n        style=\"left: {{_blockOffset}}%;width: {{blockSize}}rpx;height: {{blockSize}}rpx; border-width: {{blockBorderWidth}}rpx;\"\r\n        bindtouchstart=\"onTouchStart\"\r\n        bindtouchend=\"onTouchEnd\"\r\n    ></view>\r\n</view>总结以上就是滑块进度条组件的实现~ 实际上该组件还有更多可供配置的地方，如颜色值，背景控制等这些比较基础的东西就不继续展开讲啦~本文是以小程序进行示例。但思路是共通的，也可以使用同样思路在H5实现，只不过是 API 的差异罢了~微信代码片段, 可以直接拿来就用。2019/05/04 更新：后面又重新看了一遍，发现该组件还是有可优化的空间：操作不必局限于滑块上，可以将bindtap事件废弃，其余的所有事件都代理到最外部的节点中。touchstar的同时就渲染位置信息，还允许它自由的滑动:<view class=\"slider-wrap\"\r\n    bindtouchstart=\"onTouchStart\"\r\n    bindtouchmove=\"onTouchMove\"\r\n    bindtouchend=\"onTouchEnd\"\r\n>\r\n    <view class=\"silder-bg\" style=\"height: {{height}}rpx;\">\r\n        <view\r\n            class=\"silder-bg-inner\"\r\n            style=\"width: {{percentage}}%; height: {{height}}rpx;\"\r\n        ></view>\r\n    </view>\r\n    <view\r\n        class=\"silder-block\"\r\n        style=\"left: {{_blockOffset}}%;width: {{blockSize}}rpx;height: {{blockSize}}rpx; border-width: {{blockBorderWidth}}rpx;\"\r\n    ></view>\r\n</view>Component({\r\n    // other options ...\r\n\r\n    methods: {\r\n        // other method ...\r\n        onTouchStart(evt) {\r\n            this.data.moving = true;\r\n\r\n            const { containerInfo } = this.data;\r\n            if (!containerInfo) return;\r\n\r\n            const { clientX } = evt.changedTouches[0];\r\n            const { digits, _maxDistance } = this.data;\r\n            const computeOffset = (maxVal) => {\r\n                return this._computeOffset(clientX, containerInfo.left, maxVal);\r\n            }\r\n\r\n            // 滑块偏移度\r\n            const _blockOffset = this._boundaryHandler(\r\n                computeOffset(_maxDistance), _maxDistance\r\n            );\r\n\r\n            // 实际百分比\r\n            const percentage = this._boundaryHandler(computeOffset(100));\r\n\r\n            // 记录原始坐标\r\n            this.data.originPos = _blockOffset;\r\n            this.data.originPercentage = percentage;\r\n\r\n            this.data._startTouchX = clientX;\r\n\r\n            this.setData({ _blockOffset, percentage });\r\n            this.triggerEvent('change', { value: percentage.toFixed(digits) * 1 });\r\n        },\r\n    }\r\n});微信代码片段 v0.0.2"}
{"title": "微信小程序--发表评价满意度 ", "author": "2019-5-7 00:46", "pub_time": "2019-5-7 00:46", "content": "话不多说，我们来看一下效果图：要实现的效果：点击到第几颗星，就要显示到第几颗星,接下来直接查看源码：<view class=\"l-evalbox row\">    <text class=\"l-evaltxt\">满意度：</text>    <view class=\"l-evalist flex-1\" bindtap=\"chooseicon\">        <icon class=\"{{tabArr.curHdIndex >'0'? 'cur icon' : 'icon'}}\" data-id=\"1\"></icon>        <icon class=\"{{tabArr.curHdIndex >'1'? 'cur icon' : 'icon'}}\" data-id=\"2\"></icon>        <icon class=\"{{tabArr.curHdIndex >'2'? 'cur icon' : 'icon'}}\" data-id=\"3\"></icon>        <icon class=\"{{tabArr.curHdIndex >'3'? 'cur icon' : 'icon'}}\" data-id=\"4\"></icon>        <icon class=\"{{tabArr.curHdIndex >'4'? 'cur icon' : 'icon'}}\" data-id=\"5\"></icon>    </view></view>css如下：.l-evalbox{    height: 100rpx;    padding: 0 3%;    margin-top: 10rpx;    background: #FFF;    line-height: 100rpx;}.l-evaltxt{    width: 120rpx;    display: block;    font-size: 26rpx;    color: #666666;}.l-evalist .icon{    background-position:  -77rpx -246rpx;    width: 40rpx;    height: 43rpx;    margin-right: 30rpx;}.l-evalist .cur{    background-position:  -128rpx -246rpx;}.l-evalist .icon:last-child{    margin: 0;}js代码如下：chooseicon:function(e){    var strnumber=e.target.dataset.id;       var _obj={};        _obj.curHdIndex=strnumber;         this.setData({           tabArr: _obj        });  },这样效果显示如下："}
{"title": "微信小程序之数据访问 ", "author": "2019-5-7 00:56", "pub_time": "2019-5-7 00:56", "content": "先简单说一下，小程序的结构如图所示1、每个视图(.wxml)只需要添加对应名字的脚本（.js）和样式（.wxss）就可以了，不需要引用，page下面的脚本以及样式都是继承至最外面的app.js , app.wxcss2、脚本也就是.js文件，他有固定格式：page，是用于获取数据的3、utils是用来放置数据接口的--------------------------------------------华丽的分割线--------------------------------------------------------数据访问，如果懂点ajax，都不是问题，没啥好讲的微信小程序，因为IDE太烂了，如果代码再写得难以阅读，整个项目就很难维护了。因为没有写过app，不知道在app中数据访问是怎么封装的作为一个有3天工作经验的小程序码农，觉得如果每个页面的数据都是自己去访问数据接口，那就太不OOP了然后想到了linq to sql，只取了其中的两个方法，原本打算用singelordefault，firstordefault的，想想也麻烦，就用了getbyparams,getbyid，根据条件查找出所有数据，或者根据id获取一条数据直接看方法吧，有点啰嗦了const API_URL = 'http://localhost:4424/api/'function getApi(url,params){  return new Promise((res,rej)=>{    wx.request({      url:API_URL+'/'+url,      data:Object.assign({},params),      header:{'Content-Type': 'application/json'},      success:res,      fail:rej    })  })}module.exports = {  GetByParams(url,page=1,pageSize=20,search = ''){    const params = { start: (page - 1) * pageSize, pageSize: pageSize }    return getApi(url, search ? Object.assign(params, { q: search }) : params)      .then(res => res.data)  },  GetById(url,id){    return getApi(url, id)      .then(res => res.data)  }}module.exports = {}是固定写法，里面写一个一个的方法，每个方法用,隔开。 我设置了一个url参数，因为不可能把所有的接口都放在一个conntroller里面，所以url的格式是“conntroller/action”看一个调用的栗子吧，就明白怎么用了const req = require('../../utils/util.js')Page({  data: {    imgUrls: [],    indicatorDots: true,    autoplay: true,    interval: 2000,    duration: 2000  },  onLoad(){    req.GetByParams('home/homebanner')//看这里   看这里   看这里    .then(d=>this.setData({imgUrls:d,loading:false}))    .catch(e=>{      this.setData({imgUrls:[],loading:false})    })  }})这是index的获取banner图的方法，req.GetByParams('home/homebanner')，这里也可以带参数，也可以空着最终的页面是这样的在右边的红色框里面，我们可以看到请求返回的数据，也可以在右边修改数据，界面会跟随着变化，这是关于调试的事情了，容后再议。"}
{"title": "小程序富文本解析的「伪需求」，从wxParse到towxml的坑 ", "author": "2019-5-9 00:48", "pub_time": "2019-5-9 00:48", "content": "本文主要谈谈小程序的富文本解析和目前我的博客小程序用到的两款开源组件 wxParse 和 towxml富文本「伪需求」在进入正题之前想先聊聊「伪需求」这三个字。其实有很多场景会用到富文本框「通常后台维护一长串html文本，前台进行渲染展示」。但由于小程序的一些特殊性，无法直接渲染html，因此类似 wxParse 的开源组件诞生了「原理无非是穷举标签进行替换，差异在于覆盖是否全面和是否更加高效」在小程序刚出来的时候，富文本的问题也一直被吐槽，直到 web-view 的出现「承载网页的容器。会自动铺满整个小程序页面」。小程序终于可以「直接」渲染网页了，很多公司也利用这一点，很多页面都直接采用H5的方式开发，嵌套进小程序中。然而比较悲催的是 web-view 有个限制：个人类型与海外类型的小程序暂不支持使用。所以对于个人开发的小程序来说，依旧需要依赖类似 wxParse 的开源组件。wxParse还是towxml在基于 ghost 的博客小程序中，我用的是 wxParse ，截止到发文该项目已有6071个star，很多教程也是基于 wxParse 的，但作者似乎已经弃坑了，两年多没有再进行迭代了，所以该组件也存在很多问题。自己的项目也是在 wxParse 基础之上进行了很多改动。所以在开发新版的小程序时候果断找个替换它，可惜的是目前这类的开源组件不多「比较小众吧，只有个人开发者才会用吧」，比较之后发现还是 towxml 最佳。首先解析比较全面，样式也比较完美，对于公众号花哨的排版基本支持「只能是基本，后面会说到坑」。另外一点支持服务端解析「云函数可以利用起来」。唯一遗憾的是，体积还是比较大的，后面功能完善后打算看下它的源码进行相应的瘦身。如何使用towxml使用 towxml 还是比较简单的，网上有很多教程，这里简单说下基于服务端解析、小程序端直接渲染的方式：首先下载源码，将 towxml 整个文件夹放到小程序的根目录下。然后在 app.js 中引入并初始化：const Towxml = require('/towxml/main'); \r\nApp({           \r\n  onLaunch: function () {\r\n    ...\r\n  },\r\n  towxml:new Towxml(),\r\n  checkUserInfo: function(cb) {\r\n    ...\r\n  },\r\n  globalData: {\r\n    openid: \"\",\r\n    userInfo: null\r\n  }\r\n})接着在需要使用的地方引入模板，比如我的 detail.wxml 下：<import src=\"/towxml/entry.wxml\" />\r\n//post.content是解析后的文本\r\n<template is=\"entry\" data=\"{{...post.content}}\" />在云函数端，首先安装 towxml :npm install towxml然后申明后直接进项解析，代码如下：/**\r\n * 获取文章明细\r\n * @param {} id \r\n */\r\nasync function getPostsDetail(event) {\r\n  let post = await db.collection(\"mini_posts\").doc(event.id).get()\r\n  if (post.code) {\r\n    return \"\";\r\n  }\r\n  if (!post.data) {\r\n    return \"\";\r\n  }\r\n\r\n  let content = await convertPosts(post.data.content, \"html\");\r\n  //直接赋值towxml解析后的文本\r\n  post.data.content = content;\r\n  console.info(result)\r\n  return post.data\r\n}\r\n\r\n/**\r\n * 转换下程序文章\r\n * @param {} isUpdate \r\n */\r\nasync function convertPosts(content, type) {\r\n  let res\r\n  if (type === 'markdown') {\r\n    res = await towxml.toJson(content || '', 'markdown');\r\n  } else {\r\n    res = await towxml.toJson(content || '', 'html');\r\n  }\r\n  return res;\r\n\r\n}到这里，文章应该可以正常渲染了，使用起来相对还是比较简单的。towxml的坑准确来说是公众号文章的html一些特殊性和复杂性，导致在解析渲染的时候样式上存在一些问题。首先遇到的问题，图片展示不了，如下截图：在查看解析后的文本json后发现， img 的 src 属性是空的。再回过头看公众号文章原始的 html 的时候发现，原始的 img 标签下的属性都是 data-src 开始的，难怪无法解析。<img class=\"\"\r\ndata-ratio=\"2.1638888888888888\" data-src=\"https://mmbiz.qpic.cn/mmbiz_jpg/ibT18LpyNmXqYXfbcbQ7N4kIeJYWSEzDHMDwmbNMUBvaRP7U2zwib9ladYZ2v5mZ1rLRFP2NnCtEuPzs3ibrsKqGQ/640?wx_fmt=jpeg\"\r\ndata-type=\"jpeg\" data-w=\"1080\"title=\"image\">水平不够无法改 towxml 的源码，只能在同步文章的时候做下手脚,将 data-src 替换成 src//替换图片data-url\r\ncontent=content.replace(/data-src/g,\"src\")然后发现公众号自带的代码片段样式解析之后也存在问题，截图如下,在代码上方多了很多点。有了图片不展示的经验，就比较容易定位问题了，应该是towxml在解析代码序号的时候生成 ul 和 li 标签了，但在样式上没有做好处理。<ul class=\"code-snippet__line-index code-snippet__js\"><li></li></ul>于是在同步文章的时候也进行一些替换：//移除公众号代码片段序号\r\nlet content=content.replace(<ul class=\"code-snippet__line-index code-snippet__js\".*?<\\/ul>/g,'')目前解析过程中还有两个问题不太友好，后期需要尝试解决：第一个是部分图片依旧不会展示，原因已经定位到， img 标签之外嵌套了以下 span 标签之后，图片就不会展示「使用新媒体管家进行排版时会出现」<span style=\"color:rgba(0, 0, 0, 0);\">\r\n<span style=\"line-height: inherit;margin-right: auto;margin-left: auto;border-radius: 4px;\">另一个是部分解析出来的代码片段没有换行「使用 Md2All 进行样式转换的文章」总结但愿小程序后期官方出个比较全面的富文本组件吧，这样可以少绕很多弯路去实现简单的功能。"}
{"title": "小程序的一些小知识总结 ", "author": "2019-5-9 00:51", "pub_time": "2019-5-9 00:51", "content": "小程序很多方法都是异步的原因刚接触小程序的时候，发现很多微信提供的api都是异步的，如路由跳转，设置和读取缓存，还有获取节点信息等微信的api，都是异步的，需要传入回调函数才能获得结果，在我们正常的前端开发中，这些都不是异步的，当时很奇怪为什么是这样的，最近看了微信的一个开发教程之后，总算是明白了。 微信小程序开发教程小程序的底层架构是双线程模式，逻辑层和渲染层是分开的两个线程，渲染层指的就是渲染wxml和wxss，逻辑层指的是执行js文件，两个线程分开运行，通过微信客户端进行通信，调用微信的api的时候其实就是执行js的线程和微信客户端通信下图是微信官方文档里渲染页面的一个流程图注意事项：上述说了，小程序的渲染层和逻辑层是分开的两个线程，执行js逻辑的只有一个线程，所以在js里声明了的函数，只要有调用，就算页面卸载了，最终都会执行，所以要注意的是，一些interval，或者一些注册的其他函数，如果不想在页面离开后继续执行的话，在页面卸载的时候要注销掉。发布和订阅模式先补充一个知识点：在小程序的appjs的onLaunch里，给全局变量wx添加的属性，是全局有效的，能在其他页面中调用，比如：onLaunch: function () {\r\n    wx.aaa = '123456'; \r\n    wx.bbb = function () { console.log('541521') }\r\n}\r\n\r\n\r\nonLoad: function () {\r\n    console.log(wx.aaa);\r\n    wx.bbb();\r\n}之前对发布和订阅一直没什么概念，但是多学点东西总没坏处，近期自己花了点时间专门看了一下，大概明白了一点。订阅：订阅就是在某个地方注册一个自定义的事件，供其他地方调用发布：触发已经订阅的函数下面是我写的一个方法，可能会有一些bug，但是目前没有发现，要是有问题的话欢迎交流一下var MyEvent = (function () {\r\n  // 声明方法\r\n  var pub, sub, remove;\r\n\r\n  // 订阅缓存记录\r\n  var subCache = {};\r\n  // 发布缓存记录\r\n  var pubCache = {};\r\n  // 参数缓存\r\n  var paramCache = {};\r\n\r\n  // 订阅事件\r\n  sub = function (key, fn) {\r\n    if (!subCache[key]) {\r\n      subCache[key] = [];\r\n    }\r\n    // 添加到订阅缓存中\r\n    subCache[key].push(fn);\r\n    // 如果有发布记录，则直接执行函数\r\n    if (pubCache[key]) {\r\n      if (paramCache[key]) {\r\n        fn.apply(null, paramCache[key]);\r\n      } else {\r\n        fn.apply(null);\r\n      }\r\n      pubCache[key] = undefined;\r\n    }\r\n  };\r\n  pub = function () {\r\n    var key = Array.prototype.shift.call(arguments);\r\n    var fns = subCache[key];\r\n    // 没有订阅过，则将参数缓存，待订阅的时候直接执行\r\n    if (!fns || fns.length === 0) {\r\n      pubCache[key] = true;\r\n      paramCache[key] = Array.prototype.slice.call(arguments, 0);\r\n      return;\r\n    }\r\n    // 有订阅记录，则直接执行\r\n    for (let fn of fns) {\r\n      fn.apply(null, arguments);\r\n    }\r\n  };\r\n  remove = function (key) {\r\n    // 把所有的缓存全部清除\r\n    subCache[key] = undefined;\r\n    pubCache[key] = undefined;\r\n    paramCache[key] = undefined;\r\n  };\r\n  return {\r\n    pub: pub,\r\n    sub: sub,\r\n    remove: remove\r\n  };\r\n})();\r\n\r\nmodule.exports = MyEvent;使用方法如下：在appjs里引入MyEvent，并挂载在wx对象上App({\r\n  onLaunch: function () {\r\n    const MyEvent = require('myEvent的路径');\r\n    wx.myEvent = MyEvent;\r\n  }\r\n})在其中页面页面1的onShow里订阅test1事件，发布test2事件onLoad: function(){\r\n    wx.myEvent.sub('test1', function () {\r\n        console.log('test1');\r\n    });\r\n},\r\nonShow: function () {\r\n    wx.myEvent.pub('test2', 'test2' + new Date().getTime());\r\n}在页面2的onLoad事件里，发布test1事件，订阅test2事件onLoad: function(options) {\r\n    wx.myEvent.pub('test1');\r\n    wx.myEvent.sub('test2', function(a){\r\n      console.log(a);\r\n    });\r\n}一. 在页面1的时候，执行了订阅test1事件，发布了test2事件，但是test1没有发布，订阅的事件不会执行，test2事件没有订阅，也不会执行。二. 从页面1跳转到页面2，发布了test1事件，直接执行之前已经注册好的test1事件，订阅test2事件，因为有test2的发布事件，订阅之后直接执行，结果是打印一次test1，打印一次test2。三. 从页面2返回到页面1，执行onShow事件，再次发布test2事件，打印一次test2四. 从页面1到页面2，发布了test1事件，事件test2重复订阅了，订阅了两次，打印一次test1。五. 从页面2返回页面1，发布test2，因为test2事件订阅了两次，所以打印了两次test2，所以要注意在不需要的地方把事件注销。在页面2的onUnload事件里把事件test2注销掉，在从页面2回到页面1的时候，事件test2已经注销了，不会再执行。onUnload: function() {\r\n    wx.myEvent.remove('test2');\r\n}原理和用法说明：原理：全局只有一个wx对象，将myEvent挂载在wx上，所以全局也只有一个wx.myEvent对象，myEvent里用到了闭包，订阅的函数和参数都有保存在内存里，所以能实现订阅和发布的功能。目前事件订阅是用的数组存储，可实现同一个事件订阅多次，如果不需要的话可自行修改成只能订阅一次的方法。用法：一般用于跨页面的操作，比如在某个页面订阅某个事件，在另一份页面执行了某项操作之后，发布该事件，会直接执行订阅的事件，实现页面间的一些数据传递。还有也可用于异步请求，先订阅某个事件，异步请求数据，请求数据回来之后，再发布。待补充......"}
{"title": "记一次心血来潮的小程序开发 ", "author": "2019-5-10 00:09", "pub_time": "2019-5-10 00:09", "content": "前言：最近新出了一款游戏叫做明日方舟，其中有个系统是招募干员，于是乎就想做一个提供招募参考的小程序应用。开撸。招募系统会提供5个tag(标签)让你选择最多三个，然后根据选择的tag数量和时间判断消耗的系统的龙门币（游戏中最稀缺的一种资源，笑）然后要做到参考，最简单的一种实现是提供系统所有tag然后自己选出5个生成一个包含5个tag所有可能组合出来的干员列表再自己根据情况选择组合的tag。 以上就是这个需求的基本内容。1 准备1 获取所有干员的标签数据。利用爬虫从网站上爬取。使用mysql存储。 2 设计一套api接口提供小程序查询，小程序使用的接口都需要https。利用express+docker+nginx搭一套后台。 3 小程序本身。打算利用之前比较火的taro实践下。2 数据爬取通过百度找到一个看起来数据够用的网站 根据页面内容，分析出在这个列表页可以直接获取所有详情页，然后利用Puppeteer爬了数据到mysql。2.1 Puppeteer爬虫分析打开控制台，查看页面结构发现页面所有数据都写在页面里了，没有走接口，爬页面就可以了 然后详情页通过同样的方法即可获取到数据。2.2 数据模型建立这里就根据实际情况建立模型就好了简单的定义模型方便记录，细心的朋友可能会讲，性别，类型这种是不是定义成数字类型然后加个字典会更好啊？嗯，这点其实开始的时候我也是这么想的，但考虑到后面数据处理起来的繁琐步骤，就免了，没必要设计太复杂。3 后台搭建通过开发工具express-generator搭建一个简易框架，然后再开发两个简单接口，一个查询所有标签，一个根据提供标签返回组合数据 然后到docker部分，利用docker-compose把项目部署到nginx上，由于之前已经申请过域名，直接使用域名就ok了。https的证书在阿里云上直接申请免费版。3.1 后台开发过程基于技术选型，这里只要routes就好，配合mysql和一些业务逻辑，基本就没什么好说了。 这部分考虑到我是小前端，就不贴图让大家见笑了。4 小程序开发taro还是很好上手的，根据文档直接搭框架，根据需求开发就好了。4.1 taro使用体验初见感觉很不错，用起来也挺爽的。但是，问题来了，看似很全的文档很多坑，例如：CheckBox的组件这个常用组件只提供的api中onchange不背小程序支持。那么如果要用怎么办？只能自己写或者换实现了。最后选择自己搞个组件实现类似功能了。4.2 发布小程序小程序开发工具中上传，登录网页后台提交审核，等审核过了就可以体验了。5 总结5月7号晚上8点开始有想法然后动手，到现在提交审核后静下心写下记录全程48小时不到（当然有正常作息），感觉效率还算不错。 你问我不用上班吗？哦，最近在等入职，之前在看springboot相关的内容，所以时间还是蛮充裕的。以及在开发完发现小程序现在提供数据库支持了，自己连mysql和后台可能都不用搭建就可以直接上了，可惜已经都写好就不折腾了。 最后看看大致的效果图。"}
{"title": "浅谈小程序运行机制 ", "author": "2019-5-10 00:33", "pub_time": "2019-5-10 00:33", "content": "写作背景接触小程序有一段时间了，总得来说小程序开发门槛比较低，但其中基本的运行机制和原理还是要懂的。“比如我在面试的时候问到一个关于小程序的问题，问小程序有window对象吗？他说有吧”，但其实是没有的。感觉他并没有了解小程序底层的一些东西，归根结底来说应该只能算会使用这个工具，但并不明白其中的道理。小程序与普通网页开发是有很大差别的，这就要从它的技术架构底层去剖析了。还有比如习惯Vue，react开发的开发者会吐槽小程序新建页面的繁琐，page必须由多个文件组成、组件化支持不完善、每次更改 data 里的数据都得setData、没有像Vue方便的watch监听、不能操作Dom，对于复杂性场景不太好，之前不支持npm，不支持sass，less预编译处理语言。“有的人说小程序就像被阉割的Vue”，哈哈当然了，他们从设计的出发点就不同，咱也得理解小程序设计的初衷，通过它的使用场景，它为什么采用这种技术架构，这种技术架构有什么好处，相信在你了解完这些之后，就会理解了。下面我会从以下几个角度去分析小程序的运行机制和它的整体技术架构。了解小程序的由来在小程序没有出来之前，最初微信WebView逐渐成为移动web重要入口，微信发布了一整套网页开发工具包，称之为 JS-SDK，给所有的 Web 开发者打开了一扇全新的窗户，让所有开发者都可以使用到微信的原生能力，去完成一些之前做不到或者难以做到的事情。但JS-SDK 的模式并没有解决使用移动网页遇到的体验不良的问题，比如受限于设备性能和网络速度，会出现白屏的可能。因此又设计了一个增强版JS-SDK，也就是“微信 Web 资源离线存储”，但在复杂的页面上依然会出现白屏的问题，原因表现在页面切换的生硬和点击的迟滞感。这个时候需要一个 JS-SDK 所处理不了的，使用户体验更好的一个系统，小程序应运而生。快速的加载更强大的能力原生的体验易用且安全的微信数据开放高效和简单的开发小程序与普通网页开发的区别小程序的开发同普通的网页开发相比有很大的相似性，小程序的主要开发语言也是 JavaScript，但是二者还是有些差别的。普通网页开发可以使用各种浏览器提供的 DOM API，进行 DOM 操作，小程序的逻辑层和渲染层是分开的，逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，因而缺少相关的DOM API和BOM API。普通网页开发渲染线程和脚本线程是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应，而在小程序中，二者是分开的，分别运行在不同的线程中。网页开发者在开发网页的时候，只需要使用到浏览器，并且搭配上一些辅助工具或者编辑器即可。小程序的开发则有所不同，需要经过申请小程序帐号、安装小程序开发者工具、配置项目等等过程方可完成。小程序的执行环境小程序架构一、技术选型一般来说，渲染界面的技术有三种：用纯客户端原生技术来渲染用纯 Web 技术来渲染用客户端原生技术与 Web 技术结合的混合技术（简称 Hybrid 技术）来渲染通过以下几个方面分析，小程序采用哪种技术方案开发门槛：Web 门槛低，Native 也有像 RN 这样的框架支持体验：Native 体验比 Web 要好太多，Hybrid 在一定程度上比 Web 接近原生体验版本更新：Web 支持在线更新，Native 则需要打包到微信一起审核发布管控和安全：Web 可跳转或是改变页面内容，存在一些不可控因素和安全风险由于小程序的宿主环境是微信，如果用纯客户端原生技术来编写小程序，那么小程序代码每次都需要与微信代码一起发版，这种方式肯定是不行的。所以需要像web技术那样，有一份随时可更新的资源包放在云端，通过下载到本地，动态执行后即可渲染出界面。如果用纯web技术来渲染小程序，在一些复杂的交互上可能会面临一些性能问题，这是因为在web技术中，UI渲染跟JavaScript的脚本执行都在一个单线程中执行，这就容易导致一些逻辑任务抢占UI渲染的资源。所以最终采用了两者结合起来的Hybrid 技术来渲染小程序，可以用一种近似web的方式来开发，并且可以实现在线更新代码，同时引入组件也有以下好处：扩展 Web 的能力。比如像输入框组件（input, textarea）有更好地控制键盘的能力体验更好，同时也减轻 WebView 的渲染工作绕过 setData、数据通信和重渲染流程，使渲染性能更好用客户端原生渲染内置一些复杂组件，可以提供更好的性能二、双线程模型小程序的渲染层和逻辑层分别由 2 个线程管理：视图层的界面使用了 WebView 进行渲染，逻辑层采用 JsCore 线程运行 JS脚本。那么为什么要这样设计呢，前面也提到了管控和安全，为了解决这些问题，我们需要阻止开发者使用一些，例如浏览器的window对象，跳转页面、操作DOM、动态执行脚本的开放性接口。我们可以使用客户端系统的 JavaScript 引擎，iOS 下的 JavaScriptCore 框架，安卓下腾讯 x5 内核提供的 JsCore 环境。这个沙箱环境只提供纯 JavaScript 的解释执行环境，没有任何浏览器相关接口。这就是小程序双线程模型的由来：逻辑层：创建一个单独的线程去执行 JavaScript，在这里执行的都是有关小程序业务逻辑的代码，负责逻辑处理、数据请求、接口调用等视图层：界面渲染相关的任务全都在 WebView 线程里执行，通过逻辑层代码去控制渲染哪些界面。一个小程序存在多个界面，所以视图层存在多个 WebView 线程JSBridge 起到架起上层开发与Native（系统层）的桥梁，使得小程序可通过API使用原生的功能，且部分组件为原生组件实现，从而有良好体验三、双线程通信把开发者的 JS 逻辑代码放到单独的线程去运行，但在 Webview 线程里，开发者就没法直接操作 DOM。那要怎么去实现动态更改界面呢？如上图所示，逻辑层和试图层的通信会由 Native （微信客户端）做中转，逻辑层发送网络请求也经由 Native 转发。这也就是说，我们可以把 DOM 的更新通过简单的数据通信来实现。Virtual DOM 相信大家都已有了解，大概是这么个过程： 用 JS 对象模拟 DOM 树 -> 比较两棵虚拟 DOM 树的差异 -> 把差异应用到真正的 DOM 树上。如图所示：1. 在渲染层把 WXML 转化成对应的 JS 对象。2. 在逻辑层发生数据变更的时候，通过宿主环境提供的 setData 方法把数据从逻辑层传递到 Native，再转发到渲染层。3. 经过对比前后差异，把差异应用在原来的 DOM 树上，更新界面。我们通过把 WXML 转化为数据，通过 Native 进行转发，来实现逻辑层和渲染层的交互和通信。而这样一个完整的框架，离不开小程序的基础库。四、小程序的基础库小程序的基础库可以被注入到视图层和逻辑层运行，主要用于以下几个方面：在视图层，提供各类组件来组建界面的元素在逻辑层，提供各类 API 来处理各种逻辑处理数据绑定、组件系统、事件系统、通信系统等一系列框架逻辑由于小程序的渲染层和逻辑层是两个线程管理，两个线程各自注入了基础库。小程序的基础库不会被打包在某个小程序的代码包里边，它会被提前内置在微信客户端。这样可以：降低业务小程序的代码包大小可以单独修复基础库中的 Bug，无需修改到业务小程序的代码包五、Exparser 框架Exparser是微信小程序的组件组织框架，内置在小程序基础库中，为小程序的各种组件提供基础的支持。小程序内的所有组件，包括内置组件和自定义组件，都由Exparser组织管理。Exparser的主要特点包括以下几点：基于Shadow DOM模型：模型上与WebComponents的ShadowDOM高度相似，但不依赖浏览器的原生支持，也没有其他依赖库；实现时，还针对性地增加了其他API以支持小程序组件编程。可在纯JS环境中运行：这意味着逻辑层也具有一定的组件树组织能力。高效轻量：性能表现好，在组件实例极多的环境下表现尤其优异，同时代码尺寸也较小。小程序中，所有节点树相关的操作都依赖于Exparser，包括WXML到页面最终节点树的构建、createSelectorQuery调用和自定义组件特性等。内置组件基于Exparser框架，小程序内置了一套组件，提供了视图容器类、表单类、导航类、媒体类、开放类等几十种组件。有了这么丰富的组件，再配合WXSS，可以搭建出任何效果的界面。在功能层面上，也满足绝大部分需求。六、运行机制小程序启动会有两种情况，一种是「冷启动」，一种是「热启动」。 假如用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需将后台状态的小程序切换到前台，这个过程就是热启动；冷启动指的是用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动。小程序没有重启的概念当小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后（目前是5分钟）会被微信主动销毁当短时间内（5s）连续收到两次以上收到系统内存告警，会进行小程序的销毁七、更新机制小程序冷启动时如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上。 如果需要马上应用最新版本，可以使用 wx.getUpdateManager API 进行处理。八、性能优化主要的优化策略可以归纳为三点：精简代码，降低WXML结构和JS代码的复杂性；合理使用setData调用，减少setData次数和数据量；必要时使用分包优化。1、setData 工作原理小程序的视图层目前使用 WebView 作为渲染载体，而逻辑层是由独立的 JavascriptCore 作为运行环境。在架构上，WebView 和 JavascriptCore 都是独立的模块，并不具备数据直接共享的通道。当前，视图层和逻辑层的数据传输，实际上通过两边提供的 evaluateJavascript 所实现。即用户传输的数据，需要将其转换为字符串形式传递，同时把转换后的数据内容拼接成一份 JS 脚本，再通过执行 JS 脚本的形式传递到两边独立环境。而 evaluateJavascript 的执行会受很多方面的影响，数据到达视图层并不是实时的。2、常见的 setData 操作错误频繁的去 setData在我们分析过的一些案例里，部分小程序会非常频繁（毫秒级）的去setData，其导致了两个后果：Android下用户在滑动时会感觉到卡顿，操作反馈延迟严重，因为 JS 线程一直在编译执行渲染，未能及时将用户操作事件传递到逻辑层，逻辑层亦无法及时将操作处理结果及时传递到视图层；渲染有出现延时，由于 WebView 的 JS 线程一直处于忙碌状态，逻辑层到页面层的通信耗时上升，视图层收到的数据消息时距离发出时间已经过去了几百毫秒，渲染的结果并不实时；每次 setData 都传递大量新数据由setData的底层实现可知，我们的数据传输实际是一次 evaluateJavascript脚本过程，当数据量过大时会增加脚本的编译执行时间，占用 WebView JS 线程， 后台态页面进行 setData当页面进入后台态（用户不可见），不应该继续去进行setData，后台态页面的渲染用户是无法感受的，另外后台态页面去setData也会抢占前台页面的执行。总结大致从以上几个角度分析了小程序的底层架构，从小程序的由来、到双线程的出现、设计、通信、到基础库、Exparser 框架、再到运行机制、性能优化等等，都是一个个相关而又相互影响的选择。关于小程序的底层框架设计，应该还有很多，每一个框架的诞生都有其意义，我们作为开发者能做的不只是会使用这个工具，还应理解它的设计模式。只有这样才不会被工具左右，才能走的更远！"}
{"title": "项目功能整理：微信小程序生成二维码海报 ", "author": "2019-5-10 00:40", "pub_time": "2019-5-10 00:40", "content": "刚做完一个微信小程序的项目，现在对项目里的一些功能进行整理，这篇文章记录下如何在小程序里实现生成带有二维码的海报，并保存到用户相册。以此文章记录，便于后续项目使用。项目是基于mpvue做的。项目要求每个用户可以生成一个属于自己的推广二维码，拉新后记录推广人。生成的海报最终效果也不复杂，如图：下面保存图片是个白底的按钮，跟背景色混一块就看不到了。。。需求分析通过查阅微信小程序的文档得知，可以借助于小程序提供的canvas绘图功能根据设计图来绘制个canvas图，然后通过保存图片到相册这个API把图片保存到用户的手机相册。海报中有些内容是固定不变的，比如背景图、邀请话术以及下面长按图片的提示语，而还有些内容是动态的，比如用户名和小程序码，不同项目需求不一样，但都会有变动和不变两类内容，然后我们根据设计图一点一点把内容绘制到图上就行啦。知道要做什么了，那么我们来罗列下要做的事情（吉德林法则有云：把要解决的问题清清楚楚的列下来，问题就解决了一半）获取用户名获取用户专属小程序码图片绘制处理用户取消保存到相册的授权动手实现首先在页面里插入个canvas标签，并把它的位置调整到界面外。至于为啥是通过控制位置而不是控制显示隐藏，动手试过的兄弟都应该知道，优先级问题。<canvas class=\"cv-ct-canvas\" canvas-id=\"cv-pic\"></canvas>\r\n\r\n.cv-ct-canvas {\r\n  position: absolute;\r\n  left: 800rpx;\r\n  width: 300px;\r\n  height: 500px;\r\n}\r\n复制代码准备用户名、小程序码。因为我这里的背景图也是个远程图片，所以也一并要先下载。const { tempFilePath: bg } = await this.downloadFile('$(STATICFILE_URL)/prom-share-bg.png')\r\nlet name = this.userInfo.NickName;\r\n// 下载图片到本地\r\nconst { tempFilePath } = await this.downloadFile(this.qrcodeUrl);\r\n复制代码这里要说明下，这个downloadFile方法是把微信的downloadFile方法进行了同步处理，其实很简单，就是用个Promise包裹一下。往画布上逐个绘制。const ctx = wx.createCanvasContext(\"cv-pic\");\r\n// 填充背景色\r\nctx.setFillStyle(\"#f8f8f8\");\r\nctx.fillRect(0, 0, 300, 400);\r\nctx.fill();\r\nctx.setFillStyle(\"#ffffff\");\r\nctx.fillRect(0, 400, 300, 100);\r\nctx.fill();\r\n// 填充背景图\r\nctx.drawImage(bg, 30, 20, 240, 365);\r\n// 写入名字\r\nctx.setFontSize(15);\r\nctx.setFillStyle(\"#FFF9F0\");\r\nctx.fillText(name, 61, 300);\r\n// 写两行提示\r\nctx.setFillStyle(\"#322F30\");\r\nctx.setFontSize(14);\r\nctx.fillText(\"长按识别小程序码\", 33, 440);\r\nctx.fillText(\"超值礼包等你来抢\", 33, 465);\r\n// 填充小程序码\r\nctx.drawImage(tempFilePath, 0, 0, 280, 280, 200, 410, 80, 80);\r\nconst that = this;\r\n// 把canvas图保存到临时目录\r\nctx.draw(false, function() {\r\n  wx.canvasToTempFilePath({\r\n    canvasId: \"cv-pic\",\r\n    success(res) {\r\n      let url = res.tempFilePath;\r\n      that.savePic = url;\r\n    }\r\n  });\r\n});\r\n复制代码在最后用canvasToTempFilePath把图片先保存到了临时目录，并把临时目录的地址赋值给了savePic，因为界面上要展示这个图，所以在界面上会有个Image标签，这个标签的地址就是savePic。保存到用户相册，代码比较简单，直接上：if (!this.savePic) return;\r\n  const that = this;\r\n  wx.saveImageToPhotosAlbum({\r\n    filePath: this.savePic,\r\n    success: function() {\r\n      that.showSaveCode = false;\r\n      wx.showToast({\r\n        title: \"保存成功\",\r\n        icon: \"success\",\r\n        duration: 2000\r\n      });\r\n    },\r\n    fail: function () {\r\n      that.getWriteToAlbumSetting()\r\n    }\r\n  });\r\n复制代码对于最后这个fail里面的getWriteToAlbumSetting方法，下面作解释。处理用户拒绝授权 。对于需要用户授权的操作，我们现在是这么处理的：先在页面data里声明一个变量表示当前用户是否已经授权了，比如这里我声明了 canWriteToAlbum 用来表示是否可以保存图片到相册。然后在页面加载时，如在mounted钩子函数里执行一次getWriteToAlbumSetting这个方法，该方法主要是通过wx.getSetting获取当前用户是否已经授权，代码如下：async getWriteToAlbumSetting() {\r\n  // this.getSetting 方法也是对wx.getSetting的一个同步封装处理\r\n  let status = await this.getSetting('writePhotosAlbum')\r\n  // 因为用户第一次进行操作的时候，授权状态为undefined，只有在明确拒绝过的时候才会是false\r\n  if (status === true || status === undefined) {\r\n    this.canWriteToAlbum = true\r\n  } else {\r\n    this.canWriteToAlbum = false\r\n  }\r\n}\r\n复制代码在页面中，根据用户的授权情况，显示 表面相同其实不同 的操作按钮：<div class=\"cv-save\" @click=\"saveToPhotosAlbum\" v-if=\"canWriteToAlbum\">保存图片</div>\r\n<div class=\"cv-save\" @click=\"openAlbumSetting\" v-else>保存图片</div>\r\n复制代码至于为什么要这么做，当然还是因为小程序的限制啦。如果用户拒绝过授权，再次点击保存按钮，要弹出授权界面，而微信明确要求，弹出授权界面必须是用户直接点击按钮触发，所以只能这样实现了。openAlbumSetting代码如下：async openAlbumSetting() {\r\n  // 还是对微信API的同步封装\r\n  let status = await this.openSetting('writePhotosAlbum')\r\n  // false表示又拒绝了\r\n  if (status === false) return\r\n  // 只有明确授权了才进行保存到相册的操作\r\n  this.canWriteToAlbum = true\r\n  this.saveToPhotosAlbum()\r\n}\r\n复制代码"}
{"title": "小程序报错 “渲染层错误” Expect END descriptor with depth 0 but get another ... ", "author": "2019-5-10 00:53", "pub_time": "2019-5-10 00:53", "content": "项目中有几个页面在控制台出现这个“渲染层错误”，虽然不影响业务操作，怕存在潜在风险，今天抽时间找了下原因，解决这个问题。控制台报错日志如下：(中国标准时间) 渲染层错误Error: Expect END descriptor with depth 0 but get anotherat i.value (:39360/__pageframe__/__dev__/WAWebview.js:1)at Function.G [as _startCb] (:39360/__pageframe__/__dev__/WAWebview.js:1)at n (:39360/__pageframe__/__dev__/WAWebview.js:1)at h (:39360/__pageframe__/__dev__/WAWebview.js:1)at :39360/__pageframe__/__dev__/WAWebview.js:1at t.(:39360/appservice/anonymous function) (http://127.0.0.1:39360/__pageframe__/__dev__/WAWebview.js:1:94975)at :39360/__pageframe__/pageframe.html:1at :39360/__pageframe__/pageframe.html:1at :39360/__pageframe__/pageframe.html:1at Array.forEach (<anonymous>)截图： 主要找到了2个原因，记录分享一下：1、在js中操作中，把undefined赋值给了一个数组变量，假设变量名为arr;      在.wxml页面中使用了变量arr.       这个原因导致了报“渲染层错误”。处理了arr变量后，这个错误也就没有了 2、子组件的.wxml页面中使用了if造成了这个报错，后面把if判断改成style来控制隐藏显示，     然后也消除了这个“渲染层错误”。   未改前代码截图：改后代码截图：奇怪的是其他地方使用if并没有报这个错，原理还不清楚！"}
{"title": "基于云开发的小程序评论、点赞、收藏功能实现总结 ", "author": "2019-5-13 00:12", "pub_time": "2019-5-13 00:12", "content": "mini-blog 的详情页的功能按钮基本已经全部实现（除了生成海报功能），这里记录下整个实现过程和实际编码中的一些坑。实现思路实现文章的一些操作功能，最主要的还是评论，这是作者和读者之间沟通的桥梁，评论功能的衍生无非是细化作者和读者之间的互动，或者增加文章的传播，所以在动手开发时需要思考下你期望实现哪些功能，并对应功能进行细化。我一般的经验是，先在脑子里过一遍需要的功能和大致流程，然后在笔记稍微画下「最最基础的原型，相当于产品的角色」。然后就开始直接开始搭建页面和简单的交互「使用假数据，优先完成页面」，在构造页面的时候其实也能够补充最初想法上一些流程上的缺陷，这样在设计后端和数据库结构的时候可以补上，整体下来也基本比较完善了。回头看我的小程序的需求，首先肯定是操作，在文章底部需要有个操作栏，用于发送点评和其他一些操作，在参考了一些同类型的小程序之后，逐步实现自己的一套风格，样式截图如下：在有了功能之后，点评的数据需要有地方展示「通常是文章底部」，然后就有了文章底部的评论列表，样式如下：既然有 点赞 和 收藏 的功能按钮，是否用户需要看下我点赞和收藏的文章列表呢，所以在「我的」中就有相应的列表，样式如下：到这里，最最基础的功能基本差不多，接下来就要看后端是否能支持这些页面了「主要就是数据的保存和展示了」对于评论来说，肯定需要一个集合用于保存用户的评论，而对于用户的喜欢和收藏也需要一个集合来进行保存。所以根据页面我们就可以设计 mini_comments 和 mini_posts_related 两个集合。前者用于保存评论数据，后者用户保存用户操作与文章之间的关联。剩下的工作就是变现了，无非就是页面交互和数据的增删改查了。细节点解析关于评论数量目前在文章的集合中有个 totalComments 这个属性，当这篇文章每新增一个评论时，需要加1。最初在写这个的时候，每次都是先查再更新，两段式，原代码如下：let count=post.totalComments+1;\r\nlet result =await db.collection('mini_posts').doc(event.commentContent.postId).update({\r\n    data: {\r\n      totalComments: count\r\n    }\r\n  });后来看文档发现，可以使用 db.command.inc 这个指令，无需再查一遍，直接可对原字段加1，还能保证原子性。代码如下：const _ = db.command\r\nlet result = db.collection('mini_posts').doc(event.commentContent.postId).update({\r\n    data: {\r\n      totalComments: _.inc(1)\r\n    }\r\n  });关于新增子评论需要实现在某个评论下进行回复。在交互上，点击评论者的昵称或头像时，触发相应的点击事件，在事件中去记录相应的评论ID及必要数据，同时去设置焦点到评论框内：/**\r\n  * 点击评论内容回复\r\n  */\r\n  focusComment: function (e) {\r\n    let that = this;\r\n    let name = e.currentTarget.dataset.name;\r\n    let commentId = e.currentTarget.dataset.id;\r\n    let openId = e.currentTarget.dataset.openid;\r\n\r\n    that.setData({\r\n      commentId: commentId,\r\n      placeholder: \"回复\" + name + \":\",\r\n      focus: true,\r\n      toName: name,\r\n      toOpenId: openId\r\n    });\r\n  },利用云开发新增子评论时可以使用 db.command.push 来进行操作「更新指令，对一个值为数组的字段，往数组尾部添加一个或多个值」，往子评论集合中新增：/**\r\n * 新增子评论\r\n * @param {} event \r\n */\r\nasync function addPostChildComment(event) {\r\n\r\n  let task = db.collection('mini_posts').doc(event.postId).update({\r\n    data: {\r\n      totalComments: _.inc(1)\r\n    }\r\n  });\r\n  await db.collection('mini_comments').doc(event.id).update({\r\n    data: {\r\n      childComment: _.push(event.comments)\r\n    }\r\n  })\r\n  await task;\r\n}关于判断是否已收藏在文章第一次加载时，我们需要判断下该用户是否有对该文章有相关操作，如果有相应的收藏和点赞操作，在初始化时需要更新相应的功能图标,核心代码如下：/**\r\n   * 获取收藏和喜欢的状态\r\n   */\r\n  getPostRelated: async function (blogId) {\r\n    let where = {\r\n      postId: blogId,\r\n      openId: app.globalData.openid\r\n    }\r\n    let postRelated = await api.getPostRelated(where, 1);\r\n    let that = this;\r\n    for (var item of postRelated.data) {\r\n      if (config.postRelatedType.COLLECTION === item.type) {\r\n        that.setData({\r\n          collection: { status: true, text: \"已收藏\", icon: \"favorfill\" }\r\n        })\r\n        continue;\r\n      }\r\n      if (config.postRelatedType.ZAN === item.type) {\r\n        that.setData({\r\n          zan: { status: true, text: \"已赞\", icon: \"appreciatefill\" }\r\n        })\r\n        continue;\r\n      }\r\n    }\r\n  },至于其他一些交互细节和代码细节，可以自行阅读源码去体会，如果有任何疑问或者有更好的实现方式，也可以与我沟通。总结这里主要想分享实现一个功能时候的过程，有想法的时候如何一步步去成功变现。小程序本身不难，相应的文档也很详细，但是组装的过程和逻辑的实现需要自身去思考和体会。如果你的想法和流程都非常清晰，但还是没办法实现你的预期功能，那我建议你先放放，先把 html , css , javascript 熟悉下，再看几遍小程序的文档，也许你当时面临的问题就不再是问题了。"}
{"title": "display: flex;’布局下使用‘white-space: nowrap;’导致的问题 ", "author": "2019-5-13 00:21", "pub_time": "2019-5-13 00:21", "content": "需求：在item中实现布局预期效果为：左侧一个正圆形的用户头像，右侧的上方为该用户昵称、下方为个性签名（单行显示，超出实际能显示的最大宽度则用‘...’代替）。如图：代码：wxml布局:<view class=\"member-item\">\r\n    <image class=\"avatar\" src=\"\"></image>\r\n    <view class=\"info\">\r\n      <view class=\"name\">姓名</view>\r\n      <view class=\"signature\">这个人很懒，什么都没写。这个人很懒，什么都没写。</view>\r\n    </view>\r\n  </view>wxss样式：.member-item {\r\n  margin-top: 1px;\r\n  padding: 15rpx 30rpx;\r\n  display: flex;\r\n  flex-direction: row;\r\n  background-color: white;\r\n  width: auto;\r\n}\r\n \r\n.avatar {\r\n  background-color: whitesmoke;\r\n  width: 96rpx;\r\n  height: 96rpx;\r\n  border-radius: 50%;\r\n}\r\n.info {\r\n  display: flex;\r\n  flex-direction: column;\r\n  margin-left: 30rpx;\r\n  flex: 1;\r\n}\r\n.name {\r\n  font-size: 30rpx;\r\n  color: #333;\r\n  line-height: 48rpx;\r\n}\r\n.signature {\r\n  font-size: 28rpx;\r\n  color: #888;\r\n  line-height: 48rpx;\r\n  overflow: hidden;\r\n  text-overflow: ellipsis;\r\n  white-space: nowrap;\r\n}效果：问题：为了自适应屏幕大小，这里父布局采用flex，展示个性签名的view对应的class为signature，其中我通过“overflow: hidden; text-overflow: ellipsis; white-space: nowrap;”来实现单行显示，超出实际能显示的最大宽度则用‘...’代替的效果。但是在实际效果如上图所示，当内容超出实际可显示宽度时，挤压推出左侧布局以显示signature中的内容，导致左侧布局的变形甚至被挤出。解决办法：在signature的父布局info中添加样式 min-width: 0; 即可解决。"}
{"title": "小程序ColorUI框架完成3d轮播效果 ", "author": "2019-4-19 00:14", "pub_time": "2019-4-19 00:14", "content": "一、效果预览二、ColorUI克隆地址https://github.com/weilanwl/C...三、使用方法步骤一需要在红框文件中引入篮框的两个文件如下图：@import 'colorui.wxss';\r\n@import 'icon.wxss';步骤二打开下载的文件 打开demo目录3d轮播代码在swiper页面上（卡片式轮播效果），直接复制就好了四、总结其实做这个效果我踩了很多坑 在网上找大牛用微信swiper插件改出的3d轮播效果 已经使用上了 被领导说使用卡顿 又花时间重新想的这个办法 优点：使用流畅不卡顿 缺点：占太多内存 因为微信上传代码规定不能超过两兆 要是本身小程序内容很多可能就不能用这个方法了"}
{"title": "微信小程序：wxml中增加wxs脚本实现手机号/身份证等隐私信息显示 ... ", "author": "2019-4-19 00:34", "pub_time": "2019-4-19 00:34", "content": "在js中，我们需要将手机号带星号显示是很容易的事情，只需要调用字符串截断与拼接就可以了；但是，在wxml中，我们如何处理呢？微信小程序开发框架中有一个wxs，就是为了解决类似问题的，只需要在wmxl中引入wxs，就可以调用该类的方法，这一点和网页开发html中通过script引入js类似。wxs.jpg首先，在pages同一级有个wxs目录（没有的可以自己创建），所有的wxs都可以放在这里。subutil.wxs在subutil.wxs中新建一个sub方法，用于根据特定需求截取字符串，并显示为带 * 号的字符串（前startLength + 四个 * 号 + 后endLength位），如果字符串长度小于startLength + endLength，则返回原始字符串：/** * 处理字符串为****格式，中间显示四个*号 * str 需要处理的字符串 * startLength 前面显示的字符串长度 * endLength 后面显示的字符串长度 */var sub = function (str, startLength, endLength) {  if (str.length == 0 || str == undefined) {    return \"\";  }  var length = str.length;  if (length >= startLength + endLength) {    return str.substring(0, startLength) + \"****\" + str.substring(length - endLength, length);  } else {    return str;  }}module.exports = {  sub: sub}wxml引用使用以下代码引入wxs脚本：<!-- 引入wxs脚本 --><wxs src=\"../../wxs/subutil.wxs\" module=\"tools\" />在需要的地方通过以下方式调用即可：{{tools.sub(phoneNum, 3, 4)}}一个简单的手机号/身份证等隐私信息显示方法实现了，通过wxs，还可以在wxml中实现更多的内容；当然，建议尽量在js中把数据处理好，少在wxml中处理逻辑，wxs中也只定义少量工具方法..."}
{"title": "安卓手机微信7.0.4调试小程序抓包https请求失败的问题和解决 ", "author": "2019-4-19 00:57", "pub_time": "2019-4-19 00:57", "content": "注意：阅读本文需要一台已经root的安卓手机！说明系统：MacOS 10.13.6\r\n手机：小米6（已root）\r\n抓包工具：Charles\r\n微信版本：7.0.4现象安卓手机无法通过Charles代理抓包https请求，我前天（2019年04月16日）用的7.0.3不知道为什么能抓到，昨天手残更新到7.0.4就不行了。而iOS（iPhone5S 12.1.4）没有问题。查找相关资料，都说微信升级到版本7之后就限制了用户证书凭据。根据网上较多的推荐方案，建议把证书放在系统证书存放目录下，那这就 需要Root手机 了，如果没有，以下内容不适合阅读。接下来，我尝试将Charles生成的证书放在手机的系统证书中，并没有那么顺利，很失败！我慢慢来讲解一下。步骤生成Charles证书我们要生成一个可以存放在系统证书目录下的可被识别的证书。手机代理设置好了后，手机访问：<chls.pro/ssl>下载下来证书，名称是这样的 charles-proxy-ssl-proxying-certificate.pem （你把这个文件搞到电脑上，假设该证书存在电脑的路径： ~/charles-proxy-ssl-proxying-certificate.pem ）。在你的电脑 终端 通过这个命令生成一个hash值：openssl x509 -subject_hash_old -in ~/charles-proxy-ssl-proxying-certificate.pem可以看到输出了类似如下P750TM:webs whidy$ openssl x509 -subject_hash_old -in ~/certificate.pem \r\n07e87b3d\r\n-----BEGIN CERTIFICATE-----\r\nMIIFYjCCBEqgAwIBAgIGAWeQpfWHMA...\r\n....\r\n77JclxPc0UdJHi5rOf7w+LU8YZFPdMTLa/c2JjMlspt08UeQVDE=\r\n-----END CERTIFICATE-----将证书更名 07e87b3d.0 注意后缀！接下来你可以用任意手段将该文件拷贝至手机的 /system/etc/security/cacerts/ 目录，如果成功则再次尝试抓包，如果失败，请继续看。超级终端操作如果不嫌麻烦的话，你完全可以在安卓手机上面的超级终端（自行下载的工具）进行以下操作，但是我没有这样，我在MacOSX中启用adb连接操作手机，如果你正有此意，请按照我的方式操作。电脑终端执行以下命令（这里不介绍brew，不理解的自行学习）brew cask install android-platform-tools装好后，数据线连上手机，测试一下adb devices没报错，且大概出现以下信息则正常：List of devices attached\r\n* daemon not running; starting now at tcp:5037\r\n* daemon started successfully\r\nfa8a05fd    device然后获取root权限，尝试将文件 07e87b3d.0 拷贝到 /system/etc/security/cacerts/adb root获得权限后，直接执行下面命令将证书放入系统目录。push ~/07e87b3d.0 /system/etc/security/cacerts/如果成功了，请尝试抓包。如果提示失败，比如权限不足，只读啥的，反正大概错误信息如下：P750TM:/ whidy$ adb push ~/07e87b3d.0 /system/etc/security/cacerts/\r\nadb: error: failed to copy '/Users/whidy/07e87b3d.0' to '/system/etc/security/cacerts/07e87b3d.0': remote couldn't create file: Read-only file system\r\n/Users/whidy/07e87b3d.0: 0 files pushed. 0.0 MB/s (1947 bytes in 0.119s)那就要继续折腾了。网上抄到的chmod 777目前是不管用的。要通过mount的相关操作来解决这个问题。装载可写的system目录查看当前system目录挂载在哪里 mount ，可以得到大致如下：rootfs on / type rootfs (ro,seclabel,size=2828452k,nr_inodes=707113)\r\ntmpfs on /dev type tmpfs (rw,seclabel,nosuid,relatime,size=2912600k,nr_inodes=728150,mode=755)\r\ndevpts on /dev/pts type devpts (rw,seclabel,relatime,mode=600)\r\nproc on /proc type proc (rw,relatime,gid=3009,hidepid=2)\r\nsysfs on /sys type sysfs (rw,seclabel,relatime)\r\nselinuxfs on /sys/fs/selinux type selinuxfs (rw,relatime)\r\n/dev/block/dm-0 on /system type ext4 (ro,seclabel,relatime,discard,data=ordered)\r\ndebugfs on /sys/kernel/debug type debugfs (rw,seclabel,relatime)\r\nnone on /acct type cgroup (rw,relatime,cpuacct)\r\nnone on /dev/stune type cgroup (rw,relatime,schedtune)\r\ntmpfs on /mnt type tmpfs (rw,seclabel,relatime,size=2912600k,nr_inodes=728150,mode=755,gid=1000)\r\nnone on /config type configfs (rw,relatime)\r\nnone on /dev/memcg type cgroup (rw,relatime,memory)注意到 /dev/block/dm-0 on /system type ext4 (ro,seclabel,relatime,discard,data=ordered) 这一行，后面括号有个ro，代表readonly！接下来尝试修改为可写（ rw ）状态：mount -o rw,remount /dev/block/dm-0 /system如果成功了，就试试将文件拷贝进去，失败了，例如提示： '/dev/block/dm-0' is read-only，请继续阅读。这里参考 Android O, failed to mount /system, /dev/block/dm-0 is read only ，一顿操作！我这边是这样的：adb disable-verity\r\nadb reboot关闭验证是要重启设备的。执行重启后，继续：adb root\r\nadb remount\r\nadb shell再执行 mount 发现结果跟刚才不一样了，找到有system的那一行发现这样的/dev/block/sde43 on /system type ext4 (rw,seclabel,relatime,discard,data=ordered)已经可写了，我试试拷贝进去。执行 adb push ~/07e87b3d.0 /system/etc/security/cacerts/，出现以下结果：P750TM:/ whidy$ adb push ~/07e87b3d.0 /system/etc/security/cacerts/\r\n/Users/whidy/07e87b3d.0: 1 file pushed. 0.1 MB/s (1947 bytes in 0.022s)应该就完成了。再去我的小米6手机里面的 设置 > 更多设置 > 系统安全 > 加密与凭据 > 信任的凭据 > 系统 里面看看，滚到最低部，ok，证书导入成功了。再去抓包看看~我这文章是边写边记录的，现在可以看到https请求的抓包已经Ok啦~最后我建议最后还原之前操作的 disable-verity ，这样操作一下：adb root\r\nadb enable-verity\r\nadb reboot行了差不多就这些了。"}
{"title": "微信小程序组建通信 ", "author": "2019-4-22 00:22", "pub_time": "2019-4-22 00:22", "content": "子组件传递父组件需要用到triggerEvent方法，当子组件（自定义组件）点击button的时候调用triggerEvent方法传递一些数据，首先第一个属性为自定义名称（myevent）对应父组件（bind:myevent）名字是个标识必须相同，第二个参数就是要传递的数据，第三个参数是一些配置具体参考（https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/events.html）。父组件bind:myevent=\"onMyEvent\"事件绑定，通过e.detail.count来获取数据。//父组件，引用component-tag-name\r\n<component-tag-name bind:myevent=\"onMyEvent\" />\r\n\r\n//index.js\r\nComponent({\r\n    onMyEvent(e) {\r\n        e.detail.count // 自定义组件触发事件时提供的detail对象，结果为1\r\n    }\r\n})//子组件\r\n<button bindtap=\"onTap\">点击这个按钮将触发“myevent”事件</button>\r\n\r\n//index.js\r\nComponent({\r\n  properties: {},\r\n  methods: {\r\n    onTap() {\r\n      const myEventDetail = {count:1} // detail对象，提供给事件监听函数\r\n      const myEventOption = {} // 触发事件的选项\r\n      this.triggerEvent('myevent', myEventDetail, myEventOption)\r\n    }\r\n  }\r\n})"}
{"title": "上传小程序的代码时自动压缩 ", "author": "2019-4-22 00:34", "pub_time": "2019-4-22 00:34", "content": "为了节省开发时间，我们尽量整合现有业务线小程序代码，减少业务改动。目录结构同时为了后期计算各业务占用空间情况方便，我们直接将各业务线小程序工程代码拷贝到各自业务线目录下，最终的目录结构如下：.\r\n├── common # 通用模块/公共业务\r\n├── home   # 首页\r\n├── flight # 机票\r\n├── train  # 火车票\r\n├── bus    # 汽车票\r\n├── hotel  # 酒店\r\n└── ticket # 门票common 模块即工程的复用部分，具体业务代码都在各自目录下。总体架构如下：公共组件、API微信小程序其实并没有提供组件化开发的方式。只是提供了 template 的方式，所以我们只提供了为数不多的页面及组件，例如：城市定位、日历组件等。但是收益却是非常明显的，像这些页面大小都在 20KB~30KB，如果每个业务自己整一套可能将徒增上百 KB 代码。公共 API 我们提供了统一的 Watcher 监控、 Requester 请求、 Loading 加载转态、 Navigation 导航等。这些公共逻辑的抽取，为整个项目整合节省了巨大的空间，使 size 达标看起来不那么难了。工程复用上节省了很大一部分空间。但是空间是有限的，业务需求是无限的。而且，size 的大小会影响用户加载的速度，包括下载最新版本代码的速度和小程序初始化的速度，所以还需要进一步进行代码压缩。打包压缩工具微信开发者工具我们知道微信小程序开发者工具本身提供了『代码压缩上传』功能。但是个人觉得它是个『假的压缩选项』。因为在阅读开发者工具的源码逻辑之后，发现它的压缩，只是将 JavaScript 用 uglify 进行混淆压缩。而对 WXML、WXSS 没有进行任何压缩处理。同时，对资源路径中的无用文件也没有做处理。小程序的构建在小程序开发者工具的 Sources 面板，查看 JavaScript 脚本，会发现：项目中所有的 JavaScript 都会被 同步加载 ，不管是否被 require 。每个脚本都会被套上如下代码：define(\"some.js\", function(require,module){\r\n    // 原本的代码\r\n});这种加载方式类似 AMD，但是跟标准的 AMD 又有些不同，缺少了依赖部分的声明。而对于 WXSS 和 WXML 文件，则被开发者工具自动转换为 JavaScript 后加载，其中：WXSS：主要处理的是 import 逻辑，然后生成的 CSS，通过脚本的形式插入页面使用。WXML：类似于 React Naitive 的 JSX，被编译成 createElement 类似的形式。一些技巧在 MacOS 系统中，右键开发者工具『Show Contents』（显示包内容），就能在 Resources/app.nw/ 下找到相应的源码，完成路径如下： /Applications/wechatwebdevtools.app/Contents/Resources/app.nw/ 。源码都是压缩过后的 JavaScript 脚本，可以使用 js-beautity 进行格式化，以便于阅读。// 在源码目录的 app 目录下执行\r\nfind . -type f -name '*.js' -exec js-beautify -r -s 2 -p -f '{}' \\;在资源目录下: app/dist/app.js 的第 37 行 window.addEventListener(\"resize\", function() {}) 之前，加入 nw.Window.get().showDevTools(); 。之后每次打开微信开发者工具时，会自动启动针对『开发者工具』的开发者工具，并可以通过它调试微信的开发者工具。在打印日志时，不要用 console.log ，请使用 global.contentWindow.console.log 。这样，才能输出到上面所说的开发者工具的开发者工具的控制台里。（NW.js 的 Node JS Context 和 Webkit JS Context 是分开的， JavaScript 脚本运行在 Node 的 JS Context 中，因此，打印其实打印在 Node 的输出中，并不在  Webkit 的开发者工具的控制台中。 global.contentWindow 获取的是 Webkit 的 JS Context 里的 Window）使用这两点技巧，读者们可以优雅地去阅读微信开发者工具的源码了。在阅读源码，知道微信小程序的内部加载构建方式之后，我们可以针对性的对 JavaScript、WXML、WXSS 等代码文件进行打包压缩。压缩 JavaScript由于微信只是将 js 进行了混淆压缩，并没有打包合并成一个文件。所以我们提供了打包压缩工具将 js 文件合并压缩成一个 bundle.js 文件。合并成一个文件有以下好处：require 的长路径没了，脚本压缩效率变高代码合并在一起，混淆性越大文件合并，减少了 IO 次数，提升了加载效率上文说了 JavaScript 都会被同步加载，所以不用担心打包成一个文件后会延长小程序加载时间。那么打包压缩工具具体做了什么工作呢？小程序有一个统一的入口是 app.js ，而每个页面都有自己的入口 page.js利用 AST，将 page.js 里页面注册 Page(pageOpt) 代码改成 global.YPage(pageName, pageIndex)(pageOpt)pageName 页面路由pageIndex 是打包工具根据页面路由内部自动维护的// global.YPage 函数\r\nglobal.YPage = (pageName, index)=> {\r\n    return (pageOpt) => {\r\n        // 其他处理逻辑\r\n        global['p' + index] = ()=> {\r\n            Page(pageOpt);\r\n        }\r\n    }\r\n}这样 page.js 里实际是这样的代码global['p' + index] = ()=> {\r\n       Page(pageOpt);\r\n}这样并不会执行 Page(pageOpt) ，页面也没注册啊。这就是要达到的目的，继续往后看。将所有这些入口 require 到一个统一的入口文件中，然后用 webpack 打包压缩输出到 bundle.js 。require('app.js')\r\nrequire('page1.js')\r\nrequire('page2.js')\r\n...现在 page.js 里的代码都打包到单一文件 bundle.js 里了。将 page.js 内容替换成 global['p' + index]() ，这样第三步中的 Page(pageOpt) 不就可以执行注册页面了。最后一步，替换 app.js 内容为 require('./bundle.js') 即大功告成。压缩 WXML、WXSS、JSONWXML/<!--((.|\\n|\\r)*?)-->/gm 去除注释/\\\"\\n\\s*/g 去除换行WXSS直接用 uglifycssJSON直接 JSON.stringify(JSON.parse(...))这里，有些读者会可能提出两个疑问：空白字符、换行能有多少，减不了多少吧？开发者工具为什么不做对这些文件的压缩？关于第一个问题，一个约 1000KB 的代码，空白字符和换行大概有 10KB。在有上限的情况之下，10 KB 也是要珍惜的。关于第二个问题，个人认为微信开发者工具的开发者觉得没有必要去做。因为，WXML 和 WXSS 都会被转义成 JavaScript 脚本，在此过程中，不管 WXML 和 WXSS 是否被压缩，它们的转化结果是相同的。因此，压缩与否，对于最终产物是没有影响的（最终产物指在服务器二次打包后的结果，也是用户真正使用的）。但是，Size 是以本地打包上传的内容进行计算的，不进行此步压缩，会使微信服务端判定的 Size 增大。删除无用文件工程庞大了，肯定会存在很多无用的空目录，空文件，没有被 import 的 js 、 wxml 、 wxss 文件。删除这些无用文件不仅可以减小 size，还可以提升小程序加载时间。上文说了这些文件都会被转成 JavaScript 进行加载的，是会占用加载时间的。删除无用 JavaScript由于通过 webpack 打包，除了 page.js 、 bundle .js 文件，其他 js 文件都可以删掉。删除无用 WXML打包压缩工具在打包时，已经记录了所有页面的路由。遍历分析所有路由下的 wxml 文件，通过 xmldom 解析代码记录其他被 import 的 wxml 文件。最后遍历所有 wxml 文件，删除不在 import 列表里的无用 wxml 文件。删除无用 WXSS类似处理 WXML。遍历分析所有路由下的 wxss 文件，通过正则 /@import\\s*[\"']([^\"']+)[\"']/g 分析代码记录其他被 import 的 wxss 文件。最后遍历所有 wxss 文件，删除不在 import 列表里的无用 wxss 文件。代码级优化除了利用工具进行压缩，在编写代码时，也可以通过一些方法来减小体积，在这里简单列几点：使用 ES6 时，尽量不使用依赖 Runtime/Polyfill 的语法，例如 import 和 class 。图标使用 Iconfont。等等…最终效果经过打包工具的极限压缩处理，还有代码设计上的可复用性，目前我们七个业务线的微信小程序整合后代码编译包大小维持在 1300KB 左右。还剩余 730KB 的可用空间。结语希望此次在微信小程序整合上做的，工程化抽取公共逻辑、规范业务代码，通过工具进行针对性的代码打包压缩的实践能给大家带来一定的帮助再宏伟的目标，拆分下来，也只是一串串的代码而已；一串串的代码，细分来看，也只是一个一个的字母而已！也许，我做不到一晚上完成大神一小时随便敲打的项目，但为这一目标，每天添砖加瓦，我想我应该是可以完成的！"}
{"title": "微信小程序 封装路由 mini-router ", "author": "2019-4-22 00:38", "pub_time": "2019-4-22 00:38", "content": "1.介绍mini-router 是一个在微信小程序中使用的路由模块，主要用于在小程序中的路由模块化和解耦，解决小程序中的路由地址的硬编码。 Github: https://github.com/hellolad/mini-router原生路由：// 用法：1wx.navigateTo({  url: \"/pages/logs/logs\"})// 用法：2wx.navigateTo({  url: \"/pages/logs/logs\",  success(res) {    console.log(\"success\", res)   },  fail(err) {    console.log(\"fail\", err)  },  complete() {    console.log(\"complete\")  }})// 用法：3（传参）wx.navigateTo({  url: \"/pages/logs/logs?key=value\",})mini-router// 用法：1app.$router.push(\"logs\")// 用法：2app.$router.push(\"mine\")  .success(res => {    console.log(\"success: \", res)  })  .fail(err => {    console.log(\"fail: \", res)  })  .complete(_ => {    console.log(\"complete\")  })// 用法：3 (传参)app.$router.push(\"logs\", { key: value })2.使用方法// 第一步：导入router模块，并且在app.js里 给app设置一个属性$router// app.jsimport MiniRouter from './route/router'onLaunch: function () {  this.$router = new MiniRouter()},// 第二步：配置route文件夹中的pages模块 （url 直接复制app.json里的pages）export default [  {    url: 'pages/index/index',    name: 'index'  },  {    url: 'pages/article/article',    name: 'article'  },  {    url: 'pages/mine/mine',    name: 'mine'  },  {    url: 'pages/logs/logs',    name: 'logs'  },  {    url: 'pages/login/login',    name: 'login'  },  {    url: 'pages/next/next',    name: 'next'  }]// 第三步：在需要的文件里 使用app.$router.push(\"logs\")3.支持的方法目前mini-router支持微信小程序里的路由的所有方法，函数名对比:4.函数介绍push(name, params = null) 保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面reLaunch(name, params = null) 关闭所有页面，打开到应用内的某个页面 可传递参数 可跳转到Tabbar页面redirect(name, params = null) 关闭所有页面，打开到应用内的某个页面 可传递参数 不可重定向到Tabbar页面switchTab(name) 跳转到指定的Tabback(delta = 1, params = null) 关闭当前页面，返回上一页面或多级页面。 没有参数 代表返回上一页backHome(params = null) 关闭所有页面返回到首页5.错误处理当你输入一个在pages模块中找不到的路由时(log)，mini-router会抛出错误，例如：app.$router.push(\"log\", { log: \"这是一个Log\" })// 打印/*!! Not found page ->：[log] !!; [Component] Event Handler Error @ pages/index/index#bound handlePushLogs*/6.获取传递的参数mini-router内置了一个属性params，它会根据你跳转的页面，动态的更换当前属性的值。// 当我传递了一个参数 { log: \"这是一个Log\" }app.$router.push(\"logs\", { log: \"这是一个Log\" })// 然后我在下一个界面的onShow/onLoad里接收const params = app.$router.paramsparams.log // 这是一个Log参数存储在storage里，你可以通过小程序调试工具看到:mini-router params获取参数时，你不必知道它存储在storage里的key是什么，你只要拿app.$router.params就可以了7.反向传值mini-router 通过back或者backHome函数实现反向传值（反向携带参数）app.$router.back(1, { isLogin: false })// 中间页传值给最后一页，最后一页携带值给首页const { data } = app.$router.paramsapp.$router.backHome({ data })当你选择不携带参数返回时，在首页你将拿不到app.$router.params,因为mini-router会把params软删除，如果你需要的话，你还是可以从storage里拿到它。8.状态处理mini-router同小程序一样，提供三种状态success， fail， complete 不同于小程序，mini-router使用链式调用来处理这三种状态，app.$router.push(\"mine\")  .success(res => {    console.log(\"success: \", res)  })  .fail(err => {    console.log(\"fail: \", res)  })  .complete(_ => {    console.log(\"complete\")  })9.query方式传参上面的都是通过params传参，传的参数缓存在了storage里，新增加的query类型传参，将参数拼接到了url后面:/** * Query 方式传递参数 */handlePushLogsQuery() {  app.$router.push(\"logs\", { log: \"这是一个Log\", name: \"hellolad\"}, 'query')},handlePushLoginQuery() {  app.$router    .push(\"login\", { phoneNumber: \"1561900000000\" }, 'query')    .success(res => {      console.log(\"success: \", res)    })},handleReLaunchArticleQuery() {  app.$router.reLaunch(\"article\", { articleId: '10002' }, 'query')    .success(res => {      console.log(\"success: \", res)    })},handleRedirectLoginQuery() {  app.$router.redirect(\"login\", { phoneNumber: '1561900000000' }, 'query')    .success(res => {      console.log(\"success: \", res)    })},// 获取参数和普通的params传参获取参数一样:const { phoneNumber } = app.$router.params// 也可以在onLoad(options)里获取console.log(\"login options\", options)// 生成的url类似：/pages/login/login?phoneNumber=1561900000000寄语：对于前端来说，可以说初窥门径，想要更深入一步，还是要坚持不断的学习和看源码。mini-router可以实现小程序里路由的跳转，也将成为我下一个小程序使用的路由模块，如果有不足的地方欢迎题issuse，如果有好的想法，欢迎pull request。Github: https://github.com/hellolad/mini-router"}
{"title": "微信小程序Page对象重写 ", "author": "2019-4-23 00:21", "pub_time": "2019-4-23 00:21", "content": "关于重写微信小程序Page对象如下：let orgainPage = Page; // 保存原本的Page对象\r\nlet basePage = function (data) {\r\n  // 生成初始data，如果页面已经有该值不在重新赋值\r\n  if (typeof data.data.dataVal === 'undefined') {\r\n    data.data.dataVal = '具体值';\r\n  }\r\n  // 重写onLoad默认执行一些初始事件\r\n  let orgainOnLoad = data.onLoad;\r\n  data.onLoad = function (o) {\r\n    // 执行的初始事件 start\r\n\r\n    // 执行的初始事件 end\r\n    orgainOnLoad.call(this, o);\r\n  }\r\n  // 默认初始方法，如果页面已经有该方法不在重写该方法\r\n  if (typeof data.orgainFun !== 'function') {\r\n    data.orgainFun = function () {\r\n      // 执行具体函数 start\r\n\r\n      // 执行具体函数 end\r\n    }\r\n  }\r\n  return orgainPage(data);\r\n}; 重写后的Page可以直接挂到App里面App({\r\n  onLaunch() { },\r\n   // 直接挂到这边，新页面直接调用app.Base替换Page\r\n  Base: basePage,\r\n  globalData: {}\r\n})不直接重写Page是因为使用app.json插件时，不允许修改全局变量“Page”。 每个Page页面调用const app = getApp();\r\napp.Base({\r\n  data: {\r\n  }\r\n})页面必须有data,不然.call会报错。"}
{"title": "服务端使用 nodejs 获取带参微信小程序码图片 ", "author": "2019-4-23 00:25", "pub_time": "2019-4-23 00:25", "content": "服务器使用 nodejs 请求获取微信小程序图片的教程，附详细代码。\r\n\r\n\r\n此文于2018.09.19完成，无法保证现在微信小程序的接口没有改变。\r\n\r\n调研\r\n首先看微信小程序的 获取二维码 文档，可以看到微信支持三种接口，其中只有B接口没有生成个数限制，长远来看，我选择使用 B 接口。\r\n根据文档，要使用 B 接口生成小程序码，就需要一个 access_token，这个 token 可以通过另一个接口传入appId和密钥来获得。详情看 该接口文档。\r\n实现\r\n获取 access_token\r\nnodejs 的版本为 8.x。\r\n考虑到服务端发送的请求并不多，不打算引入 request、axios 之类的三方库，用原生 https 模块实现（其实我只是想学习 nodejs 的原生 api 哈）。\r\n首先，要获取 access_token，要用到 appid 和 appsecret。\r\nconst https = require('https');\r\nhttps.get(`https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=${appid}&secret=${appsecret}`, res => {\r\n    let resData = '';\r\n    res.on('data', data => {\r\n        resData += data;\r\n    });\r\n    res.on('end', () => {\r\n        resData = JSON.parse(resData);\r\n    })\r\n})\r\n复制代码通过 end 事件，我们获得了返回的完整的 JSON 对象 resData。\r\n如果参数正确的话，会返回 {\"access_token\":\"ACCESS_TOKEN\",\"expires_in\":7200} 这样的 JSON 对象。expires_in 指的是 token 的有效期时间，单位是秒，获取了这个对象后，我添加了一个 timestamp 属性，存储当前时间，来确定这个 access_token 什么时候过期。这个对象，你可以存在 global 下，但最好存到 redis，这样即使你重启服务器就不需要重新获取 access_token 了。\r\n获取小程序码图片\r\n有了 access_token，我们就可以通过 post 请求来获取图片二进制流了。\r\n发送 post 请求，要用到 https.request 方法，比 https.get 要复杂一点。\r\n首先我们用自带的 url 模块，将 url 字符串转换为 URL 对象。因为我们要用到 post 方法，并指定一些headers，所以还要给这个对象追加一些属性。 url 字符串转为对象有两种方法，一种是 new URL(<urlString>)，还有一个是 url.parse(<urlString>)。请不要使用第一种方式，因为给转换后的对象添加属性，然后转为 JSON 对象时，不会存在（具体原因不明，有空我研究下。）第二种方式生成的对象则没有这些问题。\r\n具体代码如下：\r\nconst url = require('url');\r\nlet options = url.parse(`https://api.weixin.qq.com/wxa/getwxacodeunlimit?access_token=${access_token}`);\r\n\r\n// 添加必要的属性\r\noptions = Object.assign(options, {\r\n    method: 'POST',\r\n    headers: {\r\n        // 'Content-Length': Buffer.byteLength(post_data),\r\n        'Content-Type': 'application/json',\r\n        'Content-Length': post_data.length,\r\n    }\r\n});\r\n复制代码这里的 post_data 其实就是请求主题里的数据。\r\n注意获取二维码的 api 文档里的 Bug & Tip 明确说明了, POST 参数需要转成 json 字符串，不支持 form 表单提交。\r\nconst post_data = JSON.stringify({\r\n    scene: '你要传的参数',      // 最多32个字符。\r\n    width: 200,               // 生成的小程序码宽度。\r\n});\r\n复制代码然后我们就可以用 https.request 方法去请求图片了\r\nlet req = https.request(options, (res) => {\r\n    let resData = '';\r\n    res.setEncoding(\"binary\");\r\n    res.on('data', data => {\r\n        resData += data;\r\n    });\r\n    res.on('end', () => {\r\n        // 微信api可能返回json，也可能返回图片二进制流。这里要做个判断。\r\n        // errcode:42001 是指 token 过期了，需要重新获取。40001 是指token格式不对或很久之前的token。\r\n        const contentType = res.headers['content-type'];\r\n        if ( !contentType.includes('image') ) {\r\n            console.log('获取小程序码图片失败，微信api返回的json为：')\r\n            console.log( JSON.parse(resData) )\r\n            return resolve(null);\r\n        }\r\n        const imgBuffer = Buffer.from(resData, 'binary');\r\n        resolve( {imgBuffer, contentType} );\r\n    });\r\n});\r\nreq.on('error', (e) => {\r\n    console.log('获取微信小程序图片失败')\r\n    console.error(e);\r\n});\r\nreq.write(post_data);   // 写入post请求的请求主体。\r\nreq.end();\r\n复制代码注意点：\r\n\r\n\r\n这里比较重要的是这个 res.setEncoding(\"binary\");，因为服务器默认返回的数据会编码为 utf8 格式，但我们只需要二进制，且二进制转 utf8 再转回二进制貌似会丢失数据（具体我还不知道为什么）。\r\n\r\n\r\n另外，这个返回的 req 对象，可以诸如 setHeader(name, value), getHeader(name), removeHeader(name) 的api，直到你使用 request.end() 才真正把请求发送出去。如果你忘了调用 request.end 而执行了代码，过了一段时间会报一个超时错误。\r\n\r\n\r\n考虑到返回的不一定是图片，也有可能返回 JSON，所以做了一些判断。\r\n\r\n\r\n如果参数比较固定，你可以把图片下载下来，将图片路径映射到 redis 上，做个缓存。用户第二次访问的时候，直接传对应的图片就行了。\r\n\r\n\r\n完整代码（仅供参考）\r\n下面是完整代码和一些简单的注释，另外因为使用了 Koa 框架，需要用到 async/await 的同步方式，我把请求包装成了 Promise。\r\nconst https = require('https');\r\nconst url = require('url');\r\n\r\nconst uid = '你要传的参数';\r\n\r\nconst S_TO_MS = 1000;  // 秒到毫秒的转换。\r\nif (!global.access_token || global.access_token.timestamp + global.access_token.expires_in * S_TO_MS <= new Date() - 300) {\r\n    // 过期，获取新的 token\r\n    const appid = '小程序的appId';\r\n    const appsecret = '密钥';\r\n\r\n    const accessTokenObj = await new Promise( (resolve, reject) =>{\r\n        https.get(`https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=${appid}&secret=${appsecret}`, res => {\r\n            let resData = '';\r\n            res.on('data', data => {\r\n                resData += data;\r\n            });\r\n            res.on('end', () => {\r\n                resolve( JSON.parse(resData) );\r\n            })\r\n        })\r\n    }).catch(e => {\r\n        console.log(e);\r\n    });\r\n    \r\n    // 这里应该加一个判断的，因为可能请求失败，返回另一个 JSON 对象。\r\n    global.access_token = Object.assign(accessTokenObj, {timestamp: +new Date()});\r\n}\r\n\r\nconst access_token = global.access_token.access_token;\r\n\r\nconst post_data = JSON.stringify({\r\n    scene: uid,     // 最多32个字符。\r\n    width: 200,     // 生成的小程序码宽度。\r\n});\r\n\r\nlet options = url.parse(`https://api.weixin.qq.com/wxa/getwxacodeunlimit?access_token=${access_token}`);\r\noptions = Object.assign(options, {\r\n    method: 'POST',\r\n    headers: {\r\n        'Content-Type': 'application/json',\r\n        'Content-Length': post_data.length,\r\n    }\r\n});\r\n\r\n// 获取图片二进制流\r\nconst {imgBuffer, contentType} = await new Promise((resolve, reject) => {\r\n    let req = https.request(options, (res) => {\r\n        let resData = '';\r\n        res.setEncoding(\"binary\");\r\n        res.on('data', data => {\r\n            resData += data;\r\n        });\r\n        res.on('end', () => {\r\n            // 微信api可能返回json，也可能返回图片二进制流。这里要做个判断。\r\n            const contentType = res.headers['content-type'];\r\n            if ( !contentType.includes('image') ) {\r\n                console.log('获取小程序码图片失败，微信api返回的json为：')\r\n                console.log( JSON.parse(resData) )\r\n                return resolve(null);\r\n            }\r\n            const imgBuffer = Buffer.from(resData, 'binary');\r\n            resolve( {imgBuffer, contentType} );\r\n        });\r\n    });\r\n    req.on('error', (e) => {\r\n        console.log('获取微信小程序图片失败')\r\n        console.error(e);\r\n    });\r\n    req.write(post_data);   // 写入 post 请求的请求主体。\r\n    req.end();\r\n}).catch(() => {\r\n    return null;\r\n});\r\n\r\nif (imgBuffer == null) {\r\n    ctx.body = {code: 223, msg: '获取小程序码失败'};\r\n    return;\r\n}\r\nctx.res.setHeader('Content-type', contentType);\r\nctx.body = imgBuffer;\r\n复制代码后面的话\r\n\r\n原生 api 有点繁琐，建议使用一些流行的请求库，可读性高且方便修改。\r\n微信 api 返回的图片流，是先获取到完整的二进制数据，再返回到客户端的。如果可以直接把传回来的每一个数据块直接发到客户端，无疑可以缩短响应时间，貌似这里可以进行优化。\r\n涉及到了编码和解码的问题，这块内容要多学习。\r\n\r\n参考\r\n\r\nwww.cnblogs.com/chyingp/p/c…\r\nwww.ruanyifeng.com/blog/2007/1…"}
{"title": "适用于小程序的 ES6 ", "author": "2019-4-23 00:56", "pub_time": "2019-4-23 00:56", "content": "JavaScript内部，字符以UTF-16的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode码点大于0xFFFF的字符），JavaScript会认为它们是两个字符。ES6新增了完全支持UTF-16的方法codePointAt()，该方法接受编码单元的位置而非字符位置作为参数，返回与字符串中给定位置对应的码位，即一个整数值var text = \"a\" ;\r\n\r\nconsole.log(text.charCodeAt(0)); // 55362\r\nconsole.log(text.charCodeAt(1)); // 57271\r\nconsole.log(text.charCodeAt(2)); // 97\r\n\r\nconsole.log(text.codePointAt(0)); // 134071\r\nconsole.log(text.codePointAt(1)); // 57271\r\nconsole.log(text.codePointAt(2)); // 97二、includes1. indexOf用来查找某个元素的位置，如果不存在就返回-1，但是不能判断是否有NaN的元素。2. Array.includes()函数判断是否包含某一元素，返回 true / false，不能定位元素，但是能判断 NaN。const arr1 = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', NaN]\r\nconsole.log('%s', arr1.indexOf(NaN)) // -1\r\nconsole.log(arr1.includes('c')) // true\r\nconsole.log(arr1.includes('z')) // false\r\nconsole.log(arr1.includes(NaN))  // true复制代码三、startsWith1. 确定字符串是否以指定字符串的字符开头，返回 true/false。注意：区分大小写！2. 接受两个参数：  第一个参数，要在此字符串开头搜索的字符；  第二个参数是指定从字符串开始的位置，默认从零开始 四、endsWith1. 从字符串的末尾开始查找五、repeat1. 返回一个新字符串，表示将原字符串重复n次let str1='a';\r\nlet str2=str1.repeat(3);\r\nconsole.log(str2)//aaa复制代码六、String.fromCodePoint七、copyWithin1. 用于操作当前数组自身，用来把某些位置的元素复制并覆盖到其他位置上去。2. 该函数有三个参数：  target：目的起始位置；  start：复制源的起始位置，可以省略，可以是负数；  end：复制源的结束位置，可以省略，可以是负数，实际结束位置是end-1。3. const arr1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\r\narr1.copyWithin(1, 3, 6)\r\nconsole.log('%s', JSON.stringify(arr1)) // [1,4,5,6,5,6,7,8,9,10,11]\r\n复制代码目标的位置不够的，能覆盖多少就覆盖多少const arr2 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\r\narr2.copyWithin(3)\r\nconsole.log('%s', JSON.stringify(arr2)) // [1,2,3,1,2,3,4,5,6,7,8]复制代码start和end都可以是负数，负数表示从右边数过来第几个const arr3 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\r\narr3.copyWithin(3, -3, -2)\r\nconsole.log(JSON.stringify(arr3)) // [1,2,3,9,5,6,7,8,9,10,11]复制代码八、find1. 查找目标元素，找到就返回该元素，找不到返回undefinedconst arr1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\r\nvar ret1 = arr1.find((value, index, arr) => { \r\nreturn value > 4\r\n})\r\nvar ret2 = arr1.find((value, index, arr) => { \r\nreturn value > 14\r\n})\r\nconsole.log('%s', ret1) // 5\r\nconsole.log('%s', ret2) // undefined复制代码九、findIndex1. 查找目标元素，找到就返回元素的位置，找不到就返回-1var ret3 = arr1.findIndex((value, index, arr) => { \r\nreturn value > 4\r\n}) \r\nvar ret4 = arr1.findIndex((value, index, arr) => { \r\nreturn value > 14\r\n})\r\nconsole.log('%s', ret3) // 4\r\nconsole.log('%s', ret4) // -1复制代码十、fill1. 使用制定的元素填充数组2. 参数：  value：填充值。  start：填充起始位置，可以省略。  end：填充结束位置，可以省略，实际结束位置是end-1。const arr1 = [1, 2, 3, 4, 5]\r\narr1.fill(7)\r\nconsole.log(arr1) // [7, 7, 7, 7, 7]复制代码十一、entries()，keys()和values() —— 用于遍历数组1. 区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历for (let index of ['a', 'b'].keys()) {\r\n console.log(index) // 0 1\r\n}复制代码十二、Array.from1. 将对象转换成数组2. 条件：  1）部署了Iterator接口的对象，比如：Set，Map，Array  2）类数组对象，就是一个对象必须有length属性，没有length，转出来的就是空数组。转换map转换set转换字符串Array.from('hello world') // [\"h\", \"e\", \"l\", \"l\", \"o\", \" \", \"w\", \"o\", \"r\", \"l\", \"d\"]复制代码Array.from('\\u767d\\u8272\\u7684\\u6d77') // [\"白\", \"色\", \"的\", \"海\"]复制代码类数组对象Array.from({\r\n  0: '0',\r\n  1: '1',\r\n  3: '3',\r\n  length:4\r\n}) \r\n// [\"0\", \"1\", undefined, \"3\"]复制代码Array.from({\r\n  0: 0,\r\n  1: 1\r\n})\r\n// []复制代码3. 参数： 1）被转换的的对象。 2）map函数。3）map函数中this指向的对象。let diObj = {\r\n  handle: function(n){\r\n    return n + 2\r\n  }\r\n}\r\nArray.from(\r\n  [1, 2, 3, 4, 5], \r\n  function (x){\r\n    return this.handle(x)\r\n  }, \r\n  diObj\r\n) // [3, 4, 5, 6, 7]复制代码十三、Array.of1. new Array()构造数组的时候，是有二意性的  构造时，传一个参数，表示生成多大的数组。  构造时，传多个参数，每个参数都是数组的一个元素。2.  将一个或多个值转换成数组 === new Array() 传多个参数 的情况"}
{"title": "微信小程序之自定义倒计时组件 ", "author": "2019-4-29 00:11", "pub_time": "2019-4-29 00:11", "content": "最近写小程序写上瘾了,业务上需要实现一个倒计时的功能,考虑到可拓展以及使用方便,便将其封装成组件(写习惯了JSX不得不吐槽小程序自定义组件的繁琐)萌新第一次在掘金写东西,东西比较简单可能拉低整个掘金的文章水平了(求轻喷~)需求可配置倒计时的时间倒计时结束后执行事件可配置倒计时时间的格式步骤先定义自定义组件的 properties ,这里有两个父组件传给该倒计时组件的参数 target 倒计时的时间, format 倒计时时间的格式properties: {\r\n    target: {\r\n      type: String,\r\n    },\r\n    format: {\r\n      type: Function,\r\n      default: null\r\n    }\r\n},\r\n复制代码定义组件生命周期函数lifetimes: {\r\n    attached() {\r\n      //组件创建时\r\n      this.setData({\r\n        lastTime: this.initTime(this.properties).lastTime,  //根据 target 初始化组件的lastTime属性\r\n      }, () => {\r\n        //开启定时器\r\n        this.tick();\r\n        //判断是否有format属性 如果设置按照自定义format处理页面上显示的时间 没有设置按照默认的格式处理\r\n        if (typeof this.properties.format === 'object') {\r\n          this.defaultFormat(this.data.lastTime)\r\n        }\r\n      })\r\n    },\r\n\r\n    detached() {\r\n      //组件销毁时清除定时器 防止爆栈\r\n      clearTimeout(timer);\r\n    },\r\n},\r\n复制代码微信小程序自定义组件的生命周期指的是指的是组件自身的一些函数，这些函数在特殊的时间点或遇到一些特殊的框架事件时被自动触发。其中，最重要的生命周期是 created attached detached ，包含一个组件实例生命流程的最主要时间点。具体微信自定义组件学习参考官方文档定义组件自身的状态/**\r\n * 组件的初始数据\r\n*/\r\ndata: {\r\n    d: 0, //天\r\n    h: 0, //时\r\n    m: 0, //分\r\n    s: 0, //秒\r\n    result: '',  //自定义格式返回页面显示结果\r\n    lastTime:''  //倒计时的时间错\r\n},\r\n复制代码组件自身的方法methods: {\r\n    //默认处理时间格式\r\n    defaultFormat: function(time) {\r\n      const day = 24 * 60 * 60 * 1000\r\n      const hours = 60 * 60 * 1000;\r\n      const minutes = 60 * 1000;\r\n\r\n      const d = Math.floor(time / day);\r\n      const h = Math.floor((time - d * day) / hours);\r\n      const m = Math.floor((time - d * day - h * hours) / minutes);\r\n      const s = Math.floor((time - d * day - h * hours - m * minutes) / 1000);\r\n      this.setData({\r\n        d,\r\n        h,\r\n        m,\r\n        s\r\n      })\r\n    },\r\n\r\n    //定时事件\r\n    tick: function() {\r\n      let {\r\n        lastTime\r\n      } = this.data;\r\n\r\n      timer = setTimeout(() => {\r\n        if (lastTime < interval) {\r\n          clearTimeout(timer);\r\n          this.setData({\r\n              lastTime: 0,\r\n              result: ''\r\n            },\r\n            () => {\r\n              this.defaultFormat(lastTime)\r\n              if (this.onEnd) {\r\n                this.onEnd();\r\n              }\r\n            }\r\n          );\r\n        } else {\r\n          lastTime -= interval;\r\n          this.setData({\r\n              lastTime,\r\n              result: this.properties.format ? this.properties.format(lastTime) : ''\r\n            },\r\n            () => {\r\n              this.defaultFormat(lastTime)\r\n              this.tick();\r\n            }\r\n          );\r\n        }\r\n      }, interval);\r\n    },\r\n\r\n    //初始化时间\r\n    initTime: function(properties) {\r\n      let lastTime = 0;\r\n      let targetTime = 0;\r\n      try {\r\n        if (Object.prototype.toString.call(properties.target) === '[object Date]') {\r\n          targetTime = Number(properties.target).getTime();\r\n        } else {\r\n          targetTime = new Date(Number(properties.target)).getTime();\r\n        }\r\n      } catch (e) {\r\n        throw new Error('invalid target properties', e);\r\n      }\r\n\r\n      lastTime = targetTime - new Date().getTime();\r\n      return {\r\n        lastTime: lastTime < 0 ? 0 : lastTime,\r\n      };\r\n    },\r\n    //时间结束回调事件\r\n    onEnd: function() {\r\n      this.triggerEvent('onEnd');\r\n    }\r\n  }\r\n复制代码defaultFormat :默认时间处理函数 tick :定时事件 initTime 初始化时间 onEnd :时间结束的回调倒计时组件 countDown.js 完整代码var timer = 0;\r\nvar interval = 1000;\r\nComponent({\r\n  /**\r\n   * 组件的属性列表\r\n   */\r\n  properties: {\r\n    target: {\r\n      type: String,\r\n    },\r\n    format: {\r\n      type: Function,\r\n      default: null\r\n    }\r\n  },\r\n\r\n  lifetimes: {\r\n    attached() {\r\n      //组件创建时\r\n      this.setData({\r\n        lastTime: this.initTime(this.properties).lastTime,  //根据 target 初始化组件的lastTime属性\r\n      }, () => {\r\n        //开启定时器\r\n        this.tick();\r\n        //判断是否有format属性 如果设置按照自定义format处理页面上显示的时间 没有设置按照默认的格式处理\r\n        if (typeof this.properties.format === 'object') {\r\n          this.defaultFormat(this.data.lastTime)\r\n        }\r\n      })\r\n    },\r\n\r\n    detached() {\r\n      //组件销毁时清除定时器 防止爆栈\r\n      clearTimeout(timer);\r\n    },\r\n  },\r\n\r\n  /**\r\n   * 组件的初始数据\r\n   */\r\n  data: {\r\n    d: 0, //天\r\n    h: 0, //时\r\n    m: 0, //分\r\n    s: 0, //秒\r\n    result: '',  //自定义格式返回页面显示结果\r\n    lastTime:''  //倒计时的时间错\r\n  },\r\n\r\n  /**\r\n   * 组件的方法列表\r\n   */\r\n  methods: {\r\n    //默认处理时间格式\r\n    defaultFormat: function(time) {\r\n      const day = 24 * 60 * 60 * 1000\r\n      const hours = 60 * 60 * 1000;\r\n      const minutes = 60 * 1000;\r\n\r\n      const d = Math.floor(time / day);\r\n      const h = Math.floor((time - d * day) / hours);\r\n      const m = Math.floor((time - d * day - h * hours) / minutes);\r\n      const s = Math.floor((time - d * day - h * hours - m * minutes) / 1000);\r\n      this.setData({\r\n        d,\r\n        h,\r\n        m,\r\n        s\r\n      })\r\n    },\r\n\r\n    //定时事件\r\n    tick: function() {\r\n      let {\r\n        lastTime\r\n      } = this.data;\r\n\r\n      timer = setTimeout(() => {\r\n        if (lastTime < interval) {\r\n          clearTimeout(timer);\r\n          this.setData({\r\n              lastTime: 0,\r\n              result: ''\r\n            },\r\n            () => {\r\n              this.defaultFormat(lastTime)\r\n              if (this.onEnd) {\r\n                this.onEnd();\r\n              }\r\n            }\r\n          );\r\n        } else {\r\n          lastTime -= interval;\r\n          this.setData({\r\n              lastTime,\r\n              result: this.properties.format ? this.properties.format(lastTime) : ''\r\n            },\r\n            () => {\r\n              this.defaultFormat(lastTime)\r\n              this.tick();\r\n            }\r\n          );\r\n        }\r\n      }, interval);\r\n    },\r\n\r\n    //初始化时间\r\n    initTime: function(properties) {\r\n      let lastTime = 0;\r\n      let targetTime = 0;\r\n      try {\r\n        if (Object.prototype.toString.call(properties.target) === '[object Date]') {\r\n          targetTime = Number(properties.target).getTime();\r\n        } else {\r\n          targetTime = new Date(Number(properties.target)).getTime();\r\n        }\r\n      } catch (e) {\r\n        throw new Error('invalid target properties', e);\r\n      }\r\n\r\n      lastTime = targetTime - new Date().getTime();\r\n      return {\r\n        lastTime: lastTime < 0 ? 0 : lastTime,\r\n      };\r\n    },\r\n    //时间结束回调事件\r\n    onEnd: function() {\r\n      this.triggerEvent('onEnd');\r\n    }\r\n  }\r\n})\r\n复制代码倒计时组件 countDown.wxml 完整代码<wxs src=\"../wxs/utils.wxs\" module=\"utils\" />\r\n<wxs src=\"../../comm.wxs\" module=\"comm\" />\r\n<view class=\"count-down\">\r\n  <text wx:if=\"{{result!==''}}\">{{result}}text>\r\n  <block wx:else>\r\n    <text wx:if=\"{{comm.numberToFixed(d)>0}}\">{{d}}天text>\r\n    <text>{{utils.fixedZero(h)}}text>\r\n    <text style=\"font-weight: 500\">:text>\r\n    <text>{{utils.fixedZero(m)}}text>\r\n    <text style=\"font-weight: 500\">:text>\r\n    <text>{{utils.fixedZero(s)}}text>\r\n  block>\r\nview>\r\n复制代码其中引入了两个wxs文件中的函数WXS（WeiXin Script）是小程序的一套脚本语言，结合 WXML，可以构建出页面的结构。官方文档function fixedZero(val) {\r\n  return val * 1 < 10 ? '0' + val : val;\r\n}\r\n//保留 pos位小数\r\nfunction numberToFixed(number, pos) {\r\n  if (number === null || number === '' || number < 0) return ''\r\n  return parseFloat(number).toFixed(pos)\r\n}\r\n复制代码组件使用引入方式\"usingComponents\": {\r\n    \"countDown\": \"../../../components/countDown/countDown\"\r\n  },\r\n复制代码代码演示<countDown bind:onEnd=\"getPageList\" format=\"{{formatTime}}\" target=\"{{creatTargetTime}}\" />\r\n复制代码const formatChinaDate = mss => {\r\n  let days = parseInt(mss / (1000 * 60 * 60 * 24));\r\n  let hours = parseInt((mss % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));\r\n  let minutes = parseInt((mss % (1000 * 60 * 60)) / (1000 * 60));\r\n  let seconds = parseInt((mss % (1000 * 60)) / 1000);\r\n  return days + ' 天 ' + hours + ' 小时 ' + minutes + ' 分钟 ' + seconds + ' 秒 ';\r\n};\r\ndata:{\r\n    formatTime:formatChinaDate,\r\n    creatTargetTime:1556428889000, //时间戳\r\n}\r\n\r\ngetPageList:function(){\r\n    //倒计时结束啦\r\n    console.log('倒计时结束啦')\r\n}\r\n复制代码"}
{"title": "在微信小程序与小游戏中使用 LeanCloud ", "author": "2019-4-29 00:37", "pub_time": "2019-4-29 00:37", "content": "微信小程序是一个全新的跨平台移动应用平台，小游戏是小程序的一个类目，在小程序的基础上开放了游戏相关的 API。LeanCloud 为小程序提供一站式后端云服务，为你免去服务器维护、证书配置等繁琐的工作，大幅降低你的开发和运维成本。本文说明了如何在微信小程序与小游戏中使用 LeanCloud 提供的各项服务。+Demo我们在小程序上实现了 LeanTodo 应用。在这个 Demo 中你可以看到：+如何集成 LeanCloud 用户系统，包括自动登录、unionid 绑定以及如何在登录后设置账号与密码以供用户在其他平台的 LeanTodo 应用上登录如何对云端数据进行查询、增加、修改与删除如何将查询结果数组绑定到视图层进行展示，以及如何在点击事件中得到对应的数组项如何使用 LiveQuery 实现对查询结果的实时更新和多端同步如何集成微信支付你可以通过微信扫描以下二维码进入 Demo。 Demo 的源码与运行说明请参考 https://github.com/leancloud/leantodo-weapp。+准备工作创建应用如果你还没有创建过 LeanCloud 应用，请登录 LeanCloud 控制台 创建一个新应用。如果你还没有小程序帐号，请访问 微信公众平台 注册一个小程序帐号。如果你不需要进行真机调试可以跳过这一步。下载 小程序开发工具，按照 小程序开发教程 创建一个项目。配置域名白名单请按照 小程序域名白名单配置 的步骤配置。如果你不需要进行真机调试可以跳过这一步（可在开发者工具的 详情 > 项目设置 中勾选不校验安全域名、TLS 版本以及 HTTPS 证书）。+安装与初始化 SDK要使用 LeanCloud 的结构化对象存储、文件存储、用户系统等功能，需要使用 LeanCloud 存储 SDK。存储 SDK 的安装与初始化请请参阅《JavaScript SDK 安装指南》中对应平台的说明。+安装存储 SDK 后即可在 app.js 中初始化应用：+// 获取 AV 命名空间的方式根据不同的安装方式而异，这里假设是通过手动导入文件的方式安装的 SDK\r\nconst AV = require('./libs/av-weapp-min.js');\r\nAV.init({\r\n  appId: '{{appid}}',\r\n  appKey: '{{appkey}}',\r\n});\r\n 要使用 LeanCloud 的即时通讯服务实现聊天等功能，需要使用 LeanCloud 即时通讯 SDK。即时通讯 SDK 是与存储 SDK 独立的 SDK，我们在单独的 即时通讯 章节介绍其安装与初始化的步骤。+结构化对象存储所有的结构化对象存储 API 都能正常使用，详细的用法请参考 JavaScript 数据存储开发指南。+数据绑定AV.Object 实例是一些携带很多信息与方法的对象，而小程序的存放渲染用数据的 data 字段需要的是 JSON 类型的数据，因此我们需要将 AV.Object 实例处理为 JSON 数据后再设置给 data。+以 LeanTodo Demo 中的 Todo 列表为例，要实现「将 AV.Query 查询结果 Todo 列表中的 content 与 done 字段展示为列表」的功能，我们可以定义一个 getDataForRender 来做上面说的「处理」：+const getDataForRender = todo => ({\r\n  content: todo.get('content'),\r\n  done: todo.get('done')\r\n});\r\n\r\nPage({\r\n  data: {\r\n    todos: []\r\n  },\r\n  onReady() {\r\n    new AV.Query('Todo')\r\n      .find()\r\n      .then(todos => this.setData({\r\n        todos: todos.map(getDataForRender)\r\n      }))\r\n      .catch(console.error);\r\n  }\r\n});AV.Object 提供了一个 #toJSON() 方法以 JSON 的形式返回其携带的有效信息。因此如果不考虑渲染性能，getDataForRender 可以简化为：+const getDataForRender = todo => todo.toJSON();使用 #toJSON() 会比手动 pick 需要的数据带来更多的性能消耗。这是因为小程序的 data 在逻辑层与渲染层之间是通过序列化后的字符串格式通讯的，过大的 data 结构会造成渲染耗时过久。因此对于结构复杂的 AV.Object，特别是如果是一个列表，手动 pick 需要的数据设置为 data 是一种常见的优化方法。+当然，每次 setData 时遇到不同结构中的 AV.Object 都要进行这样的处理会让代码充斥噪音，你可以使用各种技巧对此进行优化。这里分享一个 Demo 中使用的一个统一对 setData 的对象进行「处理」的 utility 方法 jsonify：+const isPlainObject = target =>\r\n  target &&\r\n  target.toString() == '[object Object]' &&\r\n  Object.getPrototypeOf(target) == Object.prototype;\r\nconst _jsonify = target => {\r\n  if (target && typeof target.toJSON === 'function') return target.toJSON();\r\n  if (Array.isArray(target)) return target.map(_jsonify);\r\n  return target;\r\n};\r\n\r\nconst jsonify = target =>\r\n  isPlainObject(target)\r\n    ? Object.keys(target).reduce(\r\n      (result, key) => ({\r\n        ...result,\r\n        [key]: _jsonify(target[key])\r\n      }),\r\n      {}\r\n    )\r\n    : _jsonify(target);jsonify 能正确的处理 AV.Object、AV.Object 数组以及其他类型的数据。使用时可以简单的在所有的 setData 之前对数据调用一次 jsonify 方法：+this.setData(jsonify({\r\n  todos, // AV.Object list\r\n  user, // AV.Object\r\n}));值得注意的是从 AV.Object 到 JSON 数据的处理是不可逆的，如果在之后还需要用到查询结果的 AV.Object，我们可以将其保存到 Page 实例上：+Page({\r\n  // todos 存放的是 AV.Object 列表，后续可以这些对象进行操作（比如调用其 save 方法），不参与渲染\r\n  todos: [],\r\n  data: {\r\n    // data.todo 存放的是 JSON 数据，供 WXML 页面渲染用\r\n    todos: []\r\n  },\r\n  onReady() {\r\n    new AV.Query('Todo')\r\n      .find()\r\n      .then(todos => {\r\n        this.todos = todos;\r\n        this.setData(jsonify({\r\n          todos\r\n        });\r\n      })\r\n      .catch(console.error);\r\n  },\r\n  saveAll() {\r\n    // 可以在这里获取到 this.todos 进行操作\r\n    return AV.Object.saveAll(this.todos)\r\n  }\r\n});你可能会在某些过时的文档或者 Demo 中看到直接使用 this.setData() 将 AV.Object 对象设置为当前页面的 data 的用法。我们 不再推荐这种用法。这是 SDK 针对小程序做的特殊「优化」，利用了小程序渲染机制中的一个未定义行为，目前已知在使用了自定义组件（usingComponents）时这种用法会失效。+文件存储在小程序中，可以将用户相册或拍照得到的图片上传到 LeanCloud 服务器进行保存。首先通过 wx.chooseImage 方法选择或拍摄照片，得到本地临时文件的路径，然后按照下面的方法构造一个 AV.File 将其上传到 LeanCloud：+wx.chooseImage({\r\n  count: 1,\r\n  sizeType: ['original', 'compressed'],\r\n  sourceType: ['album', 'camera'],\r\n  success: function(res) {\r\n    var tempFilePath = res.tempFilePaths[0];\r\n    // 使用本地临时文件的路径构造 AV.File\r\n    new AV.File('file-name', {\r\n      blob: {\r\n        uri: tempFilePath,\r\n      },\r\n    })\r\n      // 上传\r\n      .save()\r\n      // 上传成功\r\n      .then(file => console.log(file.url()))\r\n      // 上传发生异常\r\n      .catch(console.error);\r\n  }\r\n});上传成功后可以通过 file.url() 方法得到服务端的图片 url。+关于文件存储更详细的用法请参考 JavaScript 数据存储开发指南 · 文件。+用户系统小程序中提供了登录 API 来获取微信的用户登录状态，应用可以访问到用户的昵称、性别等基本信息。但是如果想要保存额外的用户信息，如用户的手机号码、收货地址等，或者需要在其他平台使用该用户登录，则需要使用 LeanCloud 的用户系统。+一键登录LeanCloud 的用户系统支持一键使用微信用户身份登录。要使用一键登录功能，需要先设置小程序的 AppID 与 AppSecret：+登录 微信公众平台，在 设置 > 开发设置 中获得 AppID 与 AppSecret。前往 LeanCloud 控制台 > 组件 > 社交，保存「微信小程序」的 AppID 与 AppSecret。这样你就可以在应用中使用 AV.User.loginWithWeapp() 方法来使用当前用户身份登录了。+AV.User.loginWithWeapp().then(user => {\r\n  this.globalData.user = user;\r\n}).catch(console.error);使用一键登录方式登录时，LeanCloud 会将该用户的小程序 openid 与 session_key 等信息保存在对应的 user.authData.lc_weapp 属性中，你可以在控制台的 _User 表中看到：+{\r\n  \"authData\": {\r\n    \"lc_weapp\": {\r\n      \"session_key\": \"2zIDoEEUhkb0B5pUTzsLVg==\",\r\n      \"expires_in\": 7200,\r\n      \"openid\": \"obznq0GuHPxdRYaaDkPOHk785DuA\"\r\n    }\r\n  }\r\n}如果用户是第一次使用此应用，调用登录 API 会创建一个新的用户，你可以在 控制台 > 存储 中的 _User 表中看到该用户的信息，如果用户曾经使用该方式登录过此应用（存在对应 openid 的用户），再次调用登录 API 会返回同一个用户。+用户的登录状态会保存在客户端中，可以使用 AV.User.current() 方法来获取当前登录的用户，下面的例子展示了如何为登录用户保存额外的信息：+// 假设已经通过 AV.User.loginWithWeapp() 登录\r\n// 获得当前登录用户\r\nconst user = AV.User.current();\r\n// 调用小程序 API，得到用户信息\r\nwx.getUserInfo({\r\n  success: ({userInfo}) => {\r\n    // 更新当前用户的信息\r\n    user.set(userInfo).save().then(user => {\r\n      // 成功，此时可在控制台中看到更新后的用户信息\r\n      this.globalData.user = user;\r\n    }).catch(console.error);\r\n  }\r\n});authData 默认只有对应用户可见，开发者可以使用 masterKey 在云引擎中获取该用户的 openid 与 session_key 进行支付、推送等操作。详情的示例请参考 支付。+小程序的登录态（session_key）存在有效期，可以通过 wx.checkSession() 方法检测当前用户登录态是否有效，失效后可以通过调用 AV.User.loginWithWeapp() 重新登录。+使用 unionid微信开放平台使用 unionid 来区分用户的唯一性，也就是说同一个微信开放平台帐号下的移动应用、网站应用和公众帐号（包括小程序），用户的 unionid 都是同一个，而 openid 会是多个。如果你想要实现多个小程序之间，或者小程序与使用微信开放平台登录的应用之间共享用户系统的话，则需要使用 unionid 登录。+要在小程序中使用 unionid 登录，请先确认已经在 微信开放平台 绑定了该小程序+在小程序中有很多途径可以 获取到 unionid。不同的 unionid 获取方式，接入 LeanCloud 用户系统的方式也有所不同。+一键登录时静默获取 unionid当满足以下条件时，一键登录 API AV.User.loginWithWeapp() 能静默地获取到用户的 unionid 并用 unionid + openid 进行匹配登录。+微信开放平台帐号下存在同主体的公众号，并且该用户已经关注了该公众号。微信开放平台帐号下存在同主体的公众号或移动应用，并且该用户已经授权登录过该公众号或移动应用。要启用这种方式，需要在一键登录时指定参数 preferUnionId 为 true：+AV.User.loginWithWeapp({\r\n  preferUnionId: true,\r\n});使用 unionid 登录后，用户的 authData 中会增加 _weixin_unionid 一项（与 lc_weapp 平级）：+{\r\n  \"authData\": {\r\n    \"lc_weapp\": {\r\n      \"session_key\": \"2zIDoEEUhkb0B5pUTzsLVg==\",\r\n      \"expires_in\": 7200,\r\n      \"openid\": \"obznq0GuHPxdRYaaDkPOHk785DuA\",\r\n      \"unionid\": \"ox7NLs5BlEqPS4glxqhn5kkO0UUo\"\r\n    },\r\n    \"_weixin_unionid\": {\r\n      \"uid\": \"ox7NLs5BlEqPS4glxqhn5kkO0UUo\"\r\n    }\r\n  }\r\n}用 unionid + openid 登录时，会按照下面的步骤进行用户匹配：+如果已经存在对应 unionid（authData._weixin_unionid.uid）的用户，则会直接作为这个用户登录，并将所有信息（openid、session_key、unionid 等）更新到该用户的 authData.lc_ewapp 中。如果不存在匹配 unionid 的用户，但存在匹配 openid（authData.lc_weapp.openid）的用户，则会直接作为这个用户登录，并将所有信息（session_key、unionid 等）更新到该用户的 authData.lc_ewapp 中，同时将 unionid 保存到 authData._weixin_unionid.uid 中。如果不存在匹配 unionid 的用户，也不存在匹配 openid 的用户，则创建一个新用户，将所有信息（session_key、unionid 等）更新到该用户的 authData.lc_ewapp 中，同时将 unionid 保存到 authData._weixin_unionid.uid 中。不管匹配的过程是如何的，最终登录用户的 authData 都会是上面这种结构。+LeanTodo Demo 便是使用这种方式登录的，如果你已经关注了其关联的公众号（搜索 AVOSCloud，或通过小程序关于页面的相关公众号链接访问），那么你在登录后会在 LeanTodo Demo 的 设置 - 用户 页面看到当前用户的 authData 中已经绑定了 unionid。+需要注意的是：+如果用户不符合上述静默获取 unionid 的条件，那么就算指定了 preferUnionId 也不会使用 unionid 登录。如果用户符合上述静默获取 unionid 的条件，但没有指定 preferUnionId，那么该次登录不会使用 unionid 登录，但仍然会将获取到的 unionid 作为一般字段写入该用户的 authData.lc_weapp 中。此时用户的 authData 会是这样的：+{\r\n  \"authData\": {\r\n    \"lc_weapp\": {\r\n      \"session_key\": \"2zIDoEEUhkb0B5pUTzsLVg==\",\r\n      \"expires_in\": 7200,\r\n      \"openid\": \"obznq0GuHPxdRYaaDkPOHk785DuA\",\r\n      \"unionid\": \"ox7NLs5BlEqPS4glxqhn5kkO0UUo\"\r\n    }\r\n  }\r\n}通过其他方式获取 unionid 后登录如果开发者自行获得了用户的 unionid（例如通过解密 wx.getUserInfo 获取到的用户信息），可以在小程序中调用 AV.User.loginWithWeappWithUnionId() 投入 unionid 完成登录授权：+AV.User.loginWithWeappWithUnionId(unionid, {\r\n  asMainAccount: true\r\n}).then(console.log, console.error);通过其他方式获取 unionid 与 openid 后登录如果开发者希望更灵活的控制小程序的登录流程，也可以自行在服务端实现 unionid 与 openid 的获取，然后调用通用的第三方 unionid 登录接口指定平台为 lc_weapp 来登录：+const unionid = '';\r\nconst authData = {\r\n  openid: '',\r\n  session_key: ''\r\n};\r\nconst platform = 'lc_weapp';\r\nAV.User.loginWithAuthDataAndUnionId(authData, platform, unionid, {\r\n  asMainAccount: true\r\n}).then(console.log, console.error);相对上面提到的一些 Weapp 相关的登录 API，loginWithAuthDataAndUnionId 是更加底层的第三方登录接口，不依赖小程序运行环境，因此这种方式也提供了更高的灵活度：+可以在服务端获取到 unionid 与 openid 等信息后返回给小程序客户端，在客户端调用 AV.User.loginWithAuthDataAndUnionId 来登录。也可以在服务端获取到 unionid 与 openid 等信息后直接调用 AV.User.loginWithAuthDataAndUnionId 登录，成功后得到登录用户的 sessionToken 后返回给客户端，客户端再使用该 sessionToken 直接登录。关联第二个小程序这种用法的另一种常见场景是关联同一个开发者帐号下的第二个小程序。+因为一个 LeanCloud 应用默认关联一个微信小程序（对应的平台名称是 lc_weapp），使用小程序系列 API 的时候也都是默认关联到 authData.lc_weapp 字段上。如果想要接入第二个小程序，则需要自行获取到 unionid 与 openid，然后将其作为一个新的第三方平台登录。这里同样需要用到 AV.User.loginWithAuthDataAndUnionId 方法，但与关联内置的小程序平台（lc_weapp）有一些不同：+需要指定一个新的 platform需要将 openid 保存为 uid（内置的微信平台做了特殊处理可以直接用 openid 而这里是作为通用第三方 OAuth 平台保存因此需要使用标准的 uid 字段）。这里我们以新的平台 weapp2 为例：+const unionid = '';\r\nconst openid = '';\r\nconst authData = {\r\n  uid: openid,\r\n  session_key: ''\r\n};\r\nconst platform = 'weapp2';\r\nAV.User.loginWithAuthDataAndUnionId(authData, platform, unionid, {\r\n  asMainAccount: true\r\n}).then(console.log, console.error);获取 unionid 后与现有用户关联如果一个用户已经登录，现在通过某种方式获取到了其 unionid（一个常见的使用场景是用户完成了支付操作后在服务端通过 getPaidUnionId 得到了 unionid）希望与之关联，可以在小程序中使用 AV.User#associateWithWeappWithUnionId()：+const user = AV.User.current(); // 获取当前登录用户\r\nuser.associateWithWeappWithUnionId(unionid, {\r\n  asMainAccount: true\r\n}).then(console.log, console.error);启用其他登录方式上述的登录 API 对接的是小程序的用户系统，所以使用这些 API 创建的用户无法直接在小程序之外的平台上登录。如果需要使用 LeanCloud 用户系统提供的其他登录方式，如用手机号验证码登录、邮箱密码登录等，在小程序登录后设置对应的用户属性即可：+// 小程序登录\r\nAV.User.loginWithWeapp().then(user => {\r\n  // 设置并保存手机号\r\n  user.setMobilePhoneNumber('13000000000');\r\n  return user.save();\r\n}).then(user => {\r\n  // 发送验证短信\r\n  return AV.User.requestMobilePhoneVerify(user.getMobilePhoneNumber());\r\n}).then({\r\n  // 用户填写收到短信验证码后再调用 AV.User.verifyMobilePhone(code) 完成手机号的绑定\r\n  // 成功后用户的 mobilePhoneVerified 字段会被置为 true\r\n  // 此后用户便可以使用手机号加动态验证码登录了\r\n}).catch(console.error);验证手机号码功能要求在 控制台 > 存储 > 设置 > 用户账号 启用「用户注册时，向注册手机号码发送验证短信」。+绑定现有用户如果你的应用已经在使用 LeanCloud 的用户系统，或者用户已经通过其他方式注册了你的应用（比如在 Web 端通过用户名密码注册），可以通过在小程序中调用 AV.User#associateWithWeapp() 来关联已有的账户：+// 首先，使用用户名与密码登录一个已经存在的用户\r\nAV.User.logIn('username', 'password').then(user => {\r\n  // 将当前的微信用户与当前登录用户关联\r\n  return user.associateWithWeapp();\r\n}).catch(console.error);即时通讯要使用 LeanCloud 的即时通讯服务实现聊天等功能，需要使用 LeanCloud 即时通讯 SDK。+安装与初始化请参阅《JavaScript SDK 安装指南》中对应平台的说明。+安装 SDK 后即可在 app.js 中初始化应用：+// Realtime 类获取的方式根据不同的安装方式而异，这里假设是通过手动导入文件的方式安装的 SDK\r\nconst { Realtime } = require('./libs/realtime.weapp.min.js');\r\nconst realtime = new Realtime({\r\n  appId: '{{appid}}',\r\n  appKey: '{{appkey}}',\r\n});\r\n 需要特别注意的是，小程序对 WebSocket 连接的数量是有限制的，因此推荐的用法是初始化 Realtime 一次，挂载到全局的 App 实例上，然后在所有需要的时候都使用这个 Realtime 实例。+// app.js\r\nconst { Realtime } = require('./libs/realtime.weapp.min.js');\r\nconst realtime = new Realtime({\r\n  appId: '{{appid}}',\r\n  appKey: '{{appkey}}',\r\n});\r\nApp({\r\n  realtime: realtime,\r\n  // ...\r\n});\r\n\r\n// some-page.js\r\nconst realtime = getApp().realtime;\r\n 即时通讯 SDK 的详细用法请参考 即时通讯开发指南。+富媒体消息要在小程序中使用即时通讯 SDK 的富媒体消息插件，有一些额外的约束：+安装存储 SDK 至 libs 目录，并将文件重命名为 leancloud-storage.js。安装即时通讯 SDK 至 libs 目录，并将文件重命名为 leancloud-realtime.js。下载 leancloud-realtime-plugin-typed-messages.js，移动到 libs 目录。必须保证三个文件在同一目录中。在 app.js 中依次加载 leancloud-storage.js、leancloud-realtime.js 和 leancloud-realtime-plugin-typed-messages.js。const AV = require('./libs/leancloud-storage.js');\r\nconst Realtime = require('./libs/leancloud-realtime.js').Realtime;\r\nconst TypedMessagesPlugin = require('./libs/leancloud-realtime-plugin-typed-messages.js').TypedMessagesPlugin;\r\nconst ImageMessage = require('./libs/leancloud-realtime-plugin-typed-messages.js').ImageMessage;在 app.js 中初始化应用：// 初始化存储 SDK\r\nAV.init({\r\n appId: '{{appid}}',\r\n appKey: '{{appkey}}',\r\n});\r\n// 初始化即时通讯 SDK\r\nconst realtime = new Realtime({\r\n appId: '{{appid}}',\r\n appKey: '{{appkey}}',\r\n plugins: [TypedMessagesPlugin], // 注册富媒体消息插件\r\n});\r\n 富媒体消息的用法请参考 即时通讯开发指南 - 富媒体消息。+数据绑定使用即时通讯 SDK，一个常见的需求是将 Conversation 与 Message 类型的数据绑定到视图层进行渲染。这里会遇到一些与结构化数据存储 SDK 一样的问题，其解决方案与最佳实践请参考结构化数据存储的 数据绑定 章节（Conversation 与 Message 都实现了 #toJSON 方法，上文中介绍的 jsonify 方法同样适用于Conversation 与 Message 实例）。+支付配置在开始之前，请确保已经在微信小程序后台开启了「微信支付」功能，然后按照下面的步骤配置云引擎环境变量：2进入应用控制台 - 云引擎 - 设置设置应用的二级域名并保存添加并保存以下环境变量WEIXIN_APPID：小程序 AppIdWEIXIN_MCHID：微信支付商户号WEIXIN_PAY_SECRET：微信支付 API 密钥（微信商户平台 - 账户设置 - API安全 - 密钥设置）WEIXIN_NOTIFY_URL：https://.leanapp.cn/weixin/pay-callback，其中 yourdomain 是第二步中设置的二级域名查看示例服务端开发首先确认本机已经安装 Node.js 运行环境和 LeanCloud 命令行工具，然后执行下列指令下载示例项目：+$ git clone https://github.com/leancloud/weapp-pay-getting-started.git\r\n$ cd weapp-pay-getting-started安装依赖：+npm install登录并关联应用：+lean login\r\nlean switch启动项目：+lean up之后你就可以在 localhost:3001 调试云函数了。+示例项目中与支付直接相关代码有三部分：+order.js：对应 Order 表，定义了部分字段的 getter/setter，以及 place 方法用于向微信 API 提交订单。cloud.js：其中定义了名为 order 的云函数，这个云函数会获取当前用户的 openid，以其身份创建了一个 1 分钱的 order 并下单，最后返回签名过的订单信息。routers/weixin.js：其中定义了 pay-callback 的处理函数，当用户支付成功后微信调用这个 URL，这个函数将对应的订单状态更新为 SUCCESS。请根据你的业务需要修改代码。参考文档：+微信支付统一下单 API 参数与错误码微信支付结果通知参数完成开发后部署到预备环境（若无预备环境则直接部署到生产环境）：+lean deploy客户端开发客户端完成一次支付需要分两步：+用户登录后，调用名为 order 的云函数下单，返回签名过的订单信息。调用支付 API（wx.requestPayment），传入上一步返回的订单信息，发起支付。AV.Cloud.run('order').then((data) => {\r\n  data.success = () => {\r\n    // 支付成功\r\n  });\r\n  data.fail = ({ errMsg }) => {\r\n    // 错误处理\r\n  });\r\n  wx.requestPayment(data);\r\n}).catch(error => {\r\n  // 错误处理\r\n})客户端的示例代码参见 Demo 打赏功能。参考文档：2小程序客户端发起支付 APIFAQ配置 download 合法域名时显示「该域名因违规被禁止设置。」请前往 控制台 > 存储 > 设置 > 文件 配置你自己的文件域名。+Access denied by api domain white list如果你的应用启用并配置了 Web 安全域名，你可能会 catch 到 Access denied by api domain white list 异常，请将提示的域名添加至应用的 Web 安全域名列表。+小程序真机上传数据时，控制台存储中显示的 Class 表名被压缩为单个字母。例如新建一个名为「Todo」的表，上传数据成功后进入控制台查看，其表名称显示为像 i、u 这样的单个字母。这是因为真机上代码会被压缩，解决办法是在创建 Class 后向 SDK 注册该 Class 的名字：AV.Object.register(Todo, 'Todo');。+反馈如果在微信小程序中使用 LeanCloud 时遇到问题，欢迎通过我们的 论坛 进行反馈。"}
{"title": "微信小程序怎么使用icon ", "author": "2019-4-30 00:21", "pub_time": "2019-4-30 00:21", "content": "小程序怎么使用icon第一步 下载icon我选择的图标库是阿里图标官网， 加入购物车第二步 转换ttf因为小程序的wxss文件的font-face的url不接受http地址作为参数,但可以接受base64,因此需将字体文件下载后,转换为base64，然后引用进入https://transfonter.org/平台点击Add fonts，添加iconfont.ttf勾选Base64 encode点击 convert 完成转换按照上图1,2,3的步骤 转换完成， 点击Download第三步 在微信小程序中使用icon解压 第二步中的文件夹找到stylesheet.css 文件打开第一步中压缩包的iconfont.css，把里面圈红的部分（即fontface部分我们不需要啦）复制到stylesheet.css修改后的stylesheet.css修改stylesheet.css的文件后缀为wxss，即stylesheet.wxss把stylesheet.wxss放进微信小程序的公共文件里面，然后把整个文件import到页面的样式表里在wxml页面引入使用完结"}
{"title": "使用 wx.getLocation() 获取用户位置并转化成真实描述文字 ", "author": "2019-4-12 00:10", "pub_time": "2019-4-12 00:10", "content": "解决问题：在小程序中获取用户的信息， 使用 wx.getLocation API, 在使用这个 API 之前需要首先设置用户授权.用户有可能在进入小程序的时候关闭了获取位置的权限， 当需要获取位置的时候要重新判断是否拥有权限。 如果没有权限需要再次提醒用户授权.wx.getLocation 接口返回的用户位置是经纬度形式的， 需要借助于 微信小程序JavaScript SDK 对返回的 latitude longitude 经纬度信息解析为 国家 省份 市 ... 的形式。设置用户授权小程序中部分接口是需要用户授权同意后才能调用的。 像 getUserInfo getLocation chooseAddress chooseInvoiceTitle getWeRunData 等。 当我们在小程序中需要使用这些接口的时候，首先都要用户用户授权才能使用， 我们可以使用 wx.openSetting 打开设置界面，引导用户开启授权。getLocation 除了需要用户授权外， 还需要在开发的时候在 app.json 配置地理位置用途说明;所以 第一步 我们需要在 app.json 文件中首先配置 地理位置用途说明app.json{\r\n    \"permission\": {\r\n        \"scope.userLocation\": {\r\n            \"desc\": \"你的位置信息将用于小程序位置接口的效果展示\"\r\n        }\r\n    }\r\n}\r\n复制代码获取经纬度信息第二步 在需要使用到 getLocation 接口的页面中的 xx.js 的 onLoad 方法中判断用户时候已经授权了 getLocation 的权限。使用 wx.getSetting 获取所有已授权接口。 该接口会返回一个 authSetting 对象， 里面包含了所有的授权结果。success(res) {\r\n   console.log(res.authSetting)\r\n   // res.authSetting = {\r\n   //   \"scope.userInfo\": true,\r\n   //   \"scope.userLocation\": true\r\n   // }\r\n }\r\n})\r\n复制代码所以我们可以在 onLoad 方法中使用 getSetting 方法判断用户是否授权了 userLocationonLoad: function() {\r\n    // 将当前页面的 this 赋值给 vm, 以区别于下面回调函数中的 this \r\n    const vm = this\r\n\r\n    wx.getSetting({\r\n      success(res) {\r\n        // 1. scope.userLocation 为真， 代表用户已经授权\r\n        if (res.authSetting['scope.userLocation']) {\r\n         // 1.1 使用 getlocation 获取用户 经纬度位置\r\n         wx.getLocation({\r\n             success(res){\r\n                 // 1.2 获取用户位置成功后，将会返回 latitude, longitude 两个字段，代表用户的经纬度位置\r\n                 console.log(res)\r\n\r\n                 // 1.3 将获取到的 经纬度传值给 getAddress 解析出 具体的地址\r\n                vm.getAddress(res.latitude, res.longitude)\r\n             }\r\n         })\r\n        }else {\r\n            // 2. 用户未授权的情况下， 打开授权界面， 引导用户授权.\r\n            wx.openSetting({\r\n                success(res) {\r\n                    // 2.1 如果二次授权允许了 userLocation 权限， 就再次执行获取位置的接口\r\n                    if (res.authSetting[\"scope.userLocation\"]) {\r\n                         wx.getLocation({\r\n                            success(res){\r\n                                // 2.2 获取用户位置成功后，将会返回 latitude, longitude 两个字段，代表用户的经纬度位置\r\n                                console.log(res)\r\n\r\n                                // 2.3 将获取到的 经纬度传值给 getAddress 解析出 具体的地址\r\n                                vm.getAddress(res.latitude, res.longitude)\r\n                            }\r\n                        })\r\n                    }\r\n                }\r\n            })\r\n        }\r\n      }\r\n    })\r\n}\r\n\r\n复制代码上面的代码的逻辑是: 当页面加载完成后， 1. 先获取用户授权列表。 并判断是否有 scope.userLocation 的权限.如果有权限， 直接调用 wx.getLocation 获取用户的位置。 将获取的经纬度位置传递给 getAddress 。 在 getAddress 方法中将会把 经纬度位置转换成实际的 国家 省份 市 格式的地址；如果没有权限，就使用 wx.openSetting 接口代开权限设置界面， 让用户进行二次授权。授权成功后执行 wx.getLocation --> getAddress 的方法。注意 注意 注意： wx.openSetting 接口在 2018年10月1号起用法已经改变， 像代码中直接使用 wx.openSetting 来打开授权页面已经不能使用了， 新版本的使用方法参考 打开小程序设置页（wx.openSetting）接口调整转化经纬度信息为 国家 省份 市在第二步， 已经拿到了经纬度的信息之后， 使用了一个 getAddress 的方法，来转化经纬度。在这个方法中需要使用 微信小程序JavaScript SDK 来作为工具。在使用 微信小程序JavaScript SDK 的时候需要先在 微信小程序JavaScript SDK 中注册账号， 并申请一个 key , 要想在小程序中使用这个 key 还需要 把这个 key 的 WebServiceAPI 勾选上使用 '微信小程序 JavaScriptSDK' 需要 下载微信小程序 JavaScriptSDK v1.2 文件 。 然后将微信小程序 JavaScriptSDK 文件引入到当前页面的 xx.js 中。// xx.js\r\nconst QQMapWX = require('../../utils/qqmap-wx-jssdk.js')\r\n复制代码最后实现 getAddress 方法:getAddress(latitude, longitude) {\r\n        // 生成 QQMapWX 实例\r\n        let qqmapsdk = new QQMapWX({\r\n            key: 'xxxx-xxxxx-xxxxx-xxxxx-xxxxx-xxxxx-xxxxx'\r\n        })\r\n\r\n        // reverseGeocoder 为 QQMapWX 解析 经纬度的方法\r\n        qqmapsdk.reverseGeocoder({\r\n            location: {latitude,longitude},\r\n            success(res) {\r\n                console.log('success', res)\r\n                vm.setData({\r\n                    // ad_info: res.result.ad_info\r\n                    // city： res.result.ad_info\r\n                })\r\n            }\r\n        })\r\n    }\r\n复制代码关于 reverseGeocoder 返回的详细信息可以查看 reverseGeocoder 返回信息"}
{"title": "微信小程序：如何防止数据重复插入？ ", "author": "2019-4-12 00:23", "pub_time": "2019-4-12 00:23", "content": "号外：为读者持续整理了几份最新教程，覆盖了 Spring Boot、Spring Cloud、微服务架构等PDF。获取方式：关注右侧公众号\"泥瓦匠BYSocket\"，来领取吧！摘要: 原创出处 https://www.bysocket.com 「公众号：泥瓦匠BYSocket 」欢迎关注和转载，保留摘要，谢谢！目录为啥要解决数据重复插入？解决方案实战可落地小总结一、为啥要解决数据重复插入？问题起源，微信小程序抽风 wx.request() 重复请求服务器提交数据。后端服务也很简单，伪代码如下：class SignLogService {\r\n    public void saveSignLog(SignLogDO log) {\r\n        // 简单插入做记录\r\n        SignLogDAO.insert(log);\r\n    }\r\n}发现数据库会存在重复数据行，提交时间一模一样。但业务需求是不能有多余的 log 出现，这明显是个问题。问题是，重复请求导致的数据重复插入。这问题造成的后果很明显：数据冗余，可能不单单多一条有些业务需求不能有多余数据，造成服务问题问题如图所示：解决方式：如何将 同请求 A，不执行插入，而是读取前一个请求插入的数据并返回。解决后流程应该如下：二、解决方案实战1.单库单表解决方案唯一索引 + 唯一字段幂等上面说的那种业务场景：sign_log 表会有 user_id、sign_id、sign_time 等。那么每次签到，每个人每天只有一条签到记录。数据库层采取唯一索引的形式，保证数据记录唯一性。即 UNIQUE 约束，UNIQUE 约束唯一标识数据库表中的每条记录。另外，user_id,sign_id,sign_time 三个组合适唯一字段。创表的伪代码如下：CREATE TABLE sign_log\r\n(\r\nid int NOT NULL,\r\nuser_id int NOT NULL,\r\nsign_id int,\r\nsign_time int,\r\nCONSTRAINT unique_sign_log UNIQUE (user_id,sign_id,sign_time)\r\n)重点是 CONSTRAINT unique_sign_log UNIQUE (user_id,sign_id,sign_time) 。有个小问题，数据量大的时候，每条记录都会有对应的唯一索引，比较耗资源。那么这样就行了吗？答案是不行，服务不够健壮。第一个请求插入成功，第二个请求直接报错，Java 服务会抛出 DuplicateKeyException 。简单的幂等写法操作即可，伪代码如下：class SignLogService {\r\n    public SingLogDO saveSignLog(SignLogDO log) {\r\n        // 幂等处理\r\n        SignLogDO insertLog = null;\r\n        try {\r\n            insertLog = signLogDAO.insert(log);\r\n        } catch (DuplicateKeyException e) {\r\n            insertLog = selectByUniqueKeys(userId,signId,signTime);\r\n        }\r\n\r\n        return insertLog;\r\n    }\r\n}的确，流量不是很大，也不算很高并发。重复写问题，这样处理即可。那大流量、高并发场景咋搞2.分库分表解决方案流量大了后，单库单表会演变成分库分表。那么基于单表的唯一索引形式，在碰到分表就无法保证呢，插入的地方可能是两个分表 A1 和 A2。解决思路：将数据的唯一性条件放到其他存储，并进行锁控制还是上面的例子，每天，每次签到，每个人只有一条签到记录。那么使用分布式锁 Redis 的解决方案。大致伪代码如下：a.加锁// 加锁\r\njedis.set(lockKey, requestId, \"NX\", \"PX\", expireTime);lockKey 最简单的是 user_id + sign_id + sign_timeexpireTime 设置为一天b.解锁// 解锁\r\njedis.eval(script, lockKey,requestId);c.幂等代码加强class SignLogService {\r\n    public SingLogDO saveSignLog(SignLogDO log) {\r\n\r\n        // 幂等校验\r\n        SignLogDO existLog = selectByUniqueKeys(userId,signId,signTime);\r\n        if(Objects.nonNull(existLog)) {\r\n            return existLog;\r\n        }\r\n\r\n        // 加锁\r\n        jedis.set\r\n\r\n        SignLogDO insertLog = signLogDAO.insert(log);\r\n\r\n        // 解锁\r\n        jedis.eval\r\n\r\n        return insertLog;\r\n    }\r\n}这个方案还是不是很成熟，大家参考下即可。三、可落地小总结解决方案实战中，了解具体术。归纳如下：幂等：保证多次同意请求后结果一致并发控制：单表唯一索引、分布式多表分布式锁降级兜底方案：分布式锁锁失效 – 考虑乐观锁兜底"}
{"title": "支付宝小程序微信小程序分享转发 ", "author": "2019-4-12 00:42", "pub_time": "2019-4-12 00:42", "content": "由于业务需求最近对支付宝小程序和微信小程序的分享功能做了一些了解和尝试，进而写撰写此文作为积累和总结。\r\n微信小程序\r\n微信小程序触发分享有两种方式设置onShareAppMessage和button添加open-type=\"share\"属性\r\n微信 onShareAppMessage\r\n在page中添加onShareAppMessage方法，然后点击右上角菜单就会有分享选项，如果没有定义onShareAppMessage右上角菜单就没有分享选项\r\n微信自定义转发内容\r\n\r\n使用默认截图\r\n1.5.0\r\n\r\n\r\n\r\n代码示意\r\npage({\r\n  data: {\r\n    shareData: {\r\n      title: '自定义转发标题',\r\n      imageUrl: 'xxxx.jpeg',\r\n      path: '/page/API/pages/share/share'\r\n    }\r\n  },\r\n\r\n  onShareAppMessage() {\r\n    return this.data.shareData\r\n  }\r\n})\r\n复制代码转发方式\r\n转发方式只能转发给朋友或者群聊效果如下\r\n\r\n微信动态生成带有用户标识的自定义分享图片\r\n只是单纯的将固定图片分享到群聊显然不够酷炫，现在另一个比较流行的做法是生成一个自定义的分享图片，但是这个流程已经脱离了小程原本的分享功能。\r\n该流程的大体思路是用户触发自定义的分享按钮，然后再小程序端用canvas动态的绘制一个带有当前用户标识的图片存储到用户的相册中，之后用户在手动的将图片转发到朋友圈\r\n微信 open-type=\"share\"\r\nbutton组件设置open-type=\"share\"点击button触发分享，open-type=\"share\"模式如果没有定义onShareAppMessage方法也会触发分享\r\n支付宝\r\n支付宝小程序触发分享的方式跟微信小程序相同也是两种方式设置onShareAppMessage和button添加open-type=\"share\"属性\r\n支付宝onShareAppMessage\r\n在page中添加onShareAppMessage方法，然后点击右上角菜单就会有分享选项，如果没有定义onShareAppMessage右上角菜单也有分享选项\r\n支付宝自定义转发内容\r\n\r\n\r\n\r\n字段\r\n类型\r\n必填\r\n描述\r\n最低版本\r\n\r\n\r\n\r\n\r\ntitle\r\nString\r\n是\r\n自定义分享标题\r\n无\r\n\r\n\r\ndesc\r\nString\r\n否\r\n自定义分享描述：由于分享到微博只支持最大长度 140 个字，因此建议长度不要超过该限制。\r\n无\r\n\r\n\r\npath\r\nString\r\n是\r\n自定义分享页面的路径，path中的自定义参数可在小程序生命周期的 onLoad方法中获取（参数传递遵循 http get 的传参规则）\r\n无\r\n\r\n\r\ncontent\r\nString\r\n否\r\n自定义吱口令文案，最多28个字符实际测试无效，咨询支付宝运营人员说是文字吱口令下线了\r\n1.7.0\r\n\r\n\r\nimageUrl\r\nString\r\n否\r\n自定义分享小图 icon 元素，支持：网络图片路径；apFilePath 路径；相对路径。使用场景详见下方说明\r\n1.4.0\r\n\r\n\r\nbgImgUrl\r\nString\r\n否\r\n自定义分享预览大图，建议尺寸750x825，支持：网络图片路径；apFilePath路径（客户端10.1.58版本开始支持）；相对路径\r\n（客户端 10.1.58 版本开始支持\r\n\r\n\r\nsuccess\r\nFunction\r\n否\r\n分享成功后回调\r\n1.4.0\r\n\r\n\r\nfail\r\nFunction\r\n否\r\n分享失败后回调\r\n1.4.0\r\n\r\n\r\n\r\n支付宝转发方式\r\n支付宝转发方式花样就比较多了详情可以参考官方文档\r\n这里单单提一下分享到微信，当用户点击微信的时候支付宝会自动将分享图片存入用户相册（此时支付宝还有文案提示告诉你生成了吱口令去微信粘贴但是现在并不好使，咨询运营人员才知道吱口令下线了）\r\n\r\n关于动态生成带有用户标识的自定义分享图片的尝试\r\n因为支付宝分享会自动截屏保存到相册中，所以当时思考了一下如果当拉起分享窗口的时候页面通过显隐控制的方式，将原本的页面隐藏将规划好的个性化分享页面显示出来，然后小程序进行截图保存，这样既能生成带有用户标识的分享图片，还能无缝衔接到分享流程中，说干就干一顿操作之后在Android手机中测试完美几乎完美，可以天不遂人愿在IOS下失败了故放弃此方案。\r\n总结\r\n\r\n支付宝小程序和微信小程序分享API基本相同只是一些细节不太一样，最大的区别就是微信只能分享到群组或者好友，而支付宝提供了更多的方式\r\n遇见问题简单查查文档如果找不到头绪首选求助小程序交流群或者运营人员，因为小程序发展太快了有些问题能找到的资源并不多，而且官方文档更新的也不怎么及时，闷头踩坑的话有些得不偿失。\r\n信息具有实效性本文或者网上的其他文章或者官方文档皆不可全信一切以实践为准"}
